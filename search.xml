<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一、无人驾驶--路径规划算法：Dijkstra</title>
      <link href="/2021/11/13/7%E3%80%81%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/2%E3%80%81%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6-%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%EF%BC%9ADijkstra/"/>
      <url>/2021/11/13/7%E3%80%81%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/2%E3%80%81%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6-%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%EF%BC%9ADijkstra/</url>
      
        <content type="html"><![CDATA[<h3 id="2、Dijkstra"><a href="#2、Dijkstra" class="headerlink" title="2、Dijkstra"></a>2、Dijkstra</h3><h4 id="2-1、算法简介"><a href="#2-1、算法简介" class="headerlink" title="2.1、算法简介"></a>2.1、算法简介</h4><p>迪杰斯特拉算法是由荷兰计算机科学家狄克斯特拉于1959年提出的，因此又称为狄克斯特拉算法；</p><p>它是从一个节点遍历其余各个节点的最短路径算法，解决的是有权图中最短路径问题。</p><p>主要特点：从起点开始，采用贪心算法的策略，每次遍历到初始点距离最近且未访问过的顶点的邻接点，直到扩展到终点为止。</p><h4 id="2-2、算法思路"><a href="#2-2、算法思路" class="headerlink" title="2.2、算法思路"></a>2.2、算法思路</h4><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161052.png"></p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/路径规划/20211113161110.png"  /><p>如上图G=(V,E)是一个带权有向图，把图中节点集合V分成两组：</p><p>第一组为已经求出最短路径的节点集合（用S表示，初始时S只有一个源点，即：D(0),之后每求得一条最短路径，就将该节点加入到集合S中，指导全部节点都加入到S中，算法就结束了）；第二组为其余未确定最短路径的节点集合（U表示），按最短路径长度的递增次序把第二组的节点加入S中。在加入的过程中，总保持从源点V到S中节点的最短路径长度不大于从源点V到U中任何节点的最短路径长度。</p><p>此外，每个节点对应一个距离,S中的节点的距离就是从V到此节点的最短路径长度,U中的节点的距离，是从V到此节点只包含S中的节点为中间节点的当前最短路径长度。</p><h5 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h5><p>设D为起点，A为终点，找到D~A的最短路径</p><p>1、S中只包含起节点D（0）；U包含除S外的其它节点，如C节点，C与D相邻，所以C（3）表示C到D的距离为3，而F与D不相邻，所以设F到D的距离为∞。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161117.png"></p><p>2、在U中选出最短节点，这里为C（3），将C移到S中，并在U中删除。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161122.png"></p><p>3、按上述方法依次选出，在U中选出最短节点，此时为E（4），将E移到S中，并在U中删除。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161127.png"></p><p>4、此时就要对比D<del>C</del>B=13;D<del>C</del>F=9;D<del>E</del>F=6;D<del>E</del>G=12的距离，所以将F（6）移到S中，并在U中删除；</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161130.png"></p><p>5、依次按照上述方法推算</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161134.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161353.png"></p><p>6、直到U为空集，此时，可以得到最短距离：A(22) = D<del>E</del>F~A =4+2+16；</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161142.png"></p><h4 id="2-3、算法具体实现"><a href="#2-3、算法具体实现" class="headerlink" title="2.3、算法具体实现"></a>2.3、算法具体实现</h4><p>defColorMap.m文件：</p><blockquote><p>作用：生成栅格图</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[field,cmap]</span> = <span class="title">defColorMap</span><span class="params">(rows, cols)</span></span></span><br><span class="line">cmap = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>; ...       <span class="comment">% 1-白色-空地</span></span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; ...           <span class="comment">% 2-黑色-静态障碍</span></span><br><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; ...           <span class="comment">% 3-红色-动态障碍</span></span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>;...            <span class="comment">% 4-黄色-起始点 </span></span><br><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;...            <span class="comment">% 5-品红-目标点</span></span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>; ...           <span class="comment">% 6-绿色-到目标点的规划路径   </span></span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>];              <span class="comment">% 7-青色-动态规划的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 构建颜色MAP图</span></span><br><span class="line">colormap(cmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义栅格地图全域，并初始化空白区域</span></span><br><span class="line">field = <span class="built_in">ones</span>(rows, cols);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 障碍物区域</span></span><br><span class="line">obsRate = <span class="number">0.3</span>;</span><br><span class="line">obsNum = <span class="built_in">floor</span>(rows*cols*obsRate);</span><br><span class="line">obsIndex = randi([<span class="number">1</span>,rows*cols],obsNum,<span class="number">1</span>);</span><br><span class="line">field(obsIndex) = <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>getNeighborNodes.m文件：</p><blockquote><p>作用：搭建个节点之间的关系；实现查找当前父节点临近的周围8个子节点</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">neighborNodes</span> = <span class="title">getNeighborNodes</span><span class="params">(rows, cols, lineIndex, field)</span></span></span><br><span class="line">[row, col] = <span class="built_in">ind2sub</span>([rows,cols], lineIndex);</span><br><span class="line">neighborNodes = <span class="built_in">inf</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 查找当前父节点临近的周围8个子节点</span></span><br><span class="line"><span class="comment">% 左上节点</span></span><br><span class="line"><span class="keyword">if</span> row<span class="number">-1</span> &gt; <span class="number">0</span> &amp;&amp; col<span class="number">-1</span> &gt; <span class="number">0</span></span><br><span class="line">    child_node_sub = [row<span class="number">-1</span>, col<span class="number">-1</span>];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">1</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">1</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 上节点</span></span><br><span class="line"><span class="keyword">if</span> row<span class="number">-1</span> &gt; <span class="number">0</span></span><br><span class="line">    child_node_sub = [row<span class="number">-1</span>, col];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">2</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">2</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 右上节点</span></span><br><span class="line"><span class="keyword">if</span> row<span class="number">-1</span> &gt; <span class="number">0</span> &amp;&amp; col+<span class="number">1</span> &lt;= cols</span><br><span class="line">    child_node_sub = [row<span class="number">-1</span>, col+<span class="number">1</span>];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">3</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">3</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 左节点</span></span><br><span class="line"><span class="keyword">if</span>  col<span class="number">-1</span> &gt; <span class="number">0</span></span><br><span class="line">    child_node_sub = [row, col<span class="number">-1</span>];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">4</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">4</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 右节点</span></span><br><span class="line"><span class="keyword">if</span>  col+<span class="number">1</span> &lt;= cols</span><br><span class="line">    child_node_sub = [row, col+<span class="number">1</span>];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">5</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">5</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 左下节点</span></span><br><span class="line"><span class="keyword">if</span> row+<span class="number">1</span> &lt;= rows &amp;&amp; col<span class="number">-1</span> &gt; <span class="number">0</span></span><br><span class="line">    child_node_sub = [row+<span class="number">1</span>, col<span class="number">-1</span>];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">6</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">6</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 7.下节点</span></span><br><span class="line"><span class="keyword">if</span> row+<span class="number">1</span> &lt;= rows</span><br><span class="line">    child_node_sub = [row+<span class="number">1</span>, col];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">7</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">7</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 8.右下节点</span></span><br><span class="line"><span class="keyword">if</span> row+<span class="number">1</span> &lt;= rows &amp;&amp; col+<span class="number">1</span> &lt;= cols</span><br><span class="line">    child_node_sub = [row+<span class="number">1</span>, col+<span class="number">1</span>];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">8</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">8</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Dijkstra.m文件：</p><blockquote><p>具体的算法实现</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 基于栅格地图的机器人路径规划算法</span></span><br><span class="line"><span class="comment">% 第2节：Dijkstra算法</span></span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 栅格界面、场景定义</span></span><br><span class="line"><span class="comment">% 行数和列数</span></span><br><span class="line">rows = <span class="number">10</span>;</span><br><span class="line">cols = <span class="number">20</span>;</span><br><span class="line">[field,cmap] = defColorMap(rows, cols);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 起点、终点、障碍物区域</span></span><br><span class="line">startPos = <span class="number">2</span>;</span><br><span class="line">goalPos = rows*cols<span class="number">-2</span>;</span><br><span class="line">field(startPos) = <span class="number">4</span>;</span><br><span class="line">field(goalPos) = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 算法初始化</span></span><br><span class="line"><span class="comment">% S/U的第一列表示栅格节点线性索引编号</span></span><br><span class="line"><span class="comment">% 对于S，第二列表示从源节点到本节点已求得的最小距离，不再变更；</span></span><br><span class="line"><span class="comment">% 对于U，第二列表示从源节点到本节点暂时求得的最小距离，可能会变更</span></span><br><span class="line">U(:,<span class="number">1</span>) = (<span class="number">1</span>: rows*cols)&#x27;;</span><br><span class="line">U(:,<span class="number">2</span>) = <span class="built_in">inf</span>;</span><br><span class="line">S = [startPos, <span class="number">0</span>];</span><br><span class="line">U(startPos,:) = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">% 更新起点的邻节点及代价</span></span><br><span class="line">neighborNodes = getNeighborNodes(rows, cols, startPos, field);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">    childNode = neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 判断该子节点是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isinf</span>(childNode)</span><br><span class="line">        idx = <span class="built_in">find</span>(U(:,<span class="number">1</span>) == childNode);</span><br><span class="line">        U(idx,<span class="number">2</span>) = neighborNodes(<span class="built_in">i</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% S集合的最优路径集合</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:rows*cols</span><br><span class="line">    path&#123;<span class="built_in">i</span>,<span class="number">1</span>&#125; = <span class="built_in">i</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">    childNode =  neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isinf</span>(neighborNodes(<span class="built_in">i</span>,<span class="number">2</span>))</span><br><span class="line">        path&#123;childNode,<span class="number">2</span>&#125; = [startPos,neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 循环遍历</span></span><br><span class="line"><span class="keyword">while</span> ~<span class="built_in">isempty</span>(U)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 在U集合找出当前最小距离值的节点,视为父节点，并移除该节点至S集合中</span></span><br><span class="line">    [dist_min, idx] = <span class="built_in">min</span>(U(:,<span class="number">2</span>));</span><br><span class="line">    parentNode = U(idx, <span class="number">1</span>);</span><br><span class="line">    S(<span class="keyword">end</span>+<span class="number">1</span>,:) = [parentNode, dist_min];</span><br><span class="line">    U(idx,:) = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 获得当前节点的临近子节点</span></span><br><span class="line">    neighborNodes = getNeighborNodes(rows, cols, parentNode, field);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 依次遍历邻近子节点，判断是否在U集合中更新邻节点的距离值</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 需要判断的子节点</span></span><br><span class="line">        childNode = neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">        cost = neighborNodes(<span class="built_in">i</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ~<span class="built_in">isinf</span>(childNode)  &amp;&amp; ~<span class="built_in">ismember</span>(childNode, S)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">% 找出U集合中节点childNode的索引值</span></span><br><span class="line">            idx_U = <span class="built_in">find</span>(childNode == U(:,<span class="number">1</span>));            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">% 判断是否更新</span></span><br><span class="line">            <span class="keyword">if</span> dist_min + cost &lt; U(idx_U, <span class="number">2</span>)</span><br><span class="line">                U(idx_U, <span class="number">2</span>) = dist_min + cost;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">% 更新最优路径</span></span><br><span class="line">                path&#123;childNode, <span class="number">2</span>&#125; = [path&#123;parentNode, <span class="number">2</span>&#125;, childNode];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 画栅格界面</span></span><br><span class="line"><span class="comment">% 找出目标最优路径</span></span><br><span class="line">path_opt = path&#123;goalPos,<span class="number">2</span>&#125;;</span><br><span class="line">field(path_opt(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>)) = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 画栅格图</span></span><br><span class="line">image(<span class="number">1.5</span>,<span class="number">1.5</span>,field);</span><br><span class="line">grid on;</span><br><span class="line">set(gca,<span class="string">&#x27;gridline&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;gridcolor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;GridAlpha&#x27;</span>,<span class="number">0.5</span>);</span><br><span class="line">set(gca,<span class="string">&#x27;xtick&#x27;</span>,<span class="number">1</span>:cols+<span class="number">1</span>,<span class="string">&#x27;ytick&#x27;</span>,<span class="number">1</span>:rows+<span class="number">1</span>);</span><br><span class="line">axis image;</span><br></pre></td></tr></table></figure><h5 id="2-3-1、程序详解"><a href="#2-3-1、程序详解" class="headerlink" title="2.3.1、程序详解"></a>2.3.1、程序详解</h5><p>①、 算法初始化</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 算法初始化</span></span><br><span class="line"><span class="comment">% S/U的第一列表示栅格节点线性索引编号</span></span><br><span class="line"><span class="comment">% 对于S，第二列表示从源节点到本节点已求得的最小距离，不再变更；</span></span><br><span class="line"><span class="comment">% 对于U，第二列表示从源节点到本节点暂时求得的最小距离，可能会变更</span></span><br><span class="line">U(:,<span class="number">1</span>) = (<span class="number">1</span>: rows*cols)&#x27;;</span><br><span class="line">U(:,<span class="number">2</span>) = <span class="built_in">inf</span>;</span><br><span class="line">S = [startPos, <span class="number">0</span>];</span><br><span class="line">U(startPos,:) = [];</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对U集合进程初始化，生成如下表，第一列未线性索引值，第二列为距离都设为∞</span><br><span class="line">U(:,<span class="number">1</span>) = (<span class="number">1</span>: rows*cols)&#x27;;</span><br><span class="line">U(:,<span class="number">2</span>) = <span class="built_in">inf</span>;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/路径规划/20211113161153.png" style="zoom:50%;" /><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%将初始节点放入S集合中，并设置它的距离为0；再U集合中删除初始节点！</span></span><br><span class="line">S = [startPos, <span class="number">0</span>];</span><br><span class="line">U(startPos,:) = [];</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161156.png"></p><p>②、更新起点的邻节点及代价</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 更新起点的邻节点及代价</span></span><br><span class="line">neighborNodes = getNeighborNodes(rows, cols, startPos, field);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">    childNode = neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 判断该子节点是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isinf</span>(childNode)</span><br><span class="line">        idx = <span class="built_in">find</span>(U(:,<span class="number">1</span>) == childNode);</span><br><span class="line">        U(idx,<span class="number">2</span>) = neighborNodes(<span class="built_in">i</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里调用了getNeighborNodes函数实现查找当前父节点临近的周围8个子节点</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161201.png"></p><blockquote><p>有三种情况：</p><p>①、两列都为inf，即这个节点不存在；</p><p>②、两个都是数字，即此节点存在，且为自由空间（可以走的节点）；</p><p>③、第一列是数字，第二列是inf，即此节点为障碍物</p></blockquote><p><code>for i = 1:8</code>；之后进行8次循环，判断该子节点是否存在，如果子节点存在，则将从父节点到子节点的距离存放到U集合中；</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161205.png"></p><blockquote><p>如上图中D是父节点，它有两个子节点C和E，那么就要再U集合中更新D到这两个节点的距离为3和4。</p></blockquote><p>③、S集合的最优路径集合</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% S集合的最优路径集合</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:rows*cols</span><br><span class="line">    path&#123;<span class="built_in">i</span>,<span class="number">1</span>&#125; = <span class="built_in">i</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">    childNode =  neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isinf</span>(neighborNodes(<span class="built_in">i</span>,<span class="number">2</span>))</span><br><span class="line">        path&#123;childNode,<span class="number">2</span>&#125; = [startPos,neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里是生成初始节点的最优路径</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161210.png"></p><p>④、进行循环，循环的条件是U集合不为空</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ~<span class="built_in">isempty</span>(U)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 在U集合找出当前最小距离值的节点,视为父节点，并移除该节点至S集合中</span></span><br><span class="line">    [dist_min, idx] = <span class="built_in">min</span>(U(:,<span class="number">2</span>));</span><br><span class="line">    parentNode = U(idx, <span class="number">1</span>);</span><br><span class="line">    S(<span class="keyword">end</span>+<span class="number">1</span>,:) = [parentNode, dist_min];</span><br><span class="line">    U(idx,:) = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 获得当前节点的临近子节点</span></span><br><span class="line">    neighborNodes = getNeighborNodes(rows, cols, parentNode, field);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 依次遍历邻近子节点，判断是否在U集合中更新邻节点的距离值</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 需要判断的子节点</span></span><br><span class="line">        childNode = neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">        cost = neighborNodes(<span class="built_in">i</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ~<span class="built_in">isinf</span>(childNode)  &amp;&amp; ~<span class="built_in">ismember</span>(childNode, S)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">% 找出U集合中节点childNode的索引值</span></span><br><span class="line">            idx_U = <span class="built_in">find</span>(childNode == U(:,<span class="number">1</span>));            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">% 判断是否更新</span></span><br><span class="line">            <span class="keyword">if</span> dist_min + cost &lt; U(idx_U, <span class="number">2</span>)</span><br><span class="line">                U(idx_U, <span class="number">2</span>) = dist_min + cost;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">% 更新最优路径</span></span><br><span class="line">                path&#123;childNode, <span class="number">2</span>&#125; = [path&#123;parentNode, <span class="number">2</span>&#125;, childNode];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>得出个节点的距离值，进行排序后得到最优路径！</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161215.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161221.png"></p><p>Dijkstra算法动态效果实现图：</p><p><img src="G:\我的程序人生\无人驾驶学习\文章总结\无人驾驶公司汇总\2.gif" alt="2"></p>]]></content>
      
      
      <categories>
          
          <category> 路径规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、vector容器</title>
      <link href="/2021/11/13/1%E3%80%81C++/3.C++%20STL/2%E3%80%81C++%20STL%EF%BC%9Avector%E5%AE%B9%E5%99%A8/"/>
      <url>/2021/11/13/1%E3%80%81C++/3.C++%20STL/2%E3%80%81C++%20STL%EF%BC%9Avector%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><p><strong>功能：</strong></p><ul><li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li></ul><p><strong>vector与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong></p><ul><li><strong>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</strong></li><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h4 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建vector容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v; </code>                            //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());   </code>       //将v[begin(), end())区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li></ul><p><strong>例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) </span><br><span class="line">    &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">100 100 100 100 100 100 100 100 100 100 </span><br><span class="line">100 100 100 100 100 100 100 100 100 100 </span><br></pre></td></tr></table></figure><h4 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</li></ul><p><strong>例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) </span><br><span class="line">    &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">v2 = v1;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v4;</span><br><span class="line">v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4  vector容量和大小"></a>3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>empty(); </code>                            //判断容器是否为空</p></li><li><p><code>capacity();</code>                      //容器的容量，一般是2的n次方</p></li><li><p><code>size();</code>                              //返回容器中元素的个数</p></li><li><p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​                                               //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>​                                                 //如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="keyword">if</span> (v1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">v1.<span class="built_in">resize</span>(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line">v1不为空</span><br><span class="line">v1的容量 = <span class="number">16</span></span><br><span class="line">v1的大小 = <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>这里要注意的是为什么v.capacity是16，因为vector的容量是2的n次方，这里因为vector存了10个数，因此capacity是2的4次方！</p></blockquote><p>总结：</p><ul><li>判断是否为空  — empty</li><li>返回元素个数  — size</li><li>返回容器容量  — capacity</li><li>重新指定大小  —  resize</li></ul><h4 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code>                                         //尾部插入元素ele</li><li><code>pop_back();</code>                                                //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code>                                                        //删除容器中所有元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">v1.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">v1.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span> </span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="number">100</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="number">1000</span> <span class="number">1000</span> <span class="number">100</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="number">1000</span> <span class="number">100</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插  — push_back</li><li>尾删  — pop_back</li><li>插入  — insert    (位置迭代器)</li><li>删除  — erase  （位置迭代器）</li><li>清空  —  clear  </li></ul><h4 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>       //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line">v1的第一个元素为： <span class="number">0</span></span><br><span class="line">v1的最后一个元素为： <span class="number">9</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code>  // 将vec与本身的元素互换</li></ul><p><strong>例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换容器</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">swap</span>(v2);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收缩内存</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换容器</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">swap</span>(v2);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收缩内存</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line">互换后</span><br><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line">v的容量为：<span class="number">131072</span></span><br><span class="line">v的大小为：<span class="number">100000</span></span><br><span class="line">v的容量为：<span class="number">131072</span></span><br><span class="line">v的大小为：<span class="number">3</span></span><br><span class="line">v的容量为：<span class="number">3</span></span><br><span class="line">v的大小为：<span class="number">3</span></span><br></pre></td></tr></table></figure><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预留空间</span></span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">p = &amp;v[<span class="number">0</span>];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num:<span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>]]></content>
      
      
      <categories>
          
          <category> C++-STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++-STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL--标准模板库</title>
      <link href="/2021/11/13/1%E3%80%81C++/3.C++%20STL/0%E3%80%81C++%20STL--%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
      <url>/2021/11/13/1%E3%80%81C++/3.C++%20STL/0%E3%80%81C++%20STL--%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h2 id="C-STL–标准模板库"><a href="#C-STL–标准模板库" class="headerlink" title="C++ STL–标准模板库"></a>C++ STL–标准模板库</h2><blockquote><p>声明：本文是在学习C++ STL–标准模板库的笔记，主要参考《C++ Prime》和《C++标准库》等。</p></blockquote><p>1、STL的诞生</p><p>为了建立数据结构和算法的一套标准，诞生了<strong>STL</strong></p><h3 id="2-2STL基本概念"><a href="#2-2STL基本概念" class="headerlink" title="2.2STL基本概念"></a>2.2STL基本概念</h3><ul><li><strong>标准模板库</strong></li><li>STL从广义上分为：<strong>容器、算法、迭代器</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接.</li><li>STL几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="2-3STL六大组件"><a href="#2-3STL六大组件" class="headerlink" title="2.3STL六大组件"></a>2.3STL六大组件</h3><p>STL大体分为六大组件，分别是：<strong>容器、算法、迭代器、仿函数、适配器(配接器)、空间配置器</strong></p><ol><li>容器:各种数据结构，如向量、列表、deque、Set、map等，用来存放数据。</li><li>算法:各种常用的算法，如排序、查找、复制、for_each等</li><li>迭代器:扮演了容器与算法之间的胶合剂.</li><li>仿函数:行为类似函数，可作为算法的某种策略.</li><li>适配器:一种用来修饰容器或者仿函数或迭代器接口的东西.</li><li>空间配置器:负责空间的配置与管理.</li></ol><p>2.4STL中容器、算法、迭代器</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构:数组，链表，树，栈，队列，集合，映射表等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种：</p><p><strong>序列式容器</strong>：：强调值的排序，序列式容器中的每个元素均有固定的位置。<strong>关联式容器</strong>：二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p>算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法:是指运算过程中会更改区间内的元素的内容.例如拷贝，替换，删除等等</p><p>非质变算法:是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p><strong>迭代器：</strong>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式.<strong>每个容器都有自己专属的迭代器</strong>。</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h2 id="3-STL-常用容器"><a href="#3-STL-常用容器" class="headerlink" title="3 STL-常用容器"></a>3 STL-常用容器</h2><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++STL/20211113110505.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++-STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++-STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、string--字符串容器</title>
      <link href="/2021/11/13/1%E3%80%81C++/3.C++%20STL/1%E3%80%81C++%20STL%EF%BC%9Astring%E5%AE%B9%E5%99%A8/"/>
      <url>/2021/11/13/1%E3%80%81C++/3.C++%20STL/1%E3%80%81C++%20STL%EF%BC%9Astring%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h2 id="3-1、string–字符串容器"><a href="#3-1、string–字符串容器" class="headerlink" title="3.1、string–字符串容器"></a>3.1、string–字符串容器</h2><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++STL/20211113113648.png"></p><h4 id="3-1-1、字符串基本概念本质："><a href="#3-1-1、字符串基本概念本质：" class="headerlink" title="3.1.1、字符串基本概念本质："></a>3.1.1、字符串基本概念<strong>本质：</strong></h4><p>字符串是C++风格的字符串，字符串本质上是一个<strong>类</strong></p><p><strong>字符串和char*区别：</strong></p><blockquote><p>char*是一个指针</p><p>字符串是一个类，类内部封装了 char* ，管理这个字符串，是一个char*型的容器。</p></blockquote><p><strong>特点：</strong></p><blockquote><p>字符串类内部封装了很多成员方法；</p><p>例如:查找查找，拷贝复制，删除删除替换替换，插入插入；</p><p>字符串管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责。</p></blockquote><h4 id="3-1-2字符串构造函数"><a href="#3-1-2字符串构造函数" class="headerlink" title="3.1.2字符串构造函数"></a>3.1.2字符串构造函数</h4><p>构造函数原型：</p><blockquote><p><code>string();</code>//创建一个空的字符串例如：Stringstr；<code>string(const char* s);</code>//使用字符串s初始化</p><p><code>string(const string&amp; str);</code>//使用一个字符串对象初始化另一个字符串对象</p><p><code>string(int n, char c);</code>//使用n个字符c初始化</p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;hello world！&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 = </span><br><span class="line">str2 = hello world！</span><br><span class="line">str3 = hello world！</span><br><span class="line">str3 = hello world！</span><br></pre></td></tr></table></figure><p>注：在使用sting容器时，要包含库文件：#include <string></p><h4 id="3-1-3字符串赋值操作"><a href="#3-1-3字符串赋值操作" class="headerlink" title="3.1.3字符串赋值操作"></a>3.1.3字符串赋值操作</h4><p>功能描述：</p><ul><li>给字符串字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code>//char*类型字符串赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>//把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>//字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>//把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>//把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>//把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>//用n个字符c赋给当前字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//赋值</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">string str1;</span><br><span class="line">str1 = &quot;hello world&quot;;</span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str2;</span><br><span class="line">str2 = str1;</span><br><span class="line">cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//字符赋值给当前的字符串</span><br><span class="line">string str3;</span><br><span class="line">str3 = &#x27;a&#x27;;</span><br><span class="line">cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str4;</span><br><span class="line">str4.assign(&quot;hello c++&quot;);</span><br><span class="line">cout &lt;&lt; &quot;str4 = &quot; &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str5;</span><br><span class="line">str5.assign(&quot;hello c++&quot;,5);</span><br><span class="line">cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//把字符串s赋给当前字符串</span><br><span class="line">string str6;</span><br><span class="line">str6.assign(str5);</span><br><span class="line">cout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//用n个字符c赋给当前字符串</span><br><span class="line">string str7;</span><br><span class="line">str7.assign(5, &#x27;x&#x27;);</span><br><span class="line">cout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1 = hello world</span><br><span class="line">str2 = hello world</span><br><span class="line">str3 = a</span><br><span class="line">str4 = hello c++</span><br><span class="line">str5 = hello</span><br><span class="line">str6 = hello</span><br><span class="line">str7 = xxxxx</span><br></pre></td></tr></table></figure><h4 id="3-1-4字符串拼接"><a href="#3-1-4字符串拼接" class="headerlink" title="3.1.4字符串拼接"></a>3.1.4字符串拼接</h4><p><strong>功能描述：</strong></p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator+=(const char* str);</code>//重载+=操作符</li><li><code>string&amp; operator+=(const char c);</code>//重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>//重载+=操作符</li><li><code>string&amp; append(const char *s); </code>//把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code>//把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>//同运算符+=(ConstString&amp;str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//字符串拼接</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;我&quot;;</span><br><span class="line"></span><br><span class="line">//重载+=操作符</span><br><span class="line">str1 += &quot;爱玩游戏&quot;;</span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str1 += &#x27;:&#x27;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str2 = &quot;LOL DNF&quot;;</span><br><span class="line"></span><br><span class="line">str1 += str2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str3 = &quot;I&quot;;</span><br><span class="line">str3.append(&quot; love &quot;);</span><br><span class="line">str3.append(&quot;game abcde&quot;, 4);</span><br><span class="line">//str3.append(str2);</span><br><span class="line">str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span><br><span class="line">cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-5字符串查找和替换"><a href="#3-1-5字符串查找和替换" class="headerlink" title="3.1.5字符串查找和替换"></a>3.1.5字符串查找和替换</h4><p><strong>功能描述：</strong></p><ul><li>查找:查找指定字符串是否存在</li><li>替换:在指定的位置替换字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>//查找str第一次出现位置，从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const; </code>//查找的第一次出现位置，从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const; </code>//从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const; </code>//查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>//查找str最后一次位置，从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>//查找的最后一次出现位置，从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>//从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const; </code>//查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>//替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s); </code>//替换从pos开始的n个字符为字符串s</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//查找和替换</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">//查找</span><br><span class="line">string str1 = &quot;abcdefgde&quot;;</span><br><span class="line"></span><br><span class="line">//查找str第一次出现位置，从pos开始查找</span><br><span class="line">int pos = str1.find(&quot;de&quot;);</span><br><span class="line"></span><br><span class="line">if (pos == -1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找str最后一次位置，从pos开始查找</span><br><span class="line">pos = str1.rfind(&quot;de&quot;);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">//替换</span><br><span class="line">string str1 = &quot;abcdefgde&quot;;</span><br><span class="line"></span><br><span class="line">str1.replace(1, 3, &quot;1111&quot;);</span><br><span class="line">//替换从pos开始n个字符为字符串str</span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">//test02();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找是从左往后，找到从右往左</li><li>找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4 id="3-1-6字符串比较"><a href="#3-1-6字符串比较" class="headerlink" title="3.1.6字符串比较"></a>3.1.6字符串比较</h4><p><strong>功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><blockquote><p>=返回 0</p><p>&gt;返回 1</p><p>&lt; 返回 -1</p></blockquote><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const; </code>//与字符串s比较</li><li><code>int compare(const char *s) const;</code>//与字符串s比较</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//字符串比较</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">string s1 = &quot;hello&quot;;</span><br><span class="line">string s2 = &quot;aello&quot;;</span><br><span class="line"></span><br><span class="line">int ret = s1.compare(s2);</span><br><span class="line"></span><br><span class="line">if (ret == 0) &#123;</span><br><span class="line">cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else if (ret &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 大于 s2</span><br></pre></td></tr></table></figure><p>总结:字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h4 id="3-1-7字符串字符存取"><a href="#3-1-7字符串字符存取" class="headerlink" title="3.1.7字符串字符存取"></a>3.1.7字符串字符存取</h4><p>字符串中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n); </code>//通过[]方式取字符</li><li><code>char&amp; at(int n); </code>//通过at方法获取字符</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//字符修改</span><br><span class="line">str[0] = &#x27;x&#x27;;</span><br><span class="line">str.at(1) = &#x27;x&#x27;;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h e l l o   w o r l d </span><br><span class="line">h e l l o   w o r l d </span><br><span class="line">xxllo world</span><br></pre></td></tr></table></figure><h4 id="3-1-8字符串插入和删除"><a href="#3-1-8字符串插入和删除" class="headerlink" title="3.1.8字符串插入和删除"></a>3.1.8字符串插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对字符串字符串进行插入和删除字符操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s); </code>//插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str); </code>//插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>//在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code>//删除从pos开始的n个字符</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//字符串插入和删除</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;hello&quot;;</span><br><span class="line">str.insert(1, &quot;111&quot;);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.erase(1, 3);  //从1号位置开始3个字符</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h111ello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p><h4 id="3-1-9字符串子串"><a href="#3-1-9字符串子串" class="headerlink" title="3.1.9字符串子串"></a>3.1.9字符串子串</h4><p><strong>功能描述：</strong></p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code>//返回由pos开始的n个字符组成的字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//获取子串</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">string str = &quot;abcdefg&quot;;</span><br><span class="line">string subStr = str.substr(1, 3);</span><br><span class="line">cout &lt;&lt; &quot;subStr = &quot; &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string email = &quot;hello@sina.com&quot;;</span><br><span class="line">int pos = email.find(&quot;@&quot;);</span><br><span class="line">string username = email.substr(0, pos);</span><br><span class="line">cout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subStr = bcd</span><br><span class="line">username: hello</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>]]></content>
      
      
      <categories>
          
          <category> C++-STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++-STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、C++14新特性：decltype（auto）类型推导</title>
      <link href="/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/4%E3%80%81decltype%EF%BC%88auto%EF%BC%89%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
      <url>/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/4%E3%80%81decltype%EF%BC%88auto%EF%BC%89%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h2 id="三、decltype（auto）"><a href="#三、decltype（auto）" class="headerlink" title="三、decltype（auto）"></a>三、decltype（auto）</h2><p>auto和decltype两个关键字都可以推导类型，但用法有所差异。</p><p>auto的使用更加方便，但是用途有限，只能用在赋值语句里；</p><p>decltype用途广，可以推导任意表达式的类型，但使用时必须在括号内写全表达式，用法略有不便。</p><p>因此C++14标准增加了一种新的语言，允许把这两者结合起来，也就是“**decltype(auto)**”，</p><p>使用decltype的语义推导类型，但是用的却是auto语法形式。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>（<span class="keyword">auto</span>） x = <span class="number">6</span>; <span class="comment">//整型类型int ，仅C++14</span></span><br><span class="line"><span class="keyword">decltype</span>（<span class="keyword">auto</span>） y = <span class="number">7L</span>; <span class="comment">//整型类型long ，仅C++14</span></span><br><span class="line"><span class="keyword">decltype</span>（<span class="keyword">auto</span>） z = x + y; <span class="comment">//整型类型long ，仅C++14</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、C++11新特性：指针空值--nullptr</title>
      <link href="/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/3%E3%80%81%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BC--nullptr/"/>
      <url>/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/3%E3%80%81%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BC--nullptr/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h2 id="四、指针空值–nullptr"><a href="#四、指针空值–nullptr" class="headerlink" title="四、指针空值–nullptr"></a>四、指针空值–nullptr</h2><blockquote><p>声明：该笔记是在学习《深入理解C++》、《C++11/14高级编程 Boost程序库探秘》时做的总结，方便以后巩固复习！</p></blockquote><h3 id="4-1、引入nullptr的意义："><a href="#4-1、引入nullptr的意义：" class="headerlink" title="4.1、引入nullptr的意义："></a><strong>4.1、引入nullptr的意义：</strong></h3><p>在C++程序开发中，为了提高代码的健壮性，一般会在定义指针的同时会完成初始化操作（避免出现野指针），在指针指向尚未明确的情况下，都会给指针初始化为空指针。在C++98/03标准中，将一个指针初始化为空指针的方式有两种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>在底层源码中 NULL 这个宏是这样定义的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看出,NULL可能被定义为字面常量0，或者是定义为无类型指针(void*)0。<strong>原因：</strong>由于 C++ 中，void * 类型无法隐式转换为其他类型的指针，此时使用 0 代替 ((void *)0)，用于解决空指针的问题。这个 0（0x0000 0000）表示的就是虚拟地址空间中的 0 地址，这块地址是只读的。但是无论采用什么样的定义方式，我们在使用空值的指针时，都不可避免地会遇到一些麻烦；</p><p>如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void func(char *c)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void func(int i)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 想要调用重载函数 void func(char *p)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">NULL</span>);  <span class="comment">//注：如果使用gcc编译，NULL转化为内部标识 __null,该语句会编译失败 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 想要调用重载函数 void func(int i)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>);    </span><br><span class="line">    </span><br><span class="line"><span class="built_in">func</span>((<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *c)</span></span></span><br></pre></td></tr></table></figure><p>虽然调用 func(NULL); 最终链接到的还是 void func(int p) 和预期是不一样的；原因：C++ 中将 NULL 定义为字面常量 0，并不能保证在所有场景下都能很好的工作，比如，函数重载时，NULL 和 0 无法区分；</p><p>在C++11新标准这，出于兼容性的考虑，字面常量0的二义性并没有被消除；但是标准为二义性给出了新的答案，就是使用nullptr；在C++11 新标准中，nullptr是一个所谓“<strong>指针空值类型</strong>”的常量；<strong>指针空值类型</strong>被命名为nullptr_t。</p><p>可以在支持nullptr的头文件（csddef）中找到如下定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="keyword">nullptr_t</span></span>;</span><br></pre></td></tr></table></figure><p>使用nullptr_t的时候必须#include<cstddef>（#include有些头文件也会间接#include<cstddef>，比如<iostream>），而nullptr则不用。</p><p>大概就是由于nullptr是关键字，而nullptr_t是通过推导而来的缘故。</p><p>对上述程序进行修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void func(char *c)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void func(int i)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用重载函数 void func(char *p)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">nullptr</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用重载函数 void func(int i)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br></pre></td></tr></table></figure><p><strong>可以看出，nullptr 无法隐式转换为整形，但是可以隐式匹配指针类型。在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。</strong></p><h3 id="4-2、nullptr和nullptr-t"><a href="#4-2、nullptr和nullptr-t" class="headerlink" title="4.2、nullptr和nullptr_t"></a>4.2、nullptr和nullptr_t</h3><p>C++11标准不仅定义了指针空值常量nullptr，也定义了其指针空值类型nullptr_t，也就表示了指针空值类型并非仅有nullptr一个实例。通常情况下，也可以通过nullptr_t来声明一个指针空值类型的变量（即使看起来用途不大）。</p><p>除去nullptr及nullptr_t以外，C++中还存在各种内置类型。C++11标准严格规定了数据间的关系。常见的规则简单地列在了下面：</p><blockquote><p>①、所有定义为nullptr_t类型的数据都是等价的，行为也是完全一致。</p><p>②、nullptr_t类型数据可以隐式转换成任意一个指针类型。</p><p>③、nullptr_t类型数据不能转换为非指针类型，即使使用reinterpret_cast<nullptr_t>()的方式也是不可以的。</p><p>④、 nullptr_t类型数据不适用于算术运算表达式。</p><p>⑤、nullptr_t类型数据可以用于关系运算表达式，但仅能与nullptr_t类型数据或者指针类型数据进行比较，当且仅当关系运算符为==、&lt;=、&gt;=等时返回true。</p></blockquote><h3 id="4-3、关于nullptr规则的一些讨论"><a href="#4-3、关于nullptr规则的一些讨论" class="headerlink" title="4.3、关于nullptr规则的一些讨论"></a>4.3、关于nullptr规则的一些讨论</h3><p>①、在C++11标准中，nullptr类型数据所占用的内存空间大小跟void*相同的，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">nullptr_t</span>) == <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*)</span><br></pre></td></tr></table></figure><p><em><em>注：那么nullptr是否是(void</em>)0的一个别名？</em>*</p><p>不是，尽管两者看起来很相似，都可以被转换为任何类型的指针，但两者在语法层面有着不同的内涵。nullptr是一个编译时期的常量，它的名字是一个编译时期的关键字，能够为编译器所识别。而(void*)0只是一个强制转换表达式，其返回的也是一个 void <em>指针类型。**最为重要的是，在C++语言中，nullptr到任何指针的转换是隐式的，而(void <em>)0则必须经过类型转换后才能使用。</em></em></p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、C++11新特性：decltype类型推导</title>
      <link href="/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/2%E3%80%81decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
      <url>/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/2%E3%80%81decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h2 id="二、decltype类型推导"><a href="#二、decltype类型推导" class="headerlink" title="二、decltype类型推导"></a>二、decltype类型推导</h2><h3 id="2-1、-decltype"><a href="#2-1、-decltype" class="headerlink" title="2.1、 decltype"></a>2.1、 decltype</h3><p>auto关键字能够在赋值语句里推导类型，但这只是C++语言里一种很少见的应用场景，要想在任意的场景都能够得到表达式的类型就需要使用关键字：<strong>decltype</strong></p><p>decltype的形式和函数调用很像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression)  <span class="comment">//获取表达式的类型--在编译期计算</span></span><br></pre></td></tr></table></figure><p>decltype在技术和使用上和sizeof非常像，都需要编译器在编译期计算类型，但是sizeof返回的是<strong>整数</strong>，而decltype得到的是<strong>类型</strong>。</p><h4 id="decltype和auto的异同："><a href="#decltype和auto的异同：" class="headerlink" title="decltype和auto的异同："></a>decltype和auto的异同：</h4><blockquote><p>与auto不同点：</p><p>decltypr的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，decltype总是以一个普通的表达式为参数，返回该表达式的类型。</p><p>与auto相同点：</p><p>①、作为一个类型指示符，decltype可以将获得的类型来定义另外一个变量；</p><p>②、declttype类型推导也是在编译时进行的</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">0</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a的类型是&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(a).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b的类型是&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(b).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="keyword">decltype</span>(c + d ) e;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;e的类型是&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(e).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a的类型是i  <span class="comment">//i代表int</span></span><br><span class="line">b的类型是i  </span><br><span class="line">e的类型是d   <span class="comment">//ddouble</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到变量b的类型由decltype（a）进行声明，表示b跟a这个表达式返回的类型相同；而e的类型则由（c + d）这个表达式返回的类型相同，c + d的表达式的类型为double，所有e的类型被decltype推导为double。</p></blockquote><h3 id="2-2、decltype的应用"><a href="#2-2、decltype的应用" class="headerlink" title="2.2、decltype的应用"></a>2.2、decltype的应用</h3><h4 id="①、decltype和typedf-using合用"><a href="#①、decltype和typedf-using合用" class="headerlink" title="①、decltype和typedf/using合用"></a>①、decltype和typedf/using合用</h4><p>在C++11 的头文件中常可以看到以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">size_t</span> = <span class="keyword">decltype</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">ptrdiff_t</span> = <span class="keyword">decltype</span>((<span class="keyword">int</span>*)<span class="number">0</span>- (<span class="keyword">int</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">nullptr_t</span> = <span class="keyword">decltype</span>(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><blockquote><p>size_t以及ptrdiff_t及nullptr都是由decltype推导出来的类型</p><p>这种定义方式的意义：</p><p>在一些常量、基本类型、运算符、操作符等基于被定义好的情况下，类型可以按照规则被推导出来。而使用using可以为这些类型取名；这样就颠覆了之前类型扩展需要江类型“映射”到基本类型的常规做法。</p></blockquote><h4 id="②、deltype在某些场景下使用增加代码的可读性"><a href="#②、deltype在某些场景下使用增加代码的可读性" class="headerlink" title="②、deltype在某些场景下使用增加代码的可读性"></a>②、deltype在某些场景下使用增加代码的可读性</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(vec.begin())</span> vectype</span>;</span><br><span class="line"><span class="keyword">for</span> (vectype i = vec.<span class="built_in">begin</span>(); i &lt; vec.<span class="built_in">end</span>(); i++) </span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(vec)::iterator i = vec.<span class="built_in">begin</span>(); i &lt; vec.<span class="built_in">end</span>(); i++) </span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><p>定义了vector的iterator的类型。这个类型还可以在main函数中重用。</p><p>当遇到一些具有复杂类型的变量或表达式时，就可以利用decltype和typedef/using的组合来将其转化为一个简单的表达式，这样在以后的代码写作中可以提高可读性和可维护性。</p><p>此外可以看到decltype(vec)::iterator这样的灵活用法，这看起来跟auto非常类似，也类似于是一种“占位符”式的替代。</p></blockquote><h4 id="③、使用decltype重用匿名类型"><a href="#③、使用decltype重用匿名类型" class="headerlink" title="③、使用decltype重用匿名类型"></a>③、使用decltype重用匿名类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span>&#123;</span>K1, K2, K3&#125;anon_e;    <span class="comment">// 匿名的强类型枚举</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">decltype</span>(anon_e) key;</span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line">&#125;anon_u;     <span class="comment">// 匿名的union联合体</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> d;</span><br><span class="line">           <span class="keyword">decltype</span>(anon_u) id;</span><br><span class="line">&#125;anon_s[<span class="number">100</span>];  <span class="comment">// 匿名的struct数组</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">decltype</span>(anon_s) as;</span><br><span class="line">    as[<span class="number">0</span>].id.key = <span class="keyword">decltype</span>(anon_e)::K1;    <span class="comment">// 引用匿名强类型枚举中的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure><blockquote><p>这里我们使用了3种不同的匿名类型：匿名的强类型枚举anon_e（请参见5.1节）、匿名的联合体anon_u，以及匿名的结构体数组anon_s。可以看到，只要通过匿名类型的变量名anon_e、anon_u，以及anon_s，decltype可以推导其类型并且进行重用。这些都是以前C++代码所做不到的。</p><p><strong>不过匿名一般都有匿名理由，一般都不希望匿名后的类型被重用。</strong></p></blockquote><h4 id="④、decltype可以适当扩大模板泛型的能力"><a href="#④、decltype可以适当扩大模板泛型的能力" class="headerlink" title="④、decltype可以适当扩大模板泛型的能力"></a>④、decltype可以适当扩大模板泛型的能力</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s的类型被声明为decltype(t1 + t2)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sum</span><span class="params">(T1 &amp; t1, T2 &amp; t2, <span class="keyword">decltype</span>(t1 + t2) &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s = t1 + t2;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s的类型是&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(s).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">long</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">float</span> c = <span class="number">1.0f</span>, d = <span class="number">2.3f</span>;</span><br><span class="line"><span class="keyword">long</span> e;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line"><span class="built_in">Sum</span>(a, b, e);    <span class="comment">// s的类型被推导为long</span></span><br><span class="line"><span class="built_in">Sum</span>(c, d, f);    <span class="comment">// s的类型被推导为float</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s的类型是l</span><br><span class="line">s的类型是f</span><br></pre></td></tr></table></figure><blockquote><p>代码中的Sum函数模板增加了类型为decltype(t1+t2)的s作为参数，而函数本身不返回任何值。这样一来，Sum的适用范围增加，其返回的类型是根据t1 + t2推导而来的类型。不过这里还是有一定的限制，可以看到返回值的类型必须一开始就被指定，我们必须清楚Sum运算的结果使用什么样的类型来存储是合适的，这在一些泛型编程中依然不能满足要求。</p><p>解决的方法是结合decltype与auto关键字，使用追踪返回类型的函数定义来使得编译器对函数返回值进行推导。</p></blockquote><h3 id="2-3、decltype推导规则"><a href="#2-3、decltype推导规则" class="headerlink" title="2.3、decltype推导规则"></a>2.3、decltype推导规则</h3><h4 id="①、表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用-decltype-推导出的类型和表达式的类型是一致的。"><a href="#①、表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用-decltype-推导出的类型和表达式的类型是一致的。" class="headerlink" title="①、表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用 decltype 推导出的类型和表达式的类型是一致的。"></a>①、表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用 decltype 推导出的类型和表达式的类型是一致的。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string text;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">110</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;y = x;</span><br><span class="line">    <span class="keyword">decltype</span>(x) a = x;</span><br><span class="line">    <span class="keyword">decltype</span>(y) b = x;</span><br><span class="line">    <span class="keyword">decltype</span>(Test::value) c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">decltype</span>(t.text) d = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 变量 a 被推导为 int 类型<br> 变量 b 被推导为 const int &amp; 类型<br> 变量 c 被推导为 const int 类型<br> 变量 d 被推导为 string 类型</p></blockquote><h4 id="②、表达式是函数调用，使用-decltype-推导出的类型和函数返回值一致。"><a href="#②、表达式是函数调用，使用-decltype-推导出的类型和函数返回值一致。" class="headerlink" title="②、表达式是函数调用，使用 decltype 推导出的类型和函数返回值一致。"></a>②、表达式是函数调用，使用 decltype 推导出的类型和函数返回值一致。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_int</span><span class="params">()</span></span>;                 <span class="comment">// 返回值为 int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func_int_r</span><span class="params">()</span></span>;              <span class="comment">// 返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">()</span></span>;            <span class="comment">// 返回值为 int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">func_cint</span><span class="params">()</span></span>;          <span class="comment">// 返回值为 const int</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">func_cint_r</span><span class="params">()</span></span>;       <span class="comment">// 返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">()</span></span>;     <span class="comment">// 返回值为 const int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> Test <span class="title">func_ctest</span><span class="params">()</span></span>;        <span class="comment">// 返回值为 const Test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>()) a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>()) b = n;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_rr</span>()) c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint</span>())  d = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_r</span>())  e = n;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_rr</span>()) f = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_ctest</span>()) g = <span class="built_in">Test</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>变量 a 被推导为 int 类型<br>变量 b 被推导为 int&amp; 类型<br>变量 c 被推导为 int&amp;&amp; 类型<br>变量 d 被推导为 int 类型<br>变量 e 被推导为 const int &amp; 类型<br>变量 f 被推导为 const int &amp;&amp; 类型<br>变量 g 被推导为 const Test 类型</p><p>函数 func_cint () 返回的是一个纯右值（在表达式执行结束后不再存在的数据，也就是临时性的数据），对于纯右值而言，只有类类型可以携带const、volatile限定符，除此之外需要忽略掉这两个限定符，因此推导出的变量 d 的类型为 int 而不是 const int。</p></blockquote><h4 id="③、表达式是一个左值，或者被括号-包围，使用-decltype-推导出的是表达式类型的引用（如果有-const、volatile-限定符不能忽略）。"><a href="#③、表达式是一个左值，或者被括号-包围，使用-decltype-推导出的是表达式类型的引用（如果有-const、volatile-限定符不能忽略）。" class="headerlink" title="③、表达式是一个左值，或者被括号 ( ) 包围，使用 decltype 推导出的是表达式类型的引用（如果有 const、volatile 限定符不能忽略）。"></a>③、表达式是一个左值，或者被括号 ( ) 包围，使用 decltype 推导出的是表达式类型的引用（如果有 const、volatile 限定符不能忽略）。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Test obj;</span><br><span class="line">    <span class="comment">//带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.num) a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>((obj.num)) b = a;</span><br><span class="line">    <span class="comment">//加法表达式</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>obj.num 为类的成员访问表达式，符合场景 1，因此 a 的类型为 int<br>obj.num 带有括号，符合场景 3，因此 b 的类型为 const int&amp;。<br>n+m 得到一个右值，符合场景 1，因此 c 的类型为 int<br>n=n+m 得到一个左值 n，符合场景 3，因此 d 的类型为 int&amp;</p></blockquote><h3 id="2-4、cv限制符的继承与冗余的符号"><a href="#2-4、cv限制符的继承与冗余的符号" class="headerlink" title="2.4、cv限制符的继承与冗余的符号"></a>2.4、cv限制符的继承与冗余的符号</h3><h4 id="①、与auto类型推导时不能“带走”cv限制符不同是："><a href="#①、与auto类型推导时不能“带走”cv限制符不同是：" class="headerlink" title="①、与auto类型推导时不能“带走”cv限制符不同是："></a>①、与auto类型推导时不能“带走”cv限制符不同是：</h4><p><strong>decltype是能够“带走”表达式的cv限制符的</strong>。不过，如果对象的定义中有const或volatile限制符，使用decltype进行推导时，其成员不会继承const或volatile限制符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ic = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> iv;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">int</span> i; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> S a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">volatile</span> S b;</span><br><span class="line"><span class="keyword">volatile</span> S* p = &amp;b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; is_const&lt;<span class="keyword">decltype</span>(ic)&gt;::value &lt;&lt; endl;        <span class="comment">// 1            </span></span><br><span class="line">cout &lt;&lt; is_volatile&lt;<span class="keyword">decltype</span>(iv)&gt;::value &lt;&lt; endl;    <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; is_const&lt;<span class="keyword">decltype</span>(a)&gt;::value &lt;&lt; endl;         <span class="comment">// 1            </span></span><br><span class="line">cout &lt;&lt; is_volatile&lt;<span class="keyword">decltype</span>(b)&gt;::value &lt;&lt; endl;     <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; is_const&lt;<span class="keyword">decltype</span>(a.i)&gt;::value &lt;&lt; endl;      <span class="comment">// 0, 成员不是const  </span></span><br><span class="line">cout &lt;&lt; is_volatile&lt;<span class="keyword">decltype</span>(p-&gt;i)&gt;::value &lt;&lt; endl; <span class="comment">// 0, 成员不volatile</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><blockquote><p>这里使用了C++库提供的is_const和is_volatile来查看类型是否是常量或者易失的。可以看到，结构体变量a、b和结构体指针p的cv限制符并没有出现在其成员的decltype类型推导结果中。</p></blockquote><h4 id="与auto相同的是："><a href="#与auto相同的是：" class="headerlink" title="与auto相同的是："></a>与auto相同的是：</h4><p><strong>decltype从表达式推导出类型后，进行类型定义时，也会允许一些冗余的符号。</strong>比如cv限制符以及引用符号&amp;，通常情况下，如果推导出的类型已经有了这些属性，冗余的符号则会被忽略</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; j = i;</span><br><span class="line"><span class="keyword">int</span> * p = &amp;i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">decltype</span>(i) &amp; var1 = i;</span><br><span class="line">    <span class="keyword">decltype</span>(j) &amp; var2 = i;      <span class="comment">// 冗余的&amp;, 被忽略</span></span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(var1)&gt;::value &lt;&lt; endl;<span class="comment">// 1, 是左值引用</span></span><br><span class="line">    cout &lt;&lt; is_rvalue_reference&lt;<span class="keyword">decltype</span>(var2)&gt;::value &lt;&lt; endl;<span class="comment">// 0, 不是右值引用</span></span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(var2)&gt;::value &lt;&lt; endl;<span class="comment">// 1, 是左值引用</span></span><br><span class="line">    <span class="comment">//decltype(p)* var3 = &amp;i;      // 无法通过编译              </span></span><br><span class="line">    <span class="keyword">decltype</span>(p)* var3 = &amp;p;      <span class="comment">// var3的类型是int**             </span></span><br><span class="line">    <span class="keyword">auto</span>* v3 = p;                  <span class="comment">// v3的类型是int*</span></span><br><span class="line">    v3 = &amp;i;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">decltype</span><span class="params">(k)</span> var4 </span>= <span class="number">1</span>; <span class="comment">// 冗余的const，被忽略</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>这里定义了类型为decltype(i) &amp;的变量var1，以及类型为decltype(j) &amp;的变量var2。</p><p>由于i的类型为int，所以这里的引用符号保证var1成为一个int&amp;引用类型。而由于j本来就是一个int &amp;的引用类型，所以decltype之后的&amp;成为了冗余符号，会被编译器忽略，因此j的类型依然是int &amp;。</p><p>特别要注意的是decltype(p)<em>的情况。可以看到，在定义var3变量的时候，由于p的类型是int</em>，因此var3被定义为了int*<em>类型。这跟auto声明中，</em>也可以是冗余的不同。在decltype后的*号，并不会被编译器忽略。</p><p>var4中const可以被冗余的声明，但会被编译器忽略，同样的情况也会发生在volatile限制符上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、C++11新特性：auto类型推导</title>
      <link href="/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/1%E3%80%81auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
      <url>/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/1%E3%80%81auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h2 id="一、auto类型推导"><a href="#一、auto类型推导" class="headerlink" title="一、auto类型推导"></a>一、auto类型推导</h2><blockquote><p>声明：该笔记是在学习《深入理解C++11》、《C++11/14高级编程 Boost程序库探秘》时做的总结，方便以后巩固复习！</p></blockquote><h3 id="1-1、静态类型、动态类型和类型推导"><a href="#1-1、静态类型、动态类型和类型推导" class="headerlink" title="1.1、静态类型、动态类型和类型推导"></a>1.1、静态类型、动态类型和类型推导</h3><p>静态类型：C/C++常被成为静态类型的编程语言，变量必须被定义；</p><p>动态类型：python、Perl、JavaScript语言常被称为动态类型的编程语言，变量不需要声明就可以被使用。</p><p>静态类型和动态类型的区别：是在对变量进行类型检测的时间点；静态类型的类型检测主要发生在编译阶段；动态类型的类型检测主要发生在运行阶段。</p><p>动态类型语言变量“拿来就用”的特性依赖的是类型推导技术；事实上类型推导也可以用于静态类型的语言中；C++11中类型推导的实现方式就有两种：①、auto，②、decltype;先学习auto关键字！</p><p>auto关键字在早期的C/C++标准中的含义：</p><blockquote><p>按照C/C++早期标准，声明时使用auto修饰的变量，是具有自动存储的局部变量；然而几乎无人使用这种含义，因为一般函数内没有被声明为static的变量总是具有自动存储的局部变量。</p></blockquote><p>auto关键字在C++11中的含义：</p><blockquote><p>auto不再是一个存储类型指示符（如static、extern为纯粹类型指示符），而是一个新的类型指示符（int、float等是类型指示符）来指示编译器，<strong>auto声明变量的类型必须由编译器在编译时期推导而得。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>; <span class="comment">//x的类型为int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="built_in">foo</span>(); <span class="comment">//y的类型为double</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">&#125;str; </span><br><span class="line"><span class="keyword">auto</span> str1 = str; <span class="comment">//str1的类型是sturct m</span></span><br><span class="line"><span class="comment">//auto z; //无法推导,不能通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>auto 声明的变量必须被初始化，以使编译能够从其初始化表达式中推导出其类型。这里可以理解为auto并非一种“类型”，而是一个类型声明时的“占位符”，编译器在编译时会将auto替代为变量实际的类型。</p></blockquote><h3 id="1-2、auto的优势"><a href="#1-2、auto的优势" class="headerlink" title="1.2、auto的优势"></a>1.2、auto的优势</h3><h4 id="①、最大优势就是在拥有初始化表达式的复杂类型变量声明时简化代码"><a href="#①、最大优势就是在拥有初始化表达式的复杂类型变量声明时简化代码" class="headerlink" title="①、最大优势就是在拥有初始化表达式的复杂类型变量声明时简化代码"></a>①、最大优势就是在拥有初始化表达式的复杂类型变量声明时简化代码</h4><p>由于C++的发展，声明变量类型也变得越来越复杂，很多时候，名字空间、模板成为了类型的一部分，导致程序员在使用库的时候如履薄冰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loopover</span><span class="params">(std::vector&lt;std:string&gt; &amp; vs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;std::string&gt;::iterator i = vs.<span class="built_in">begin</span>(); <span class="comment">//可看出在在不使用命名空间时，使用iterator 需要书写大量代码</span></span><br><span class="line"><span class="keyword">for</span>(; i &lt; vs.<span class="built_in">end</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用auto的话，代码会的可读性可以成倍增长,如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loopover</span><span class="params">(std::vector&lt;std:string&gt; &amp; vs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;std::string&gt;::iterator i = vs.<span class="built_in">begin</span>(); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>  i = vs.<span class="built_in">begin</span>(); i &lt; vs.<span class="built_in">end</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②、第二个优势则在于可以免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误"><a href="#②、第二个优势则在于可以免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误" class="headerlink" title="②、第二个优势则在于可以免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误"></a>②、第二个优势则在于可以免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误</h4><p>在C/C++中，存在着很多隐式或者用户自定义的类型转换规则（比如整型与字符型进行加法运算后，表达式返回的是整型，这是一条隐式规则）。这些规则并非很容易记忆，尤其是在用户自定义了很多操作符之后。而这个时候，auto就有用武之地了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PI</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span>* (<span class="keyword">float</span> v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)val * v;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> val = <span class="number">3.1415927f</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> radius = <span class="number">1.7e10</span>;</span><br><span class="line">    PI pi;</span><br><span class="line">    <span class="keyword">auto</span> circumference = <span class="number">2</span> * (pi * radius);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;circumference = &quot;</span> &lt;&lt; circumference &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">circumference = <span class="number">1.06814e+11</span></span><br></pre></td></tr></table></figure><blockquote><p>这里定义了float型的变量radius（半径）以及一个自定义类型PI变量pi（π值），在计算圆周长的时候，使用了auto类型来定义变量circumference。这里，PI在与float类型数据相乘时，其返回值为double。而PI的定义可能是在其他的地方（头文件里），main函数的程序员可能不知道PI的作者为了避免数据上溢或者精度降低而返回了double类型的浮点数。因此main函数程序员如果使用float类型声明circumference，就可能享受不了PI作者细心设计带来的好处。反之，将circumference声明为auto，则毫无问题，因为编译器已经自动地做了最好的选择。</p></blockquote><h4 id="③、第三个优点就是其“自适应”性能够在一定程度上支持泛型的编程"><a href="#③、第三个优点就是其“自适应”性能够在一定程度上支持泛型的编程" class="headerlink" title="③、第三个优点就是其“自适应”性能够在一定程度上支持泛型的编程"></a>③、第三个优点就是其“自适应”性能够在一定程度上支持泛型的编程</h4><p>再回到上面代码例子，这里假设改动了PI的定义，如将operator*返回值变为long double，此时，main函数并不需要修改，因为auto会“自适应”新的类型。</p><p>同时，对于不同的平台上的代码维护，auto也会带来一些“泛型”的好处。这里我们以strlen函数为例，在32位的编译环境下，strlen返回的为一个4字节的整型，而在64位的编译环境下，strlen会返回一个8字节的整型。虽然系统库<cstring>为其提供了size_t类型来支持多平台间的代码共享支持，但是使用auto关键字我们同样可以达到代码跨平台的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> v = <span class="built_in">strlen</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>由于size_t的适用范围往往局限于<cstring>中定义的函数，auto的适用范围明显更为广泛。</p><p>当auto应用于模板的定义中，其“自适应”性会得到更加充分的体现。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sum</span><span class="params">(T1 &amp; t1, T2 &amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> s = t1 + t2;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">long</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">float</span> c = <span class="number">1.0f</span>, d = <span class="number">2.3f</span>;</span><br><span class="line">    <span class="keyword">auto</span> e = Sum&lt;<span class="keyword">int</span>,<span class="keyword">long</span>&gt;(a,b);<span class="comment">//s的类型被推导为long</span></span><br><span class="line">    <span class="keyword">auto</span> f = Sum&lt;<span class="keyword">float</span>,<span class="keyword">float</span>&gt;(c,d);<span class="comment">//s的类型被推导为float</span></span><br><span class="line">cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; f &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">3.3</span></span><br></pre></td></tr></table></figure><blockquote><p>在上面程序中，由于类型T1、T2要在模板实例化时才能确定，所以在Sum中将变量s的类型声明为auto的。在函数main中我们将模板实例化时，Sum&lt;int,long&gt;中的s变量会被推导为long类型，而Sum&lt;float, float&gt;中的s变量则会被推导为float。可以看到，auto与模板一起使用时，其“自适应”特性能够加强C++中“泛型”的能力。不过在这个例子中，由于总是返回double类型的数据，所以Sum模板函数的适用范围还是受到了一定的限制。</p></blockquote><h4 id="④、在宏定义中，避免出现性能问题"><a href="#④、在宏定义中，避免出现性能问题" class="headerlink" title="④、在宏定义中，避免出现性能问题"></a>④、在宏定义中，避免出现性能问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX1(a, b) ((a) &gt; (b)) ? (a) : (b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX2(a, b) (&#123;\</span></span><br><span class="line"><span class="meta">        auto _a = (a);\</span></span><br><span class="line"><span class="meta">        auto _b = (b);\</span></span><br><span class="line"><span class="meta">        (_a &gt; _b) ? _a : _b;&#125;)</span></span><br><span class="line">        </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> m1 = <span class="built_in">MAX1</span>(<span class="number">1</span>*<span class="number">2</span>*<span class="number">3</span>*<span class="number">4</span>, <span class="number">5</span>+<span class="number">6</span>+<span class="number">7</span>+<span class="number">8</span>);</span><br><span class="line"> <span class="keyword">int</span> m2 = <span class="built_in">MAX2</span>(<span class="number">1</span>*<span class="number">2</span>*<span class="number">3</span>*<span class="number">4</span>, <span class="number">5</span>+<span class="number">6</span>+<span class="number">7</span>+<span class="number">8</span>);</span><br><span class="line"> cout &lt;&lt; m1 &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; m2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义了两种类型的宏Max1和Max2。两者作用相同，都是求a和b中较大者并返回。前者采用传统的三元运算符表达式，这可能会带来一定的性能问题。因为a或者b在三元运算符中都出现了两次，那么无论是取a还是取b，其中之一都会被运算两次。而在Max2中，我们将a和b都先算出来，再使用三元运算符进行比较，就不会存在这样的问题了。</p></blockquote><p>在传统的C++98标准中，由于a和b的类型无法获得，所以我们无法定义Max2这样高性能的宏。而新的标准中的auto则提供了这种可行性。</p><h3 id="1-3、auto使用时注意事项"><a href="#1-3、auto使用时注意事项" class="headerlink" title="1.3、auto使用时注意事项"></a>1.3、auto使用时注意事项</h3><h4 id="①、auto类型指示符与指针和引用之间的关系"><a href="#①、auto类型指示符与指针和引用之间的关系" class="headerlink" title="①、auto类型指示符与指针和引用之间的关系"></a>①、auto类型指示符与指针和引用之间的关系</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> * y = &amp;x;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> * a = &amp;x; <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp; b = x;<span class="comment">// int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> c = y;<span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> * d = y; <span class="comment">// int*</span></span><br><span class="line"><span class="comment">//auto * e = &amp;foo();//编译失败，指针不能指向一个临时变量</span></span><br><span class="line"><span class="comment">//auto &amp; f = foo();//编译失败，nonconst的左值引用不能和一个临时变量绑定</span></span><br><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bar</span>();<span class="comment">// int</span></span><br><span class="line"><span class="keyword">auto</span> &amp; h = <span class="built_in">bar</span>();<span class="comment">// int&amp;</span></span><br></pre></td></tr></table></figure><blockquote><p>变量a、c、d的类型都是指针类型，且都指向变量x。实际上对于a、c、d三个变量而言，声明其为auto *或auto并没有区别。</p><p>而如果要使得auto声明的变量是另一个变量的引用，则必须使用auto &amp;，如同本例中的变量b和h一样。</p></blockquote><h4 id="②、auto与volatile和const之间也存在着一些相互的联系"><a href="#②、auto与volatile和const之间也存在着一些相互的联系" class="headerlink" title="②、auto与volatile和const之间也存在着一些相互的联系"></a>②、auto与volatile和const之间也存在着一些相互的联系</h4><p>volatile和const代表了变量的两种不同的属性：易变的和常量的。</p><p>在C++标准中，它们常常被一起叫作cv限制符（cv-qualifier）。鉴于cv限制符的特殊性，C++11标准规定auto可以与cv限制符一起使用，<strong>不过声明为auto的变量并不能从其初始化表达式中“带走”cv限制符</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> * <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> a = <span class="built_in">foo</span>(); <span class="comment">//a:const double</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp; b = <span class="built_in">foo</span>(); <span class="comment">//b:const double&amp;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">auto</span> * c = <span class="built_in">bar</span>(); <span class="comment">//c:volatile float*</span></span><br><span class="line"><span class="keyword">auto</span> d = a; <span class="comment">//d:double</span></span><br><span class="line"><span class="keyword">auto</span> &amp; e = e; <span class="comment">//e:const double &amp;</span></span><br><span class="line"><span class="keyword">auto</span> f = c; <span class="comment">//f:float *</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">auto</span> &amp; g = c; <span class="comment">//g:volatile float * &amp;</span></span><br></pre></td></tr></table></figure><p>可以看出通过非cv限制的类型初始化一个cv限制的类型，如变量a、b、c所示。不过通过auto声明的变量d、f却无法带走a和f的常量性或者易失性。这里的例外还是引用，可以看出，声明为引用的变量e、g都保持了其引用的对象相同的属性（事实上，指针也是一样的）。</p><h4 id="③、auto可以用来声明多个变量的类型，不过这些变量的类型必须相同"><a href="#③、auto可以用来声明多个变量的类型，不过这些变量的类型必须相同" class="headerlink" title="③、auto可以用来声明多个变量的类型，不过这些变量的类型必须相同"></a>③、auto可以用来声明多个变量的类型，不过这些变量的类型必须相同</h4><p>如果这些变量的类型不相同，编译器则会报错。事实上，用auto来声明多个变量类型时，只有第一个变量用于auto的类型推导，然后推导出来的数据类型被作用于其他的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//m是一个指向const int类型变量的指针，n是一个int类型的变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* m = &amp;x, n = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//auto i = 1, j = 3.14f; //编译失败</span></span><br><span class="line"><span class="keyword">auto</span> o = <span class="number">1</span>,&amp;p = o,*q = &amp;p; <span class="comment">//从左向右推导</span></span><br></pre></td></tr></table></figure><blockquote><p>使用auto声明了两个类型相同变量x和y，并用逗号进行分隔，这可以通过编译。而在声明变量i和j的时候，按照我们所说的第一变量用于推导类型的规则，那么由于x所推导出的类型是int，那么对于变量j而言，其声明就变成了int j =3.14f，这无疑会导致精度的损失。而对于变量m和n，就变得非常有趣，这里似乎是auto被替换成了int，所以m是一个int *指针类型，而n只是一个int类型。同样的情况也发生在变量o、p、q上，这里o是一个类型为int的变量，p是o的引用，而q是p的指针。auto的类型推导按照从左往右，且类似于字面替换的方式进行。事实上，标准里称auto是一个将要推导出的类型的“占位符”（placeholder）。这样的规则无疑是直观而让人略感意外的。当然，为了不必要的繁琐记忆，程序员可以选择每一个auto变量的声明写成一行（有些观点也认为这是好的编程规范）。</p></blockquote><h4 id="④、只要能够进行推导的地方，C-11都为auto指定了详细的规则，保证编译器能够正确地推导出变量的类型"><a href="#④、只要能够进行推导的地方，C-11都为auto指定了详细的规则，保证编译器能够正确地推导出变量的类型" class="headerlink" title="④、只要能够进行推导的地方，C++11都为auto指定了详细的规则，保证编译器能够正确地推导出变量的类型"></a>④、只要能够进行推导的地方，C++11都为auto指定了详细的规则，保证编译器能够正确地推导出变量的类型</h4><p>包括C++11新引入的初始化列表，以及new，都可以使用auto关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> y &#123;<span class="number">1</span>&#125;;      <span class="comment">// 使用初始化列表的auto  </span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in"><span class="keyword">auto</span></span>(<span class="number">1</span>);    <span class="comment">// 可以用于new       </span></span><br></pre></td></tr></table></figure><blockquote><p>auto变量y的初始化使用了初始化列表，编译器可以保证y的类型推导为int。而z指针所指向的堆变量在分配时依然选择让编译器对类型进行推导，同样的，编译器也能够保证这种方式下类型推导的正确性。</p></blockquote><h4 id="⑤、不过auto也不是万能的，受制于语法的二义性，或者是实现的困难性，auto往往也会有使用上的限制"><a href="#⑤、不过auto也不是万能的，受制于语法的二义性，或者是实现的困难性，auto往往也会有使用上的限制" class="headerlink" title="⑤、不过auto也不是万能的，受制于语法的二义性，或者是实现的困难性，auto往往也会有使用上的限制"></a>⑤、不过auto也不是万能的，受制于语法的二义性，或者是实现的困难性，auto往往也会有使用上的限制</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>      </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;      </span><br><span class="line"><span class="comment">//void fun(auto x =1)&#123;&#125;  // 1: auto函数参数，无法通过编译</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str</span>&#123;</span></span><br><span class="line"><span class="comment">//auto var = 10;    // 2: auto非静态成员变量，无法通过编译</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> x[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">auto</span> y = x;</span><br><span class="line"><span class="comment">// auto z[3] = x; // 3: auto数组，无法通过编译    // 4: auto模板参数（实例化时），无法通过编译</span></span><br><span class="line">vector&lt;<span class="keyword">auto</span>&gt; v = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><p>①、对于函数fun来说，auto不能是其形参类型。可能读者感觉对于fun来说，由于其有默认参数，所以应该推导fun形参x的类型为int型。但事实却无法符合大家的想象。因为auto是不能做形参的类型的。如果程序员需要泛型的参数，还是需要求助于模板。</p><p>②、对于结构体来说，非静态成员变量的类型不能是auto的。同样的，由于var定义了初始值，读者可能认为auto可以推导str成员var的类型为int的。但编译器阻止auto对结构体中的非静态成员进行推导，即使成员拥有初始值。</p><p>③、声明auto数组。我们可以看到，main中的x是一个数组，y的类型是可以推导的，而声明auto z[3]这样的数组同样会被编译器禁止。</p><p>④、在实例化模板的时候使用auto作为模板参数，如main中我们声明的vector<auto> v。虽然读者可能认为这里一眼而知是int类型，但编译器却阻止了编译。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、Linux开发常用命令</title>
      <link href="/2021/11/10/2%E3%80%81Linux/%E4%BA%8C%E3%80%81Linux%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/10/2%E3%80%81Linux/%E4%BA%8C%E3%80%81Linux%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="二、Linux开发常用命令"><a href="#二、Linux开发常用命令" class="headerlink" title="二、Linux开发常用命令"></a>二、Linux开发常用命令</h2><h3 id="2-1、常用的系统工作命令"><a href="#2-1、常用的系统工作命令" class="headerlink" title="2.1、常用的系统工作命令"></a>2.1、常用的系统工作命令</h3><h4 id="1、echo命令"><a href="#1、echo命令" class="headerlink" title="1、echo命令"></a>1、echo命令</h4><p>echo命令用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量]”。</p><p>使用$变量的方式提取变量SHELL的值，并将其输出到屏幕上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br><span class="line">输出： /bin/bash</span><br></pre></td></tr></table></figure><h4 id="2、reboot命令"><a href="#2、reboot命令" class="headerlink" title="2、reboot命令"></a>2、reboot命令</h4><p>reboot命令用于重启系统</p><blockquote><p><strong>语法格式：</strong> reboot [参数]  </p></blockquote><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此默认只能使用root管理员来重启。</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-n</th><th>在重开机前不做将记忆体资料写回硬盘的动作 帮助</th></tr></thead><tbody><tr><td>-w</td><td>并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里</td></tr><tr><td>-d</td><td>不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）</td></tr><tr><td>-f</td><td>强迫重开机，不呼叫 shutdown 这个指令</td></tr><tr><td>-i</td><td>在重开机之前先把所有网络相关的装置先停止</td></tr></tbody></table><h4 id="3、poweroff命令"><a href="#3、poweroff命令" class="headerlink" title="3、poweroff命令"></a>3、poweroff命令</h4><p>poweroff命令用于关闭系统</p><blockquote><p><strong>语法格式：</strong>poweroff [参数]</p></blockquote><p>该命令与reboot命令相同，都会涉及硬件资源的管理权限，因此默认只有root管理员才可以关闭电脑。</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-n</th><th>关闭操作系统时不执行sync操作</th></tr></thead><tbody><tr><td>-w</td><td>不真正关闭操作系统，仅在日志文件“/var/log/wtmp”中</td></tr><tr><td>-d</td><td>关闭操作系统时，不将操作写入日志文件“/var/log/wtmp”中添加相应的记录</td></tr><tr><td>-f</td><td>强制关闭操作系统</td></tr><tr><td>-i</td><td>关闭操作系统之前关闭所有的网络接口</td></tr><tr><td>-h</td><td>关闭操作系统之前将系统中所有的硬件设置为备用模式</td></tr></tbody></table><h4 id="4、ps命令"><a href="#4、ps命令" class="headerlink" title="4、ps命令"></a>4、ps命令</h4><p>ps命令用于查看系统中的进程状态，</p><blockquote><p><strong>语法格式：</strong>ps [参数] </p></blockquote><p>该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。 </p><p><strong>常用参数：</strong>﻿</p><table><thead><tr><th>-a</th><th>显示所有终端机下执行的程序，除了阶段作业领导者之外</th></tr></thead><tbody><tr><td>a</td><td>显示现行终端机下的所有程序，包括其他用户的程序</td></tr><tr><td>-A</td><td>显示所有程序</td></tr><tr><td>-c</td><td>显示CLS和PRI栏位</td></tr><tr><td>c</td><td>列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示</td></tr><tr><td>-C &lt;指令名称&gt;</td><td>指定执行指令的名称，并列出该指令的程序的状况</td></tr><tr><td>-d</td><td>显示所有程序，但不包括阶段作业领导者的程序</td></tr><tr><td>-e</td><td>此选项的效果和指定”A”选项相同</td></tr><tr><td>e</td><td>列出程序时，显示每个程序所使用的环境变量</td></tr><tr><td>-f</td><td>显示UID,PPIP,C与STIME栏位</td></tr><tr><td>f</td><td>用ASCII字符显示树状结构，表达程序间的相互关系</td></tr><tr><td>-g &lt;群组名称&gt;</td><td>此选项的效果和指定”-G”选项相同，当亦能使用阶段作业领导者的名称来指定</td></tr><tr><td>g</td><td>显示现行终端机下的所有程序，包括群组领导者的程序</td></tr></tbody></table><h4 id="5、kill命令"><a href="#5、kill命令" class="headerlink" title="5、kill命令"></a>5、kill命令</h4><p>kill命令用于终止某个指定PID的服务进程。</p><blockquote><p><strong>语法格式：</strong>kill [参数] [进程号]</p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-l</th><th>列出系统支持的信号</th></tr></thead><tbody><tr><td>-s</td><td>指定向进程发送的信号</td></tr><tr><td>-a</td><td>处理当前进程时不限制命令名和进程号的对应关系</td></tr><tr><td>-p</td><td>指定kill命令只打印相关进程的进程号，而不发送任何信号</td></tr></tbody></table><h4 id="6、killall命令"><a href="#6、killall命令" class="headerlink" title="6、killall命令"></a>6、killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，</p><blockquote><p><strong>语法格式：</strong>“killall [参数] [进程名称]”。</p></blockquote><h3 id="2-2、系统状态检测命令"><a href="#2-2、系统状态检测命令" class="headerlink" title="2.2、系统状态检测命令"></a>2.2、系统状态检测命令</h3><h4 id="1．ifconfig命令"><a href="#1．ifconfig命令" class="headerlink" title="1．ifconfig命令"></a>1．ifconfig命令</h4><p>ifconfig命令用于获取网卡配置与网络状态等信息，</p><blockquote><p>格式为“ifconfig [网络设备] [参数]”。</p></blockquote><h4 id="2-uname命令"><a href="#2-uname命令" class="headerlink" title="2.uname命令"></a>2.uname命令</h4><p>uname命令用于查看系统内核与系统版本等信息，</p><blockquote><p><strong>语法格式：</strong>uname [参数] </p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-a</th><th>显示系统所有相关信息</th></tr></thead><tbody><tr><td>-m</td><td>显示计算机硬件架构</td></tr><tr><td>-n</td><td>显示主机名称</td></tr><tr><td>-r</td><td>显示内核发行版本号</td></tr><tr><td>-s</td><td>显示内核名称</td></tr><tr><td>-v</td><td>显示内核版本</td></tr><tr><td>-p</td><td>显示主机处理器类型</td></tr><tr><td>-o</td><td>显示操作系统名称</td></tr><tr><td>-i</td><td>显示硬件平台</td></tr></tbody></table><p>在使用uname命令时，一般会固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。</p><h3 id="2-3、工作目录切换命令"><a href="#2-3、工作目录切换命令" class="headerlink" title="2.3、工作目录切换命令"></a>2.3、工作目录切换命令</h3><h4 id="1、pwd命令"><a href="#1、pwd命令" class="headerlink" title="1、pwd命令"></a>1、pwd命令</h4><p>pwd命令用于显示用户当前所处的工作目录，</p><blockquote><p><strong>语法格式:</strong> pwd [参数]</p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-L</th><th>显示逻辑路径</th></tr></thead></table><h4 id="2、cd命令"><a href="#2、cd命令" class="headerlink" title="2、cd命令"></a>2、cd命令</h4><blockquote><p><strong>语法格式：</strong>cd [参数] [目录名] </p></blockquote><p>cd命令用于切换工作路径，格式为“cd [目录名称]”。是最常用的一个Linux命令之一。</p><p>可以通过cd命令迅速、灵活地切换到不同的工作目录。</p><p>除了常见的切换目录方式：</p><blockquote><p>可以使用“cd -”命令返回到上一次所处的目录，</p><p>使用“cd..”命令进入上级目录，</p><p>使用“cd ~”命令切换到当前用户的家目录，</p><p>使用“cd ~username”切换到其他用户的家目录。</p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-P</th><th>如果切换的目标目录是一个符号链接，则直接切换到符号链接指向的目标目录</th></tr></thead><tbody><tr><td>-L</td><td>如果切换的目标目录是一个符号链接，则直接切换到符号链接名所在的目录</td></tr><tr><td>–</td><td>仅使用”-“选项时，当前目录将被切换到环境变量”OLDPWD”对应值的目录</td></tr><tr><td>~</td><td>切换至当前用户目录</td></tr><tr><td>..</td><td>切换至当前目录位置的上一级目录</td></tr></tbody></table><h4 id="3．ls命令"><a href="#3．ls命令" class="headerlink" title="3．ls命令"></a>3．ls命令</h4><p>ls命令用于显示指定工作目录下的内容及属性信息。</p><blockquote><p><strong>语法格式:</strong> ls [选项] [文件] </p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-a</th><th>显示所有文件及目录 (包括以“.”开头的隐藏文件)</th></tr></thead><tbody><tr><td>-l</td><td>使用长格式列出文件及目录信息</td></tr><tr><td>-r</td><td>将文件以相反次序显示(默认依英文字母次序)</td></tr><tr><td>-t</td><td>根据最后的修改时间排序</td></tr><tr><td>-A</td><td>同 -a ，但不列出 “.” (当前目录) 及 “..” (父目录)</td></tr><tr><td>-S</td><td>根据文件大小排序</td></tr><tr><td>-R</td><td>递归列出所有子目录</td></tr></tbody></table><h3 id="2-4、文本文件编辑命令"><a href="#2-4、文本文件编辑命令" class="headerlink" title="2.4、文本文件编辑命令"></a>2.4、文本文件编辑命令</h3><h4 id="1、cat命令"><a href="#1、cat命令" class="headerlink" title="1、cat命令"></a>1、cat命令</h4><p>cat命令用于查看纯文本文件（内容较少的）。</p><blockquote><p>**语法格式:**“cat [选项] [文件]”</p></blockquote><p>注意：当文件内容较大时，文本内容会在屏幕上快速闪动（滚屏），用户往往看不清所显示的具体内容。因此对于较长文件内容可以按Ctrl+S键，停止滚屏；以及Ctrl+Q键可以恢复滚屏；而按Ctrl+C（中断）键则可以终止该命令的执行。</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-n</th><th>显示行数（空行也编号）</th></tr></thead><tbody><tr><td>-s</td><td>显示行数（多个空行算一个编号）</td></tr><tr><td>-b</td><td>显示行数（空行不编号）</td></tr><tr><td>-E</td><td>每行结束处显示$符号</td></tr><tr><td>-T</td><td>将TAB字符显示为 ^I符号</td></tr><tr><td>-v</td><td>使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外</td></tr><tr><td>-e</td><td>等价于”-vE”组合</td></tr><tr><td>-t</td><td>等价于”-vT”组合</td></tr><tr><td>-A</td><td>等价于 -vET组合</td></tr><tr><td>–help</td><td>显示帮助信息</td></tr><tr><td>–version</td><td>显示版本信息</td></tr></tbody></table><h4 id="2、more命令-–-显示文本文件内容"><a href="#2、more命令-–-显示文本文件内容" class="headerlink" title="2、more命令 – 显示文本文件内容"></a>2、more命令 – 显示文本文件内容</h4><p>more命令用于将内容较长的文本文件内容（不能在一屏显示完）进行分屏显示，并且支持在显示时定位关键字。而对于内容较少的文本文件内容则推荐使用cat命令查看。</p><blockquote><p><strong>语法格式：</strong>more [参数] [文件] </p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-num</th><th>指定每屏显示的行数</th></tr></thead><tbody><tr><td>-l</td><td>more在通常情况下把 <strong>^L</strong> 当作特殊字符, 遇到这个字符就会暂停,-l选项可以阻止这种特性</td></tr><tr><td>-f</td><td>计算实际的行数，而非自动换行的行数</td></tr><tr><td>-p</td><td>先清除屏幕再显示文本文件的剩余内容</td></tr><tr><td>-c</td><td>与-p相似，不滚屏，先显示内容再清除旧内容</td></tr><tr><td>-s</td><td>多个空行压缩成一行显示</td></tr><tr><td>-u</td><td>禁止下划线</td></tr><tr><td>+/pattern</td><td>在每个文档显示前搜寻该字(pattern)，然后从该字串之后开始显示</td></tr><tr><td>+num</td><td>从第 num 行开始显示</td></tr></tbody></table><h4 id="3、head命令"><a href="#3、head命令" class="headerlink" title="3、head命令"></a>3、head命令</h4><p>head命令以行为单位，取文件的内容,后面不接参数时默认打印前10行。</p><p><strong>语法格式：</strong>head [参数] [文件]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-n</th><th>后面接数字，代表显示几行的意思</th></tr></thead><tbody><tr><td>-c</td><td>指定显示头部内容的字符数</td></tr><tr><td>-v</td><td>总是显示文件名的头信息</td></tr><tr><td>-q</td><td>不显示文件名的头信息</td></tr></tbody></table><h3 id="2-5、文件目录管理命令"><a href="#2-5、文件目录管理命令" class="headerlink" title="2.5、文件目录管理命令"></a>2.5、文件目录管理命令</h3><h4 id="1、touch命令"><a href="#1、touch命令" class="headerlink" title="1、touch命令"></a>1、touch命令</h4><p>touch命令用于创建空白文件或设置文件的时间；</p><blockquote><p><strong>语法格式：</strong>touch [参数] [文件]</p></blockquote><p><strong>常用参数：</strong>﻿</p><table><thead><tr><th>-a</th><th>改变档案的读取时间记录</th></tr></thead><tbody><tr><td>-m</td><td>改变档案的修改时间记录</td></tr><tr><td>-r</td><td>使用参考档的时间记录，与 –file 的效果一样</td></tr><tr><td>-c</td><td>不创建新文件</td></tr><tr><td>-d</td><td>设定时间与日期，可以使用各种不同的格式</td></tr><tr><td>-t</td><td>设定档案的时间记录，格式与 date 命令相同</td></tr><tr><td>–no-create</td><td>不创建新文件</td></tr><tr><td>–help</td><td>显示帮助信息</td></tr><tr><td>–version</td><td>列出版本讯息</td></tr></tbody></table><h4 id="2、mkdir命令"><a href="#2、mkdir命令" class="headerlink" title="2、mkdir命令"></a>2、mkdir命令</h4><p>mkdir命令用于创建空白的目录；</p><p><strong>语法格式 :</strong> mkdir [参数] [目录] </p><p><strong>常用参数：</strong></p><table><thead><tr><th>-p</th><th>递归创建多级目录</th></tr></thead><tbody><tr><td>-m</td><td>建立目录的同时设置目录的权限</td></tr><tr><td>-z</td><td>设置安全上下文</td></tr><tr><td>-v</td><td>显示目录的创建过程</td></tr></tbody></table><p>在工作目录下，建立一个名为 dir 的子目录： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# mkdir dir</span><br></pre></td></tr></table></figure><p> 在目录/usr/linuxcool下建立子目录dir，并且设置文件属主有读、写和执行权限，其他人无权访问 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# mkdir -m 700 /usr/linuxcool/dir</span><br></pre></td></tr></table></figure><h4 id="3、cp命令"><a href="#3、cp命令" class="headerlink" title="3、cp命令"></a>3、cp命令</h4><p>cp命令可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。</p><p><strong>语法格式：</strong>cp [参数] [文件] </p><p><strong>常用参数：</strong></p><table><thead><tr><th>-f</th><th>若目标文件已存在，则会直接覆盖原文件</th></tr></thead><tbody><tr><td>-i</td><td>若目标文件已存在，则会询问是否覆盖</td></tr><tr><td>-p</td><td>保留源文件或目录的所有属性</td></tr><tr><td>-r</td><td>递归复制文件和目录</td></tr><tr><td>-d</td><td>当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录</td></tr><tr><td>-l</td><td>对源文件建立硬连接，而非复制文件</td></tr><tr><td>-s</td><td>对源文件建立符号连接，而非复制文件</td></tr><tr><td>-b</td><td>覆盖已存在的文件目标前将目标文件备份</td></tr><tr><td>-v</td><td>详细显示cp命令执行的操作过程</td></tr><tr><td>-a</td><td>等价于“dpr”选项</td></tr></tbody></table><p>例如： 交互式地将目录 /usr/linuxcool 中的所有.c文件复制到目录 dir 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# cp -r /usr/linuxcool/*.c dir</span><br></pre></td></tr></table></figure><h4 id="4、mv命令"><a href="#4、mv命令" class="headerlink" title="4、mv命令"></a>4、mv命令</h4><p>mv命令用于剪切文件或将文件重命名，mv与cp的结果不同。mv命令好像文件“搬家”，文件名称发生改变，但个数并未增加。而cp命令是对文件进行复制操作，文件个数是有增加的。</p><blockquote><p><strong>语法格式：</strong>mv [参数]</p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-i</th><th>若存在同名文件，则向用户询问是否覆盖</th></tr></thead><tbody><tr><td>-f</td><td>覆盖已有文件时，不进行任何提示</td></tr><tr><td>-b</td><td>当文件存在时，覆盖前为其创建一个备份</td></tr><tr><td>-u</td><td>当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作</td></tr></tbody></table><h4 id="5、rm命令"><a href="#5、rm命令" class="headerlink" title="5、rm命令"></a>5、rm命令</h4><p>rm命令用于删除文件或目录，格式为“rm [选项]文件”。</p><p><strong>语法格式：</strong>rm [参数] [文件]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-f</th><th>忽略不存在的文件，不会出现警告信息</th></tr></thead><tbody><tr><td>-i</td><td>删除前会询问用户是否操作</td></tr><tr><td>-r/R</td><td>递归删除</td></tr><tr><td>-v</td><td>显示指令的详细执行过程</td></tr></tbody></table><p>直接删除，不会有任何提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# rm -f test.txt.bz2  </span><br></pre></td></tr></table></figure><p>递归删除目录及目录下所有文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# mkdir /data/log</span><br><span class="line">[root@linuxcool ~]# rm -rf /data/log</span><br></pre></td></tr></table></figure><p>删除当前目录下所有文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# rm -rf *</span><br></pre></td></tr></table></figure><h3 id="2-6、打包压缩与搜索命令"><a href="#2-6、打包压缩与搜索命令" class="headerlink" title="2.6、打包压缩与搜索命令"></a>2.6、打包压缩与搜索命令</h3><h4 id="1．tar命令"><a href="#1．tar命令" class="headerlink" title="1．tar命令"></a>1．tar命令</h4><p>tar命令用于对文件进行打包压缩或解压，</p><blockquote><p><strong>语法格式：</strong>tar [参数] [文件或目录]</p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-A</th><th>新增文件到以存在的备份文件</th></tr></thead><tbody><tr><td>-B</td><td>设置区块大小</td></tr><tr><td>-c</td><td>建立新的备份文件</td></tr><tr><td>-C &lt;目录&gt;</td><td>切换工作目录，先进入指定目录再执行压缩/解压缩操作，可用于仅压缩特定目录里的内容或解压缩到特定目录</td></tr><tr><td>-d</td><td>记录文件的差别</td></tr><tr><td>-x</td><td>从归档文件中提取文件</td></tr><tr><td>-t</td><td>列出备份文件的内容</td></tr><tr><td>-z</td><td>通过gzip指令压缩/解压缩文件，文件名最好为*.tar.gz</td></tr><tr><td>-Z</td><td>通过compress指令处理备份文件</td></tr><tr><td>-f&lt;备份文件&gt;</td><td>指定备份文件</td></tr><tr><td>-v</td><td>显示指令执行过程</td></tr><tr><td>-r</td><td>添加文件到已经压缩的文件</td></tr><tr><td>-u</td><td>添加改变了和现有的文件到已经存在的压缩文件</td></tr><tr><td>-j</td><td>通过bzip2指令压缩/解压缩文件，文件名最好为*.tar.bz2</td></tr><tr><td>-v</td><td>显示操作过程</td></tr><tr><td>-l</td><td>文件系统边界设置</td></tr><tr><td>-k</td><td>保留原有文件不覆盖</td></tr><tr><td>-m</td><td>保留文件不被覆盖</td></tr><tr><td>-w</td><td>确认压缩文件的正确性</td></tr><tr><td>-p</td><td>保留原来的文件权限与属性</td></tr><tr><td>-P</td><td>使用文件名的绝对路径，不移除文件名称前的“/”号</td></tr><tr><td>-N &lt;日期格式&gt;</td><td>只将较指定日期更新的文件保存到备份文件里</td></tr><tr><td>– -exclude=&lt;范本样式&gt;</td><td>排除符合范本样式的文件</td></tr><tr><td>– -remove-files</td><td>归档/压缩之后删除源文件</td></tr></tbody></table><p>把指定的文件进行打包压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar-czvf压缩包名称．tar.gz要打包的目录</span><br></pre></td></tr></table></figure><p>解压命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf压缩包名称．tar.gz</span><br></pre></td></tr></table></figure><h4 id="2、grep命令"><a href="#2、grep命令" class="headerlink" title="2、grep命令"></a>2、grep命令</h4><p> 强大的文本搜索工具，grep命令的选项用于对搜索过程的补充，而其命令的模式十分灵活，可以是变量、字符串、正则表达式。</p><p>需要注意的是：一当模式中包含了空格，务必要用双引号将其引起来。</p><p><strong>语法格式：</strong> grep [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-i</th><th>搜索时，忽略大小写</th></tr></thead><tbody><tr><td>-c</td><td>只输出匹配行的数量</td></tr><tr><td>-l</td><td>只列出符合匹配的文件名，不列出具体的匹配行</td></tr><tr><td>-n</td><td>列出所有的匹配行，显示行号</td></tr><tr><td>-h</td><td>查询多文件时不显示文件名</td></tr><tr><td>-s</td><td>不显示不存在、没有匹配文本的错误信息</td></tr><tr><td>-v</td><td>显示不包含匹配文本的所有行</td></tr><tr><td>-w</td><td>匹配整词</td></tr><tr><td>-x</td><td>匹配整行</td></tr><tr><td>-r</td><td>递归搜索</td></tr><tr><td>-q</td><td>禁止输出任何结果，已退出状态表示搜索是否成功</td></tr><tr><td>-b</td><td>打印匹配行距文件头部的偏移量，以字节为单位</td></tr><tr><td>-o</td><td>与-b结合使用，打印匹配的词据文件头部的偏移量，以字节为单位</td></tr></tbody></table><h3 id="2-7、用户身份与文件权限"><a href="#2-7、用户身份与文件权限" class="headerlink" title="2.7、用户身份与文件权限"></a>2.7、用户身份与文件权限</h3><h4 id="1、sudo-切换用户执行身份命令"><a href="#1、sudo-切换用户执行身份命令" class="headerlink" title="1、sudo 切换用户执行身份命令"></a>1、sudo 切换用户执行身份命令</h4><p>sudo 是一种权限管理机制，管理员可以授权于一些普通用户去执行一些 root 执行的操作，而不需要知道 root 的密码。</p><blockquote><p><strong>语法格式：</strong>sudo [参数]</p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-v</th><th>因为 sudo 在第一次执行时或是在 N分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过N分钟，也会问密码</th></tr></thead><tbody><tr><td>-k</td><td>强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）</td></tr><tr><td>-b</td><td>将要执行的指令放在背景执行</td></tr><tr><td>-p</td><td>prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称，%h 会显示主机名称</td></tr><tr><td>-s</td><td>执行环境变数中的SHELL 所指定的shell ，或是 /etc/passwd 里所指定的 shell</td></tr><tr><td>command</td><td>要以系统管理者身份（或以 -u 更改为其他人）执行的指令</td></tr></tbody></table><h4 id="2、adduser-添加用户命令"><a href="#2、adduser-添加用户命令" class="headerlink" title="2、adduser 添加用户命令"></a>2、adduser 添加用户命令</h4><p>该命令用于新增使用者帐号或更新预设的使用者资料。adduser 与 useradd 指令为同一指令（经由符号连结 symbolic link）</p><blockquote><p><strong>语法格式：</strong>adduser [参数] </p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-c</th><th>加上备注文件，备注文字会存储在 passwd 的备注参数中</th></tr></thead><tbody><tr><td>-d</td><td>指定用户登录时的起始目录</td></tr><tr><td>-D</td><td>变更默认值</td></tr><tr><td>-e</td><td>设定此帐号的使用期限（格式为 YYYY-MM-DD），预设值为永久有效</td></tr><tr><td>-f &lt;缓冲天数&gt;</td><td>指定在密码过期后多少天即关闭该帐号</td></tr><tr><td>-g &lt;群组&gt;</td><td>指定用户所属的群组</td></tr><tr><td>-G &lt;群组&gt;</td><td>指定用户所属的附加群组</td></tr><tr><td>-m</td><td>自动建立用户的登入目录</td></tr><tr><td>-M</td><td>不要自动建立用户的登入目录</td></tr><tr><td>-n</td><td>取消建立以用户名称为名的群组</td></tr><tr><td>-r</td><td>建立系统帐号</td></tr><tr><td>-s <shell></td><td>指定用户登入后所使用的shell</td></tr><tr><td>-u <uid></td><td>指定用户ID</td></tr></tbody></table><h4 id="3、deluser-删除用户命令"><a href="#3、deluser-删除用户命令" class="headerlink" title="3、deluser  删除用户命令"></a>3、deluser  删除用户命令</h4><p>deluser命令用于删除用户。将一个用户从一个组中删除（即退出用户组）</p><blockquote><p><strong>语法格式：</strong>deluser [参数] </p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>–remove-all-files</th><th>删除用户拥有的所有文件</th></tr></thead><tbody><tr><td>–remove-home</td><td>删除用户的主目录和邮件后台处理程序</td></tr><tr><td>–backup-to</td><td>目标目录进行备份</td></tr><tr><td>–system</td><td>只有系统用户才能删除</td></tr></tbody></table><h4 id="4、su-切换用户命令"><a href="#4、su-切换用户命令" class="headerlink" title="4、su  切换用户命令"></a>4、su  切换用户命令</h4><p>su命令用于切换当前用户身份到指定用户或者以指定用户的身份执行命令或程序。 </p><p>普通用户切换到root用户，可以使用su – 或su root,但是必须输入root密码才能完成切换。root用户切换到普通用户，可以使用su username,不需要输入任何密码即可完成切换。</p><p><strong>语法格式:</strong> su [选项] [用户名]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-c或–command</th><th>执行完指定的指令后，即恢复原来的身份</th></tr></thead><tbody><tr><td>-f或–fast</td><td>适用于csh与tsch，使shell不用去读取启动文件</td></tr><tr><td>-l或–login</td><td>改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,logname,此外，也会变更PATH变量</td></tr><tr><td>-m,-p或–preserve-environment</td><td>变更身份时，不要变更环境变量</td></tr><tr><td>-s或–shell</td><td>指定要执行的shell</td></tr><tr><td>–help</td><td>显示帮助信息</td></tr><tr><td>–version</td><td>显示版本信息</td></tr></tbody></table><p>切换到linuxcool用户，并改变为linuxcool用户环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# su - linuxcool  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无人驾驶-感知层-传感器（一）——激光雷达</title>
      <link href="/2021/11/10/8%E3%80%81%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8F%8ASLAM/%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6-%E6%84%9F%E7%9F%A5%E5%B1%82-%E4%BC%A0%E6%84%9F%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE/"/>
      <url>/2021/11/10/8%E3%80%81%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8F%8ASLAM/%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6-%E6%84%9F%E7%9F%A5%E5%B1%82-%E4%BC%A0%E6%84%9F%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="无人驾驶-感知层-传感器（一）——激光雷达"><a href="#无人驾驶-感知层-传感器（一）——激光雷达" class="headerlink" title="无人驾驶-感知层-传感器（一）——激光雷达"></a>无人驾驶-感知层-传感器（一）——激光雷达</h3><h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><p>2021年最火爆的技术毫无疑问是无人驾驶技术，而无人驾驶技术里面竞争最激烈的便是激光雷达，蔚来1个、小鹏2个、北汽极狐αS2个、威马3个…智能汽车“军备竞赛”正在上演。那我们来看看激光雷达它为什么这么备受青睐。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86/image-20211101164030415.png"></p><p><strong>激光雷达</strong>：LiDAR<strong>（</strong>Light Detection and Ranging），是以发射激光束探测目标的位置、速度等特征量的雷达系统。近年来在机器人、无人驾驶领域得到了广泛的应用。</p><h4 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h4><p>工作原理是向目标发射探测信号(激光束）,然后将接收到的从目标反射回来的信号（目标回波）与发射信号进行比较,作适当处理后,就可获得目标的有关信息,如目标距离、方位、高度、速度、姿态、甚至形状等参数,从而对车辆、行人等目标进行探测、跟踪和识别。可以通过三角法测距或者TOF测距计算出激光雷达与物体的距离。因此对应有三角测距激光雷达和TOF测距激光雷达。</p><h5 id="2-1、三角测距激光雷达"><a href="#2-1、三角测距激光雷达" class="headerlink" title="2.1、三角测距激光雷达"></a>2.1、三角测距激光雷达</h5><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86/pIYBAGBvxlyAOmXDAABy6qDFssI146.png"></p><p>基本原理如上图所示。雷达测距模块向外发射<a href="http://www.elecfans.com/tags/%E7%BA%A2%E5%A4%96/">红外</a>激光，入射到被测物体上之后，部分散射光经接收透镜汇聚到线阵<a href="http://www.elecfans.com/tags/%E5%9B%BE%E5%83%8F%E4%BC%A0%E6%84%9F%E5%99%A8/">图像传感器</a>（CCD/CMOS）上成像。</p><p>由图中的几何关系可知，位于不同距离的物体，出射激光形成的光斑在线阵上成像的位置亦不相同；另一方面，测距模块的内部结构固定不变，接收透镜的焦距f，以及发射光路光轴与接收透镜主光轴之间的偏移（即基<a href="http://www.hqpcb.com/zhuoluye11/?tid=26&plan=fashaoyou">线距</a>离）L这两项参数都是已知的。根据三角形的相似关系，即可计算出物体的距离D如下：</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86/pIYBAGBvxlyAA1UwAAAGWnHapLU487.png"></p><p>以上原理介绍为最简化的情况。但在实际应用中，为了提高距离分辨率，以及充分利用线阵图像传感器的像素资源，通常将发射光路光轴与接收透镜主光轴布置为呈一定斜角（而非图示中的平行关系），但相似三角形的基本原理并无变化。</p><p><strong>影响三角测距激光雷达精度的参数：距离分辨率和测量速率。</strong></p><p><strong>距离分辨率：</strong>就是对不同距离目标的区分能力，相当于用尺子量长度时，使用的尺子的最小刻度是多少，三角测距的一大特点是这把“尺子”的刻度是不均匀的。对于比较近的距离区间，目标距离的变化会引起成像点位置的显著变化；而当目标位于远处时，即便距离发生很大的变化，体现到成像点上只会产生一点点移动，也就是说，三角测距的距离分辨率会随着距离的变远而急速下降。</p><p><strong>测量速率：</strong>机械式单线激光雷达在旋转扫描的同时对不同方向上的目标进行测距，因此测量速率直接决定了雷达能否以更快的速率扫描（对应更高的帧率），以及在完成一周扫描时能否输出更多的测量点（对应更高的角度分辨率）。为了达到一定的距离分辨率，三角测距激光雷达往往都会使用较高分辨率的线阵图像传感器，通常具有数千个像素点，每次测距时需要将这些像素点的灰度值读出并交给 DSP 处理，整个读出和处理的过程需要耗费一定时间，从而限制了三角测距激光雷达的数据速率。</p><h5 id="2-1、TOF测距激光雷达"><a href="#2-1、TOF测距激光雷达" class="headerlink" title="2.1、TOF测距激光雷达"></a>2.1、TOF测距激光雷达</h5><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86/pIYBAGBvxlyAcQkxAAB7AJCWE7A480.png"></p><p>​    </p><p><strong>原理：</strong>①、开始测距时，脉冲驱动<a href="http://www.hqpcb.com/">电路</a>驱动激光器发射一个持续时间极短但瞬时功率非常高的光脉冲，同时<a href="http://www.hqchip.com/app/1045">计时</a>单元启动计时；</p><p>​            ②、光脉冲经发射光路出射后，到达被测物体的表面并向各方向散射。测距模块的接收光路收到部分散射光能量，通过光电器件转化为光电流，输送给回波信号处理电路；</p><p>​            ③、回波信号处理电路将光电流转化为电压信号，经过一级或数级放大并调理后，得到一个回波信号对应的电脉冲，用于触发计时单元停止计时；</p><p>​            ④、此时，计时单元记录的时间间隔就代表了激光脉冲从发射到返回的全程所用的时间，使用这个时间值乘以光速并除以2，即可得到测距单元与被测目标之间的距离值。</p><p>ToF测距的原理很容易理解，但具体工程实现时有不少技术难点需要解决，这主要是由于ToF测距的工作条件比较极端，非常大（脉冲发射峰值）、非常弱（脉冲回波）和非常快（纳秒/皮秒级别）的信号，这就对整个电路的驱动能力、带宽和噪声抑制水平提出了很高的要求。但它的优势在于，只要解决了上述这些问题，整个测距系统可以实现非常高的性能。</p><h4 id="3、优点"><a href="#3、优点" class="headerlink" title="3、优点"></a>3、优点</h4><p>①、具有极高的分辨率：激光雷达工作于光学波段，频率比微波高2~3个数量级以上，与微波雷达相比，激光雷达具有极高的分辨率、角分辨率和速度分辨率；</p><p>②、抗干扰能力强:激光波长短，可发散角非常小的激光束，多路径效应小（不会形成定向发射于微波或毫米波产生多路径效应），可探测低空/超低空目标；</p><p>③、获取的信息量丰富：可直接获取目标的距离、角度、反射强度、速度等信息，生成目标对位图像；</p><p>④、可全天候工作：激光主动探测，不依赖于外界光照条件或目标本身的辐射特性。它只需发射自己的激光束，通过探测发射激光束的回波信号来获取目标信息。</p><h4 id="4、缺点"><a href="#4、缺点" class="headerlink" title="4、缺点"></a>4、缺点</h4><p>①、成本：激光雷达的成本是限定无人驾驶落地的原因之一；</p><p>②、应用坏境：易受天气影响（如大雾、雨天、烟尘会影响激光雷达精度）；</p><p>③、属性识别能力较弱：激光雷达的点云数据是物体的几何外形呈现，无法如同人眼视觉一样分辨物体的物理特性，如颜色、纹理等。</p><h4 id="5、分类"><a href="#5、分类" class="headerlink" title="5、分类"></a>5、分类</h4><p>①、根据线束多少，激光雷达可分为单线束和多线束（2线、4线、8线、16线、32线、64线、128线，2的倍速）。</p><p>单线束激光雷达扫描一次只能产生一条扫描线，所获得的数据为2D数据，无法区别有关物体的3D信息；多线束激光雷达可将多个横向扫描结果纵向叠加，从而获取3D数据，线束越多，纵向的垂直视角越大，价格越贵。</p><p>②、按照扫描方式，激光雷达主要分为三类：</p><p>一是光机结构整体旋转的<strong>机械式激光雷达</strong>（以Velydone公司为代表），在此基础上衍生出了收发模块不动的棱镜或转镜的激光雷达（如Livox览沃）；</p><p>二是<strong>半固态激光雷达</strong>，主要采用<strong>MEMS微振镜</strong>（Luminar/Innoviz等品牌）；</p><p>三是<strong>固态激光雷达</strong>，又分为了<strong>电子扫描</strong>或者<strong>整体曝光Flash面阵</strong>（Leddar/Ibeo/Ouster），以及<strong>基于光学相控的OPA方式</strong>（Quanergy/Lumotive），当前市场主流正朝着MEMS方向发展。</p><h4 id="6、公司"><a href="#6、公司" class="headerlink" title="6、公司"></a>6、公司</h4><p><strong>速腾聚创</strong>、华为、<strong>Livox</strong>、<strong>图达通 Innovusion</strong>、禾赛科技、镭神智能</p><h4 id="7、应用"><a href="#7、应用" class="headerlink" title="7、应用"></a>7、应用</h4><blockquote><p>参考：<a href="http://www.elecfans.com/d/1566850.html">http://www.elecfans.com/d/1566850.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 激光雷达-SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 激光雷达-SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1、PicGo+Gitee搭建图床</title>
      <link href="/2021/11/10/9%E3%80%81hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1%E3%80%81PicGo+gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2021/11/10/9%E3%80%81hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1%E3%80%81PicGo+gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="1、PicGo-Gitee搭建图床"><a href="#1、PicGo-Gitee搭建图床" class="headerlink" title="1、PicGo+Gitee搭建图床"></a>1、PicGo+Gitee搭建图床</h2><h3 id="1-1、新建仓库"><a href="#1-1、新建仓库" class="headerlink" title="1.1、新建仓库"></a>1.1、新建仓库</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110125935.png"></p><h3 id="1-2、配置仓库"><a href="#1-2、配置仓库" class="headerlink" title="1.2、配置仓库"></a>1.2、配置仓库</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110125941.png"></p><h3 id="1-3、生成密钥"><a href="#1-3、生成密钥" class="headerlink" title="1.3、生成密钥"></a>1.3、生成密钥</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110125945.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110130007.png"></p><p>这个密钥一定要保存好，之后就显示不了了</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110130239.png"></p><h2 id="2、下载PigGo软件"><a href="#2、下载PigGo软件" class="headerlink" title="2、下载PigGo软件"></a>2、下载PigGo软件</h2><h3 id="2-1、下载连接"><a href="#2-1、下载连接" class="headerlink" title="2.1、下载连接"></a>2.1、下载连接</h3><blockquote><p><a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110130012.png"></p><p>然后直接安装。。。</p><h3 id="2-2、下载gitee插件"><a href="#2-2、下载gitee插件" class="headerlink" title="2.2、下载gitee插件"></a>2.2、下载gitee插件</h3><p><strong>注意：一定要以管理员身份运行后在安装！，不然会一直安装不了！</strong></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110130016.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110130019.png"></p><h3 id="2-3、搭建图床"><a href="#2-3、搭建图床" class="headerlink" title="2.3、搭建图床"></a>2.3、搭建图床</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110132304.png"></p><p>可以把其它不用的图床关闭</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110132308.png"></p><h3 id="2-4、上传"><a href="#2-4、上传" class="headerlink" title="2.4、上传"></a>2.4、上传</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110130955.png"></p><p>显示</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110131000.png"></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思岚SLAMTEC A1开箱测试</title>
      <link href="/2021/11/10/8%E3%80%81%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8F%8ASLAM/%E4%B8%80%E3%80%81%E6%80%9D%E5%B2%9ASLAMTEC%20A1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/11/10/8%E3%80%81%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8F%8ASLAM/%E4%B8%80%E3%80%81%E6%80%9D%E5%B2%9ASLAMTEC%20A1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="思岚SLAMTEC-A1开箱测试"><a href="#思岚SLAMTEC-A1开箱测试" class="headerlink" title="思岚SLAMTEC A1开箱测试"></a>思岚SLAMTEC A1开箱测试</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120319.png"></p><h4 id="一、测试坏境"><a href="#一、测试坏境" class="headerlink" title="一、测试坏境"></a>一、测试坏境</h4><p>①、SLAMTEC A1激光雷达；</p><p>②、Ubuntu16.04 下 ROS Kinetic。</p><h4 id="二、测试功能"><a href="#二、测试功能" class="headerlink" title="二、测试功能"></a>二、测试功能</h4><p>①、运行ROS包，查看雷达数据</p><p>②、使用hector_slam进行建图</p><h4 id="三、具体实现过程"><a href="#三、具体实现过程" class="headerlink" title="三、具体实现过程"></a>三、具体实现过程</h4><p>1、建立ROS工作空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/dev/catkin_ws/src</span><br></pre></td></tr></table></figure><p>进入src文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/dev/catkin_ws/src</span><br></pre></td></tr></table></figure><p>初始化工作空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><p>在src文件中创建了一个 CMakeLists.txt 的文件，告诉系统ROS的工作空间。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120332.png"></p><p>2、下载ROS相关的功能包</p><p>在src目录下 下载SLAMTEC的激光雷达ROS包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Slamtec/rplidar_ros.git</span><br></pre></td></tr></table></figure><p>下载Hector_SLAM建图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tu-darmstadt-ros-pkg/hector_slam.git</span><br></pre></td></tr></table></figure><p>3、在工作空间中编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/dev/catkin_ws/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>添加环境变量source</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/dev/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure><p>(为了让source永久生效，应该写入.bashrc文件中）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo&quot;source~/dev/catkin_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>4、驱动安装</p><p>源码安装 rplidar-ros 雷达驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-kinetic-rplidar-ros</span><br></pre></td></tr></table></figure><p>源码安装 hector_slam库</p><pre><code>sudo apt-get install ros-kinetic-hector-slam</code></pre><p>在rplidar_ros中新建slam.launch文件<strong>（非常重要，不然会报错）</strong></p><p>在rplidar_ros/launch/目录下添加slam.launch文件:</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120337.png"></p><p>slam.launch文件中复制如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;node pkg=&quot;hector_mapping&quot; type=&quot;hector_mapping&quot; name=&quot;hector_mapping&quot; output=&quot;screen&quot;&gt;</span><br><span class="line">&lt;!-- Frame names --&gt;</span><br><span class="line">&lt;param name=&quot;pub_map_odom_transform&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;map_frame&quot; value=&quot;map&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;base_frame&quot; value=&quot;base_link&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;odom_frame&quot; value=&quot;base_link&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- Tf use --&gt;</span><br><span class="line">&lt;param name=&quot;use_tf_scan_transformation&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;use_tf_pose_start_estimate&quot; value=&quot;false&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- Map size / start point --&gt;</span><br><span class="line">&lt;param name=&quot;map_resolution&quot; value=&quot;0.05&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;map_size&quot; value=&quot;2048&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;map_start_x&quot; value=&quot;0.5&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;map_start_y&quot; value=&quot;0.5&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;laser_z_min_value&quot; value = &quot;-1.0&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;laser_z_max_value&quot; value = &quot;1.0&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;map_multi_res_levels&quot; value=&quot;2&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;param name=&quot;map_pub_period&quot; value=&quot;2&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;laser_min_dist&quot; value=&quot;0.4&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;laser_max_dist&quot; value=&quot;5.5&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;output_timing&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;pub_map_scanmatch_transform&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;!--&lt;param name=&quot;tf_map_scanmatch_transform_frame_name&quot; value=&quot;scanmatcher_frame&quot; /&gt;--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- Map update parameters --&gt;</span><br><span class="line">&lt;param name=&quot;update_factor_free&quot; value=&quot;0.4&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;update_factor_occupied&quot; value=&quot;0.7&quot; /&gt;    </span><br><span class="line">&lt;param name=&quot;map_update_distance_thresh&quot; value=&quot;0.2&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;map_update_angle_thresh&quot; value=&quot;0.06&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- Advertising config --&gt; </span><br><span class="line">&lt;param name=&quot;advertise_map_service&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;scan_subscriber_queue_size&quot; value=&quot;5&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;scan_topic&quot; value=&quot;scan&quot;/&gt;</span><br><span class="line">&lt;/node&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;base_to_laser_broadcaster&quot; args=&quot;0 0 0 0 0 0 /base_link /laser 100&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot;</span><br><span class="line">    args=&quot;-d $(find hector_slam_launch)/rviz_cfg/mapping_demo.rviz&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/launch&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、连接雷达</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120343.png"></p><p>雷达连接好后会出现usb串口<br>查看usb串口及权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /dev |grep ttyUSB</span><br></pre></td></tr></table></figure><p>对应的文件号应该是ttyUSB0<br>给串口文件号ttyUSB0添加写权限为：666  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 666 /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>6、使用rviz雷达数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">roslaunch rplidar_ros view_rplidar.launch</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120348.png"></p><p>7、在终端查看雷达数据</p><p>启动ros主节点以及启动激光雷达</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">roslaunch rplidar_ros rplidar.launch</span><br></pre></td></tr></table></figure><p>启动rplidarNodeClient节点，在终端查看数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun rplidar_ros rplidarNodeClient</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120354.png"></p><p>8、使用Hector_SLAM建图</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">roslaunch rplidar_ros slam.launch</span><br></pre></td></tr></table></figure><p>如果出现如下报错</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120359.png"></p><p>进入到rplidar_ws目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/rplidar_ws</span><br><span class="line">source devel/setup.bash</span><br><span class="line">roslaunch rplidar_ros slam.launch</span><br></pre></td></tr></table></figure><p>一定要切换rplidar_ws到此目录下在启动命令；</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120403.png"></p><p>9、保存slam得到的地图信息<br>先安装map_server包；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-kinetic-map-server</span><br></pre></td></tr></table></figure><p>然后，保存图形。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun map_server map_saver -f ~/my_map</span><br></pre></td></tr></table></figure><h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><p>进入roscoore,有时会使用CTRL+Z误操作关闭了ROS进程；</p><p>解决方案： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">killall -9 roscore</span><br><span class="line"></span><br><span class="line">killall -9 rosmaster</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://blog.csdn.net/NouriXiiX/article/details/102690064">https://blog.csdn.net/NouriXiiX/article/details/102690064</a></p><p>​            <a href="https://blog.csdn.net/t624124600/article/details/110723844">https://blog.csdn.net/t624124600/article/details/110723844</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 激光雷达-SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 激光雷达-SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FileZilla连接阿里云服务器</title>
      <link href="/2021/11/10/11%E3%80%81%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/FileZilla%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2021/11/10/11%E3%80%81%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/FileZilla%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="FileZilla连接阿里云服务器"><a href="#FileZilla连接阿里云服务器" class="headerlink" title="FileZilla连接阿里云服务器"></a>FileZilla连接阿里云服务器</h3><blockquote><p>目的：可以更好的管理云文件</p></blockquote><p>设置</p><p>在远程服务器端通过指令vim /etc/ssh/sshd_config开放22号端口</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/FileZilla%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/20211110100635.png"></p><p>设置云服务器的安全组ID，添加20/21</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/FileZilla%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/20211110100640.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/FileZilla%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/20211110100643.png"></p><p>然后启动FileZilla，新建站点，设置SFTP、公网地址（主机）、root账号（用户名）、密码、填写22端口进行连接。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/FileZilla%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/20211110100646.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/FileZilla%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/20211110100650.png"></p>]]></content>
      
      
      <categories>
          
          <category> 问题及解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题及解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、Matlab快速绘制栅格地图</title>
      <link href="/2021/11/09/7%E3%80%81%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1%E3%80%81Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/"/>
      <url>/2021/11/09/7%E3%80%81%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1%E3%80%81Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Matlab快速绘制栅格地图"><a href="#一、Matlab快速绘制栅格地图" class="headerlink" title="一、Matlab快速绘制栅格地图"></a>一、Matlab快速绘制栅格地图</h2><blockquote><p>声明：本文是学习古月居~基于栅格地图的机器人路径规划算法指南• 黎万洪](<a href="https://class.guyuehome.com/detail/p_6098db8ce4b071a81eb8befa/6)%E5%90%8E%E5%86%99%E7%9A%84%E7%AC%94%E8%AE%B0%EF%BC%8C%E5%A5%BD%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A6%82%E7%83%82%E7%AC%94%E5%A4%B4%EF%BC%81%E6%96%B9%E4%BE%BF%E6%97%A5%E5%90%8E%E7%9A%84%E5%B7%A9%E5%9B%BA%E4%B8%8E%E5%A4%8D%E4%B9%A0%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%95%99%E7%A8%8B%E8%AE%B2%E7%9A%84%E5%BE%88%E9%AB%98%EF%BC%8C%E5%80%BC%E5%BE%97%E6%8E%A8%E8%8D%90%EF%BC%81">https://class.guyuehome.com/detail/p_6098db8ce4b071a81eb8befa/6)后写的笔记，好记性不如烂笔头！方便日后的巩固与复习，这个教程讲的很高，值得推荐！</a></p></blockquote><h3 id="1、几种常用的地图形式："><a href="#1、几种常用的地图形式：" class="headerlink" title="1、几种常用的地图形式："></a>1、几种常用的地图形式：</h3><h4 id="1-1、尺度地图："><a href="#1-1、尺度地图：" class="headerlink" title="1.1、尺度地图："></a>1.1、尺度地图：</h4><p>具有真实的物理尺度，如：栅格地图、特征地图、点云地图，常用于地图构建、定位、SLAM、小规模路径规划。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109230749.png"></p><h4 id="1-2、拓扑地图："><a href="#1-2、拓扑地图：" class="headerlink" title="1.2、拓扑地图："></a>1.2、拓扑地图：</h4><p>不具备真实的物理尺度，只表示不同地点的连接关系和距离，如铁路网。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224555.png"></p><h4 id="1-3、语义地图："><a href="#1-3、语义地图：" class="headerlink" title="1.3、语义地图："></a>1.3、语义地图：</h4><p>加标签的尺度地图，常用于人机交互。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224559.png"></p><h3 id="2、栅格地图用于路径规划的优势："><a href="#2、栅格地图用于路径规划的优势：" class="headerlink" title="2、栅格地图用于路径规划的优势："></a>2、栅格地图用于路径规划的优势：</h3><blockquote><p>①、可以将任意形状轮廓的地图，用足够精细的栅格进行绘制；</p><p>②、每一个栅格，可以通过不同颜色表示不同含义，如黑色代表障碍物、黄色代表起点、红色代表终点；</p><p>③、基于栅格地图进行路径规划有横、纵、斜三个规划方向。对应室内低速机器人可以完全按照路径行走；对于中高速机器人，可以考虑将路径进行平滑处理，以适用于非完全约束系统。</p></blockquote><h3 id="3、matlab绘制栅格地图的核心函数及思想："><a href="#3、matlab绘制栅格地图的核心函数及思想：" class="headerlink" title="3、matlab绘制栅格地图的核心函数及思想："></a>3、matlab绘制栅格地图的核心函数及思想：</h3><h4 id="3-1、colormap函数："><a href="#3-1、colormap函数：" class="headerlink" title="3.1、colormap函数："></a>3.1、colormap函数：</h4><blockquote><p>为栅格地图创建自定义颜色。如黄色栅格代表起点、红色为终点。</p></blockquote><h4 id="3-2、sub2ind函数："><a href="#3-2、sub2ind函数：" class="headerlink" title="3.2、sub2ind函数："></a>3.2、sub2ind函数：</h4><p>将行列索引转为线性索引。对于右图栅格地图，10行1列，行从左上角自上而下排序，列从左上角自左向右排序。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224604.png"></p><h4 id="3-3、ind2sub函数："><a href="#3-3、ind2sub函数：" class="headerlink" title="3.3、ind2sub函数："></a>3.3、ind2sub函数：</h4><blockquote><p>与sub2ind相反，是将线性索引转为行列索引。</p></blockquote><h4 id="3-4、为了在栅格地图呈现随机障碍物的效果，可以设置障碍物出现频率数值，根据该数据在所有栅格中生成随机数，从而确定障碍物栅格。"><a href="#3-4、为了在栅格地图呈现随机障碍物的效果，可以设置障碍物出现频率数值，根据该数据在所有栅格中生成随机数，从而确定障碍物栅格。" class="headerlink" title="3.4、为了在栅格地图呈现随机障碍物的效果，可以设置障碍物出现频率数值，根据该数据在所有栅格中生成随机数，从而确定障碍物栅格。"></a>3.4、为了在栅格地图呈现随机障碍物的效果，可以设置障碍物出现频率数值，根据该数据在所有栅格中生成随机数，从而确定障碍物栅格。</h4><h4 id="3-5、image函数："><a href="#3-5、image函数：" class="headerlink" title="3.5、image函数："></a>3.5、image函数：</h4><p>利用colormap建立的颜色图，将数组信息显示为图像。</p><h3 id="4、具体例子："><a href="#4、具体例子：" class="headerlink" title="4、具体例子："></a>4、具体例子：</h3><h3 id="4-1、利用Matlab快速绘制栅格地图matlab代码："><a href="#4-1、利用Matlab快速绘制栅格地图matlab代码：" class="headerlink" title="4.1、利用Matlab快速绘制栅格地图matlab代码："></a>4.1、利用Matlab快速绘制栅格地图matlab代码：</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 构建颜色MAP图</span></span><br><span class="line">cmap = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>; ...       <span class="comment">% 1-白色-空地</span></span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; ...           <span class="comment">% 2-黑色-静态障碍</span></span><br><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; ...           <span class="comment">% 3-红色-动态障碍</span></span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>;...            <span class="comment">% 4-黄色-起始点 </span></span><br><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;...            <span class="comment">% 5-品红-目标点</span></span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>; ...           <span class="comment">% 6-绿色-到目标点的规划路径   </span></span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>];              <span class="comment">% 7-青色-动态规划的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 构建颜色MAP图</span></span><br><span class="line">colormap(cmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 构建栅格地图场景</span></span><br><span class="line"><span class="comment">% 栅格界面大小:行数和列数</span></span><br><span class="line">rows = <span class="number">10</span>;</span><br><span class="line">cols = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义栅格地图全域，并初始化空白区域</span></span><br><span class="line">field = <span class="built_in">ones</span>(rows, cols);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 障碍物区域</span></span><br><span class="line">obsRate = <span class="number">0.3</span>;</span><br><span class="line">obsNum = <span class="built_in">floor</span>(rows*cols*obsRate);</span><br><span class="line">obsIndex = randi([<span class="number">1</span>,rows*cols],obsNum,<span class="number">1</span>);</span><br><span class="line">field(obsIndex) = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 起始点和目标点</span></span><br><span class="line">startPos = <span class="number">2</span>;</span><br><span class="line">goalPos = rows*cols<span class="number">-2</span>;</span><br><span class="line">field(startPos) = <span class="number">4</span>;</span><br><span class="line">field(goalPos) = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 画栅格图</span></span><br><span class="line">image(<span class="number">1.5</span>,<span class="number">1.5</span>,field);</span><br><span class="line">grid on;</span><br><span class="line">set(gca,<span class="string">&#x27;gridline&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;gridcolor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;GridAlpha&#x27;</span>,<span class="number">0.5</span>);</span><br><span class="line">set(gca,<span class="string">&#x27;xtick&#x27;</span>,<span class="number">1</span>:cols+<span class="number">1</span>,<span class="string">&#x27;ytick&#x27;</span>,<span class="number">1</span>:rows+<span class="number">1</span>);</span><br><span class="line">axis image;</span><br></pre></td></tr></table></figure><h3 id="4-2、运行结构："><a href="#4-2、运行结构：" class="headerlink" title="4.2、运行结构："></a>4.2、运行结构：</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224610.png"></p><h3 id="4-3、具体分析"><a href="#4-3、具体分析" class="headerlink" title="4.3、具体分析"></a>4.3、具体分析</h3><p>1、</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">close all</span><br></pre></td></tr></table></figure><blockquote><p>clc：清除命令窗口的内容，对工作环境中的全部变量无任何影响<br>close：关闭当前的Figure窗口<br>close all:关闭所有的Figure窗口<br>clear：清除工作空间的所有变量<br>clear all：清除工作空间的所有变量，函数，和MEX文件</p></blockquote><p>2、自定义构建颜色MAP图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 构建颜色MAP图</span></span><br><span class="line">cmap = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>; ...       <span class="comment">% 1-白色-空地</span></span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; ...           <span class="comment">% 2-黑色-静态障碍</span></span><br><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; ...           <span class="comment">% 3-红色-动态障碍</span></span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>;...            <span class="comment">% 4-黄色-起始点 </span></span><br><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;...            <span class="comment">% 5-品红-目标点</span></span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>; ...           <span class="comment">% 6-绿色-到目标点的规划路径   </span></span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>];              <span class="comment">% 7-青色-动态规划的路径</span></span><br></pre></td></tr></table></figure><p>运行后会建立对应变量的MAP图值</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224616.png"></p><p>3、colormap构建颜色MAP图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 构建颜色MAP图</span></span><br><span class="line">colormap(cmap);</span><br></pre></td></tr></table></figure><p>4、构建栅格地图场景：大小</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 构建栅格地图场景</span></span><br><span class="line"><span class="comment">% 栅格界面大小:行数和列数</span></span><br><span class="line">rows = <span class="number">10</span>;</span><br><span class="line">cols = <span class="number">10</span>; </span><br></pre></td></tr></table></figure><p>5、定义栅格地图全域，并初始化空白区域</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 定义栅格地图全域，并初始化空白区域</span></span><br><span class="line">field = <span class="built_in">ones</span>(rows, cols);</span><br></pre></td></tr></table></figure><p>将栅格图全设置为白色</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224620.png"></p><p>6、障碍物区域</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 障碍物区域</span></span><br><span class="line">obsRate = <span class="number">0.3</span>;</span><br><span class="line">obsNum = <span class="built_in">floor</span>(rows*cols*obsRate);</span><br><span class="line">obsIndex = randi([<span class="number">1</span>,rows*cols],obsNum,<span class="number">1</span>);</span><br><span class="line">field(obsIndex) = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><blockquote><p>obsRate = 0.3;%障碍物占比率</p><p>obsNum = floor(rows<em>cols</em>obsRate);%计算障碍物个数；</p><p>obsIndex = randi([1,rows*cols],obsNum,1);%随机设置障碍物</p></blockquote><p>得到障碍物的区域</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224624.png"></p><p>7、起始点和目标点</p><p>起始点和目标点要定义在障碍物后面，不然可能会和障碍物冲突</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 起始点和目标点</span></span><br><span class="line">startPos = <span class="number">2</span>;</span><br><span class="line">goalPos = rows*cols<span class="number">-2</span>;</span><br><span class="line">field(startPos) = <span class="number">4</span>;</span><br><span class="line">field(goalPos) = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><blockquote><p>startPos = 2; &amp;起点<br>goalPos = rows*cols-2;%终点<br>field(startPos) = 4; %起点为黄色<br>field(goalPos) = 5; %终点为红色</p></blockquote><p>8、画栅格图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 画栅格图</span></span><br><span class="line">image(<span class="number">1.5</span>,<span class="number">1.5</span>,field);</span><br><span class="line">grid on;</span><br><span class="line">set(gca,<span class="string">&#x27;gridline&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;gridcolor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;GridAlpha&#x27;</span>,<span class="number">0.5</span>);</span><br><span class="line">set(gca,<span class="string">&#x27;xtick&#x27;</span>,<span class="number">1</span>:cols+<span class="number">1</span>,<span class="string">&#x27;ytick&#x27;</span>,<span class="number">1</span>:rows+<span class="number">1</span>);</span><br><span class="line">axis image;</span><br></pre></td></tr></table></figure><blockquote><p>image(1.5,1.5,field);%画出颜色图</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224629.png"></p><p>grid on;% 画出网格</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224633.png"></p><p>set(gca,’gridline’,’-‘,’gridcolor’,’k’,’linewidth’,2,’GridAlpha’,0.5); % 设置网格为：网格线<del>实线、颜色</del>黑色、线宽<del>2、透明度</del>0.5；</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224637.png"></p><p>set(gca,’xtick’,1:cols+1,’ytick’,1:rows+1); % 设置长宽高为一样~正方形<br>axis image;</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224642.png"></p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 路径规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用过程中遇到的问题（一）：push fail</title>
      <link href="/2021/11/09/6%E3%80%81git/Git%20push%E5%88%B0%E4%BB%93%E5%BA%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AFailed%20to%20connect%20to%20github.com%20port%20443%20Timed%20out/"/>
      <url>/2021/11/09/6%E3%80%81git/Git%20push%E5%88%B0%E4%BB%93%E5%BA%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AFailed%20to%20connect%20to%20github.com%20port%20443%20Timed%20out/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-push到仓库过程中遇到的问题（一）：Failed-to-connect-to-github-com-port-443-Timed-out"><a href="#Git-push到仓库过程中遇到的问题（一）：Failed-to-connect-to-github-com-port-443-Timed-out" class="headerlink" title="Git push到仓库过程中遇到的问题（一）：Failed to connect to github.com port 443: Timed out"></a>Git push到仓库过程中遇到的问题（一）：Failed to connect to github.com port 443: Timed out</h2><blockquote><p>声明：本文是记录了自己在使用git过程中遇到push到GitHub仓库失败的问题后的解决过程，为以后复习！</p></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Git%E4%BD%BF%E7%94%A8/20211109202128.png"></p><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p><strong>1、打开windos设置，进入网络和Internet</strong></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Git%E4%BD%BF%E7%94%A8/20211109202750.png"></p><p><strong>2、点击代理，关闭自动检测设置</strong></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Git%E4%BD%BF%E7%94%A8/20211109202055.png"></p><p><strong>3、重新push</strong></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Git%E4%BD%BF%E7%94%A8/20211109202109.png"></p><p><strong>上传成功</strong></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Git%E4%BD%BF%E7%94%A8/20211109202215.png"></p><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p><strong>使用命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure><p><strong>直接设置不使用代理</strong></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、STM32CubeMX安装</title>
      <link href="/2021/11/09/4%E3%80%81STM32/2%E3%80%81STM32CubeMX/STM32CubeMX%E5%AE%89%E8%A3%85/"/>
      <url>/2021/11/09/4%E3%80%81STM32/2%E3%80%81STM32CubeMX/STM32CubeMX%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="STM32CubeMX安装"><a href="#STM32CubeMX安装" class="headerlink" title="STM32CubeMX安装"></a>STM32CubeMX安装</h3><h4 id="1、STM32CubeMX介绍"><a href="#1、STM32CubeMX介绍" class="headerlink" title="1、STM32CubeMX介绍"></a>1、STM32CubeMX介绍</h4><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image.PF259242.en.feature-description-include-personalized-no-cpn-large.jpg"></p><p>​    STM32CubeMX是ST公司主动原创的一款代码生成工具， 它可以减轻开发时间和费用。STM32CubeMX集成了一个全面的软件平台，支持STM32每一个系列的MCU开发。这个平台 包括 STM32Cube HAL（一个 STM32 的抽象层集成软件，确保 STM32 系列最大的移植性），再加上兼容的一套中间件 （RTOS、USB、TCP/IP 和图形）。所有内嵌软件组件附带了全套例程。 </p><h4 id="2、软件坏境安装"><a href="#2、软件坏境安装" class="headerlink" title="2、软件坏境安装"></a>2、软件坏境安装</h4><p>STM32CubeMX软件是基于java环境运行的，所以需要安装JRE才能使用。 </p><p>STM32CubeMX要求JRE最低版本是1.7.0_45，所以最好使用教新的版本，JAVA官方网址为：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a> ，安装完成后配置好Java环境变量 。</p><h4 id="3、STM32CubeMX软件下载"><a href="#3、STM32CubeMX软件下载" class="headerlink" title="3、STM32CubeMX软件下载"></a>3、STM32CubeMX软件下载</h4><p>软件获取方式： </p><p>①、 ST官网：工具和软件→开发工具→Software Development Tools→STM32CubeMX→GET SOFTWARE </p><p>官网下载地址链接：<a href="https://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-configurators-and-code-generators/stm32cubemx.html">https://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-configurators-and-code-generators/stm32cubemx.html</a></p><p>②、从官网下载需要注册ST账号，所以我已经将软件下载好放在百度云盘，需要的关注公众号《Kevin的嵌入式学习站》，后台回复“STM32CubeMX”。</p><h4 id="4、安装步骤"><a href="#4、安装步骤" class="headerlink" title="4、安装步骤"></a>4、安装步骤</h4><p>①、解压安装包后，点击SetupSTM32CubeMX-4.27.0，以管理员权限运行</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102225307384.png"></p><p>②、安装步骤</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102230354486.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102230429236.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102230539190.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102230608865.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102230637341.png"></p><p>安装完成后可以在桌面打开STM32CubeMX</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102230737383.png"></p><p>安装对应的支持包，因为支持包比较大，所以最好更改一下默认安装路径，<strong>但切记不能出现中文路径</strong></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102230825288.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102231049976.png"></p><p>安装支持包</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102231122078.png"></p><p>安装自己开发所需要的支持包，如我需要如下安装包</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102231229774.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102231324494.png"></p><p>当然也可以提前下好支持包，然后再导入到软件中</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102231640286.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102231756636.png"></p><p>到此安装结束，<strong>值得注意的是安装坏境不要出现中文环境，不然后期开发会报错！</strong></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、ROS开发中常用的命令</title>
      <link href="/2021/11/09/3%E3%80%81ROS/%E4%B8%89%E3%80%81ROS%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/09/3%E3%80%81ROS/%E4%B8%89%E3%80%81ROS%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="三、ROS开发中常用的命令"><a href="#三、ROS开发中常用的命令" class="headerlink" title="三、ROS开发中常用的命令"></a><strong>三、ROS开发中常用的命令</strong></h2><h4 id="3-1、启动命令roscore"><a href="#3-1、启动命令roscore" class="headerlink" title="3.1、启动命令roscore"></a><strong>3.1、启动命令roscore</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><blockquote><p>必须运行 roscore 才能使 ROS 节点进行通信；</p><p>roscore 将启动:①、ros master；②、ros 参数服务器；③、rosout 日志节点</p></blockquote><h4 id="3-2、运行命令-rosrun"><a href="#3-2、运行命令-rosrun" class="headerlink" title="3.2、运行命令 rosrun"></a><strong>3.2、运行命令 rosrun</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun 包名 可执行文件名  //运行指定的ROS节点</span><br></pre></td></tr></table></figure><h4 id="3-3、创建新的ROS功能包"><a href="#3-3、创建新的ROS功能包" class="headerlink" title="3.3、创建新的ROS功能包"></a><strong>3.3、创建新的ROS功能包</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg 自定义包名 依赖包</span><br></pre></td></tr></table></figure><h4 id="3-4、安装-ROS功能包"><a href="#3-4、安装-ROS功能包" class="headerlink" title="3.4、安装 ROS功能包"></a><strong>3.4、安装 ROS功能包</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install xxx</span><br></pre></td></tr></table></figure><h4 id="3-5、删除某个功能包"><a href="#3-5、删除某个功能包" class="headerlink" title="3.5、删除某个功能包"></a><strong>3.5、删除某个功能包</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt purge xxx</span><br></pre></td></tr></table></figure><h4 id="3-6、列出所有功能包"><a href="#3-6、列出所有功能包" class="headerlink" title="3.6、列出所有功能包"></a><strong>3.6、列出所有功能包</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rospack list</span><br></pre></td></tr></table></figure><h4 id="3-7、查找某个功能包是否存在"><a href="#3-7、查找某个功能包是否存在" class="headerlink" title="3.7、查找某个功能包是否存在"></a><strong>3.7、查找某个功能包是否存在</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rospack find xxx</span><br></pre></td></tr></table></figure><h4 id="3-8、搜索某个功能包"><a href="#3-8、搜索某个功能包" class="headerlink" title="3.8、搜索某个功能包"></a><strong>3.8、搜索某个功能包</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search xxx</span><br></pre></td></tr></table></figure><h4 id="3-9、进入某个功能包"><a href="#3-9、进入某个功能包" class="headerlink" title="3.9、进入某个功能包"></a><strong>3.9、进入某个功能包</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscd xxx</span><br></pre></td></tr></table></figure><h4 id="3-10、列出某个包下的文件"><a href="#3-10、列出某个包下的文件" class="headerlink" title="3.10、列出某个包下的文件"></a><strong>3.10、列出某个包下的文件</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosls xxx</span><br></pre></td></tr></table></figure><h4 id="3-11、修改某个功能包文件"><a href="#3-11、修改某个功能包文件" class="headerlink" title="3.11、修改某个功能包文件"></a><strong>3.11、修改某个功能包文件</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosed 包名 文件名</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、Ubuntu下ROS 的安装和测试</title>
      <link href="/2021/11/09/3%E3%80%81ROS/%E4%B8%80%E3%80%81Ubuntu%E4%B8%8BROS%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/11/09/3%E3%80%81ROS/%E4%B8%80%E3%80%81Ubuntu%E4%B8%8BROS%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Ubuntu下ROS-的安装和测试"><a href="#一、Ubuntu下ROS-的安装和测试" class="headerlink" title="一、Ubuntu下ROS 的安装和测试"></a><strong>一、Ubuntu下ROS 的安装和测试</strong></h2><h4 id="1-1、在Ubuntu下选择合适的ROS版本"><a href="#1-1、在Ubuntu下选择合适的ROS版本" class="headerlink" title="1.1、在Ubuntu下选择合适的ROS版本"></a><strong>1.1、在Ubuntu下选择合适的ROS版本</strong></h4><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225548.png"></p><p>根据自己的Ubuntu坏境选择ROS版本，建议安装最新版本。</p><h4 id="1-2、配置ubuntu的软件和更新"><a href="#1-2、配置ubuntu的软件和更新" class="headerlink" title="1.2、配置ubuntu的软件和更新"></a><strong>1.2、配置ubuntu的软件和更新</strong></h4><p>配置ubuntu的软件和更新，允许安装不经认证的软件。</p><p>首先打开“软件和更新”对话框，具体可以在 Ubuntu 搜索按钮中搜索。</p><p>打开后按照下图进行配置（确保勾选了”restricted”， “universe，” 和 “multiverse.”）</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225554.png"></p><h4 id="1-3、设置安装源"><a href="#1-3、设置安装源" class="headerlink" title="1.3、设置安装源"></a><strong>1.3、设置安装源</strong></h4><p>官方默认安装源:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span><br></pre></td></tr></table></figure><p>或来自国内清华的安装源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span><br></pre></td></tr></table></figure><p>或来自国内中科大的安装源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://m</span><br></pre></td></tr></table></figure><p><strong>尽量使用国内安装源，安装的数度会快一些</strong></p><h4 id="1-4、设置key"><a href="#1-4、设置key" class="headerlink" title="1.4、设置key"></a><strong>1.4、设置key</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu</span><br></pre></td></tr></table></figure><p>若无法连接到密钥服务器，可以尝试替换上面命令中的 <code>hkp://keyserver.ubuntu.com:80</code> 为 <code>hkp://pgp.mit.edu:80</code> 。 </p><p>也可以使用curl命令替换apt-key命令，这在使用代理服务器的情况下比较有用： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL &#x27;http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654&#x27; | sudo apt-key add -</span><br></pre></td></tr></table></figure><h4 id="1-5、安装ROS"><a href="#1-5、安装ROS" class="headerlink" title="1.5、安装ROS"></a><strong>1.5、安装ROS</strong></h4><p>①、使用以下命令，确保Ubuntu软件包索引是最新的： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>②、安装完整桌面版的ROS，完整版包含了 ROS、<a href="http://wiki.ros.org/rqt">rqt</a>、<a href="http://wiki.ros.org/rviz">rviz</a>、机器人通用库、2D/3D 模拟器、导航以及 2D/3D 感知包。</p><p><strong>Ubuntu16.04下安装ROS Kinetic Kame 命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-kinetic-desktop-full</span><br></pre></td></tr></table></figure><p><strong>Ubuntu18.04下安装ROS Melodic 命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-melodic-desktop-full</span><br></pre></td></tr></table></figure><p><strong>Ubuntu20.04下安装ROS Noetic 命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-desktop-full</span><br></pre></td></tr></table></figure><p>出现错误</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225602.png"></p><p>重复多次安装一下，可能是因为网络的原因。</p><h4 id="1-6、配置ROS坏境"><a href="#1-6、配置ROS坏境" class="headerlink" title="1.6、配置ROS坏境"></a><strong>1.6、配置ROS坏境</strong></h4><p>配置环境变量，方便在任意 终端中使用 ROS。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="1-7、ROS卸载"><a href="#1-7、ROS卸载" class="headerlink" title="1.7、ROS卸载"></a><strong>1.7、ROS卸载</strong></h4><p>如果需要卸载ROS可以调用如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove ros-noetic-*</span><br></pre></td></tr></table></figure><h4 id="1-8、初始化-rosdep"><a href="#1-8、初始化-rosdep" class="headerlink" title="1.8、初始化 rosdep"></a><strong>1.8、初始化 rosdep</strong></h4><p>在使用 ROS 之前，需要初始化 <code>rosdep</code>。<code>rosdep</code> 能够轻松地安装被想要编译的源代码，或被某些 ROS 核心组件需要的系统依赖。</p><p>避免后面出现sudo rosdep：找不到命令提示，需要执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-rosdep</span><br></pre></td></tr></table></figure><p> 初始化rosdep</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225608.png"></p><p>但是，在 rosdep 初始化时，多半会抛出异常。</p><p><strong>问题:</strong></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225615.png"></p><p><strong>原因:</strong></p><p>境外资源被屏蔽。</p><p><strong>解决:</strong></p><p>百度或google搜索，解决方式有多种(<a href="https://github.com/ros/rosdistro/issues/9721)%EF%BC%8C%E5%8F%AF%E6%83%9C%E5%9C%A8">https://github.com/ros/rosdistro/issues/9721)，可惜在</a> ubuntu20.04 下，集体失效。</p><p>新思路:<em>将相关资源备份到 gitee,修改 rosdep 源码,重新定位资源。</em></p><p><strong>实现:</strong></p><p>1.先打开资源备份路径:<a href="https://gitee.com/zhao-xuzuo/rosdistro%EF%BC%8C%E6%89%93%E5%BC%80">https://gitee.com/zhao-xuzuo/rosdistro，打开</a> rosdistro/<strong>rosdep</strong>/<strong>sources.list.d</strong>/<strong>20-default.list</strong>文件留作备用(主要是复用URL的部分内容:gitee.com/zhao-xuzuo/rosdistro/raw/master)。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225620.png"></p><p>2.进入”/usr/lib/python3/dist-packages/“ 查找rosdep中和<code>raw.githubusercontent.com</code>相关的内容，调用命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f | xargs grep &quot;raw.githubusercontent&quot;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225625.png"></p><p>3.修改相关文件，主要有: ./rosdistro/<strong>init</strong>.py、./rosdep2/gbpdistro_support.py、./rosdep2/sources_list.py 、./rosdep2/rep3.py。可以使用<code>sudo gedit</code>命令修改文件:</p><p>文件中涉及的 URL 内容，如果是:<code>raw.githubusercontent.com/ros/rosdistro/master</code>都替换成步骤1中准备的<code>gitee.com/zhao-xuzuo/rosdistro/raw/master</code>即可。</p><p>修改完毕，再重新执行命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><p>就可以正常实现 rosdep 的初始化与更新了。</p><h4 id="1-9、测试-ROS——运行小海龟"><a href="#1-9、测试-ROS——运行小海龟" class="headerlink" title="1.9、测试 ROS——运行小海龟"></a><strong>1.9、测试 ROS——运行小海龟</strong></h4><ol><li><p>首先启动三个终端(ctrl + alt + T)</p></li><li><p>第一个终端运行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure></li><li><p>第二个终端运行命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure><p>此时会弹出图形化界面</p></li><li><p>第三个终端运行命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p>在3中可以通过上下左右控制2中乌龟的运动</p></li></ol><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225632.png"></p><p><strong>注：</strong></p><p>有时候下载任务不小心被 CTRL+Z暂停了</p><p>使用： jobs 命令查看已有进程 使用fg %x恢复执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fg %x</span><br></pre></td></tr></table></figure><p> 参考文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_44830040/article/details/106049992</span><br><span class="line">https://blog.csdn.net/weixin_43159148/article/details/83375218</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、MATLAB程序流程控制语句</title>
      <link href="/2021/11/09/5%E3%80%81matlab/%E5%9B%9B%E3%80%81MATLAB%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2021/11/09/5%E3%80%81matlab/%E5%9B%9B%E3%80%81MATLAB%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="四、MATLAB程序流程控制语句"><a href="#四、MATLAB程序流程控制语句" class="headerlink" title="四、MATLAB程序流程控制语句"></a>四、MATLAB程序流程控制语句</h2><blockquote><p><strong>声明：</strong><br>笔记是学习慕课网《科学计算与MATLAB语言》课程和刘卫国主编的《MATLAB程序设计与应用（第3版）》后的个人总结，方便自己以后巩固和复习！</p></blockquote><h3 id="4-1-M文件"><a href="#4-1-M文件" class="headerlink" title="4.1  M文件"></a>4.1  M文件</h3><h4 id="4-1-1-M文件的建立与打开"><a href="#4-1-1-M文件的建立与打开" class="headerlink" title="4.1.1  M文件的建立与打开"></a>4.1.1  M文件的建立与打开</h4><p>M文件是一个文本文件，它可以用任何编辑程序来建立和编辑，而一般常用且最为方便的是使用MATLAB提供的文本编辑器。</p><h5 id="1．建立新的M文件"><a href="#1．建立新的M文件" class="headerlink" title="1．建立新的M文件"></a>1．建立新的M文件</h5><p>为建立新的M文件，启动MATLAB编辑器有3种方法。<br>① 在MATLAB主窗口选择“主页”选项卡，在“文件”命令组中单击“新建脚本”命令按钮。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109182936.png"></p><p>② 在MATLAB命令行窗口输入命令：<br>edit 文件名<br>启动MATLAB编辑器后，输入M文件的内容并存盘。<br>③ 在命令历史窗口选中一些命令（按住Ctrl可同时选择多条命令），然后从右键快捷菜单中选择“创建脚本”命令，将会启动MATLAB编辑器，并在编辑区中加入所选中的命令。</p><h5 id="2．打开已有的M文件"><a href="#2．打开已有的M文件" class="headerlink" title="2．打开已有的M文件"></a>2．打开已有的M文件</h5><p>打开已有的M文件，也有3种方法：<br>    (1) 菜单操作。在MATLAB主窗口选择“主页”选项卡，在“文件”命令组中单击“打开”命令按钮，再从弹出的下拉菜单中选择“打开”命令，从“打开”对话框中选择所需打开的M文件。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109182952.png">    (2) 命令操作。在MATLAB命令窗口输入命令：edit 文件名，则打开指定的M文件。<br>    (3) 命令按钮操作。单击MATLAB主窗口工具栏上的Open File命令按钮，再从弹出的对话框中选择所需打开的M文件。</p><h4 id="4-1-2-M文件的分类"><a href="#4-1-2-M文件的分类" class="headerlink" title="4.1.2  M文件的分类"></a>4.1.2  M文件的分类</h4><p>   用MATLAB语言编写的程序，称为M文件。M文件可以根据调用方式的不同分为两类：脚本文件(Script File)和函数文件(Function File)。</p><blockquote><p><strong>脚本文件和函数文件的主要区别如下：</strong><br>① 脚本文件没有输入参数，也不返回输出参数，而函数文件可以带输入参数，也可返回输出参数。<br>② 脚本文件对MATLAB工作空间中的变量进行操作，文件中所有命令的执行结果也完全返回到工作空间中，而函数文件中定义的变量为局部变量，当函数文件执行完毕时，这些变量被清除。<br>③ 脚本文件可以直接运行，在MATLAB命令行窗口输入脚本文件的名字，就会顺序执行脚本文件中的命令，而函数文件不能直接运行，而要以函数调用的方式来调用它。</p></blockquote><p>建立一个命令文件将变量a,b的值互换，然后运行该命令文件。<br>    程序1：<br>首先建立命令文件并以文件名exch.m存盘：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clear;</span><br><span class="line">a=<span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line">b=[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>;<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>];</span><br><span class="line">c=a;a=b;b=c;</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><p>然后在MATLAB的命令窗口中输入exch，将会执行该命令文件。 </p><h3 id="4-2-程序控制结构"><a href="#4-2-程序控制结构" class="headerlink" title="4.2  程序控制结构"></a>4.2  程序控制结构</h3><h4 id="4-2-1-顺序结构"><a href="#4-2-1-顺序结构" class="headerlink" title="4.2.1  顺序结构"></a>4.2.1  顺序结构</h4><h5 id="1．数据的输入"><a href="#1．数据的输入" class="headerlink" title="1．数据的输入"></a>1．数据的输入</h5><p>从键盘输入数据，则可以使用input函数来进行，该函数的调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A=input(提示信息，选项)；</span><br></pre></td></tr></table></figure><p>其中提示信息为一个字符串，用于提示用户输入什么样的数据。<br>    如果在input函数调用时采用’s’选项，则允许用户输入一个字符串。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xm=input(<span class="string">&#x27;What&#x27;&#x27;s your name?&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="2．数据的输出"><a href="#2．数据的输出" class="headerlink" title="2．数据的输出"></a>2．数据的输出</h5><p>​    MATLAB提供的命令窗口输出函数主要有disp函数，其调用格式为<br>​    disp(输出项)<br>其中输出项既可以为字符串，也可以为矩阵。</p><p>例4-2  求一元二次方程ax2 +bx+c=0的根。<br>程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=input(<span class="string">&#x27;a=&#x27;</span>);</span><br><span class="line">b=input(<span class="string">&#x27;b=&#x27;</span>);</span><br><span class="line">c=input(<span class="string">&#x27;c=&#x27;</span>);</span><br><span class="line">d=b*b<span class="number">-4</span>*a*c;</span><br><span class="line">x=[(-b+<span class="built_in">sqrt</span>(d))/(<span class="number">2</span>*a),(-b-<span class="built_in">sqrt</span>(d))/(<span class="number">2</span>*a)];</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;x1=&#x27;</span>,num2str(x(<span class="number">1</span>)),<span class="string">&#x27;,x2=&#x27;</span>,num2str(x(<span class="number">2</span>))]);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109183009.png"></p><h5 id="3．程序的暂停"><a href="#3．程序的暂停" class="headerlink" title="3．程序的暂停"></a>3．程序的暂停</h5><p>​    暂停程序的执行可以使用pause函数，其调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pause(延迟秒数)</span><br></pre></td></tr></table></figure><p>​    如果省略延迟时间，直接使用pause，则将暂停程序，直到用户按任一键后程序继续执行。<br>​    若要强行中止程序的运行可使用Ctrl+C命令。</p><h4 id="4-2-2-选择结构"><a href="#4-2-2-选择结构" class="headerlink" title="4.2.2  选择结构"></a>4.2.2  选择结构</h4><h5 id="1．if语句"><a href="#1．if语句" class="headerlink" title="1．if语句"></a>1．if语句</h5><p>​    在MATLAB中，if语句有3种格式。<br>​    (1) 单分支if语句：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  条件</span><br><span class="line">语句组</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当条件成立时，则执行语句组，执行完之后继续执行if语句的后继语句，若条件不成立，则直接执行if语句的后继语句。</p><p>  (2) 双分支if语句：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  条件</span><br><span class="line">    语句组<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     语句组<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>​    当条件成立时，执行语句组1，否则执行语句组2，语句组1或语句组2执行后，再执行if语句的后继语句。</p><p>计算分段函数。</p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109183017.png" style="zoom:33%;" /><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=input(<span class="string">&#x27;请输入x的值:&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> x==<span class="number">10</span></span><br><span class="line">     y=<span class="built_in">cos</span>(x+<span class="number">1</span>)+<span class="built_in">sqrt</span>(x*x+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     y=x*<span class="built_in">sqrt</span>(x+<span class="built_in">sqrt</span>(x));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">y</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109183023.png"></p><h5 id="3-多分支if语句："><a href="#3-多分支if语句：" class="headerlink" title="(3) 多分支if语句："></a>(3) 多分支if语句：</h5><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109183033.png"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  条件<span class="number">1</span></span><br><span class="line">    语句组<span class="number">1</span></span><br><span class="line"><span class="keyword">elseif</span>  条件<span class="number">2</span></span><br><span class="line">    语句组<span class="number">2</span></span><br><span class="line">   ……</span><br><span class="line"><span class="keyword">elseif</span>  条件m</span><br><span class="line">     语句组m</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     语句组n</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>例：输入一个字符，若为大写字母，则输出其对应的小写字母；若为小写字母，则输出其对应的大写字母；若为数字字符则输出其对应的数值，若为其他字符则原样输出。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c=input(<span class="string">&#x27;请输入一个字符&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> c&gt;=<span class="string">&#x27;A&#x27;</span> &amp; c&lt;=<span class="string">&#x27;Z&#x27;</span></span><br><span class="line">   <span class="built_in">disp</span>(setstr(<span class="built_in">abs</span>(c)+<span class="built_in">abs</span>(<span class="string">&#x27;a&#x27;</span>)-<span class="built_in">abs</span>(<span class="string">&#x27;A&#x27;</span>)));</span><br><span class="line"><span class="keyword">elseif</span> c&gt;=<span class="string">&#x27;a&#x27;</span>&amp; c&lt;=<span class="string">&#x27;z&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(setstr(<span class="built_in">abs</span>(c)- <span class="built_in">abs</span>(<span class="string">&#x27;a&#x27;</span>)+<span class="built_in">abs</span>(<span class="string">&#x27;A&#x27;</span>)));</span><br><span class="line"><span class="keyword">elseif</span> c&gt;=<span class="string">&#x27;0&#x27;</span>&amp; c&lt;=<span class="string">&#x27;9&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="built_in">abs</span>(c)-<span class="built_in">abs</span>(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(c);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="2．switch语句"><a href="#2．switch语句" class="headerlink" title="2．switch语句"></a>2．switch语句</h5><p>​    switch语句根据表达式的取值不同，分别执行不同的语句，其语句格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>  表达式</span><br><span class="line">   <span class="keyword">case</span>  表达式<span class="number">1</span></span><br><span class="line">      语句组<span class="number">1</span></span><br><span class="line">   <span class="keyword">case</span>  表达式<span class="number">2</span></span><br><span class="line">      语句组<span class="number">2</span></span><br><span class="line">      ……</span><br><span class="line">   <span class="keyword">case</span>  表达式m</span><br><span class="line">      语句组m</span><br><span class="line">   <span class="keyword">otherwise</span></span><br><span class="line">      语句组n</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109183040.png" style="zoom:80%;" /><blockquote><p>当表达式的值等于表达式1的值时，执行语句组1，当表达式的值等于表达式2的值时，执行语句组2，…，当表达式的值等于表达式m的值时，执行语句组m，当表达式的值不等于case所列的表达式的值时，执行语句组n。当任意一个分支的语句执行完后，直接执行switch语句的下一句</p></blockquote><p>例：某商场对顾客所购买的商品实行打折销售，标准如下(商品价格用price来表示)：<br>    price&lt;200           没有折扣<br>    200≤price&lt;500      3%折扣<br>    500≤price&lt;1000     5%折扣<br>    1000≤price&lt;2500    8%折扣<br>    2500≤price&lt;5000    10%折扣<br>    5000≤price         14%折扣<br>输入所售商品的价格，求其实际销售价格。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">price=input(<span class="string">&#x27;请输入商品价格&#x27;</span>);</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">fix</span>(price/<span class="number">100</span>) </span><br><span class="line">   <span class="keyword">case</span> &#123;<span class="number">0</span>,<span class="number">1</span>&#125;             <span class="comment">%价格小于200</span></span><br><span class="line">      rate=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">case</span> &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;            <span class="comment">%价格大于等于200但小于500</span></span><br><span class="line">      rate=<span class="number">3</span>/<span class="number">100</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">5</span>:<span class="number">9</span>)       <span class="comment">%价格大于等于500但小于1000</span></span><br><span class="line">      rate=<span class="number">5</span>/<span class="number">100</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">10</span>:<span class="number">24</span>)     <span class="comment">%价格大于等于1000但小于2500</span></span><br><span class="line">      rate=<span class="number">8</span>/<span class="number">100</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">25</span>:<span class="number">49</span>)     <span class="comment">%价格大于等于2500但小于5000</span></span><br><span class="line">      rate=<span class="number">10</span>/<span class="number">100</span>;</span><br><span class="line">   <span class="keyword">otherwise</span>               <span class="comment">%价格大于等于5000</span></span><br><span class="line">      rate=<span class="number">14</span>/<span class="number">100</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">price=price*(<span class="number">1</span>-rate)              <span class="comment">%输出商品实际销售价格</span></span><br></pre></td></tr></table></figure><h5 id="3．try语句"><a href="#3．try语句" class="headerlink" title="3．try语句"></a>3．try语句</h5><p>语句格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">   语句组<span class="number">1</span></span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">   语句组<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>try语句先试探性执行语句组1，如果语句组1在执行过程中出现错误，则将错误信息赋给保留的lasterr变量，并转去执行语句组2。</p><h4 id="4-2-3-循环结构"><a href="#4-2-3-循环结构" class="headerlink" title="4.2.3  循环结构"></a>4.2.3  循环结构</h4><h5 id="1．for语句"><a href="#1．for语句" class="headerlink" title="1．for语句"></a>1．for语句</h5><p>for语句的格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量=表达式<span class="number">1</span>:表达式<span class="number">2</span>:表达式<span class="number">3</span></span><br><span class="line">        循环体语句</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中，“表达式1:表达式2:表达式3”是一个冒号表达式，将产生一个行向量，3个表达式分别代表初值、步长和终值。步长为1时，表达式2可以省略。</p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109183048.png" style="zoom:80%;" /><p>例：  一个三位整数各位数字的立方和等于该数本身则称该数为水仙花数。输出全部水仙花数。<br>程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m=<span class="number">100</span>:<span class="number">999</span></span><br><span class="line">m1=<span class="built_in">fix</span>(m/<span class="number">100</span>);           <span class="comment">%求m的百位数字</span></span><br><span class="line">m2=<span class="built_in">rem</span>(<span class="built_in">fix</span>(m/<span class="number">10</span>),<span class="number">10</span>);   <span class="comment">%求m的十位数字</span></span><br><span class="line">m3=<span class="built_in">rem</span>(m,<span class="number">10</span>);             <span class="comment">%求m的个位数字</span></span><br><span class="line"><span class="keyword">if</span> m==m1*m1*m1+m2*m2*m2+m3*m3*m3</span><br><span class="line"><span class="built_in">disp</span>(m)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>or语句更一般的格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量=矩阵表达式</span><br><span class="line">       循环体语句</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>​    执行过程是依次将矩阵的各列元素赋给循环变量，然后执行循环体语句，直至各列元素处理完毕。</p><h5 id="2．while语句"><a href="#2．while语句" class="headerlink" title="2．while语句"></a>2．while语句</h5><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>语句的一般格式为：</span><br><span class="line"><span class="keyword">while</span> (条件)</span><br><span class="line">     循环体语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>​    其执行过程为：若条件成立，则执行循环体语句，执行后再判断条件是否成立，如果不成立则跳出循环。</p><h5 id="3．break语句和continue语句"><a href="#3．break语句和continue语句" class="headerlink" title="3．break语句和continue语句"></a>3．break语句和continue语句</h5><p>​    与循环结构相关的语句还有break语句和continue语句。它们一般与if语句配合使用。<br>​    break语句用于终止循环的执行。当在循环体内执行到该语句时，程序将跳出循环，继续执行循环语句的下一语句。<br>​    continue语句控制跳过循环体中的某些语句。当在循环体内执行到该语句时，程序将跳过循环体中所有剩下的语句，继续下一次循环。</p><h5 id="4．循环的嵌套"><a href="#4．循环的嵌套" class="headerlink" title="4．循环的嵌套"></a>4．循环的嵌套</h5><p>​    如果一个循环结构的循环体又包括一个循环结构，就称为循环的嵌套，或称为多重循环结构。<br>例：  若一个数等于它的各个真因子之和，则称该数为完数，如6=1+2+3，所以6是完数。求[1,500]之间的全部完数。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m=<span class="number">1</span>:<span class="number">500</span></span><br><span class="line">s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:m/<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">rem</span>(m,k)==<span class="number">0</span></span><br><span class="line">s=s+k;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> m==s</span><br><span class="line">    <span class="built_in">disp</span>(m);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="4-3-函数文件"><a href="#4-3-函数文件" class="headerlink" title="4.3 函数文件"></a>4.3 函数文件</h3><h5 id="4-3-1-函数文件的基本结构"><a href="#4-3-1-函数文件的基本结构" class="headerlink" title="4.3.1  函数文件的基本结构"></a>4.3.1  函数文件的基本结构</h5><p>​    函数文件由function语句引导，其基本结构为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 输出形参表=函数名<span class="params">(输入形参表)</span></span></span><br><span class="line">    注释说明部分</span><br><span class="line">    函数体语句</span><br></pre></td></tr></table></figure><p>其中以function开头的一行为引导行，表示该M文件是一个函数文件。函数名的命名规则与变量名相同。输入形参为函数的输入参数，输出形参为函数的输出参数。当输出形参多于一个时，则应该用方括号括起来。</p><h5 id="4-3-2-函数调用"><a href="#4-3-2-函数调用" class="headerlink" title="4.3.2  函数调用"></a>4.3.2  函数调用</h5><p>1.函数调用的一般格式是：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[输出实参表]=函数名(输入实参表)</span><br></pre></td></tr></table></figure><p>​    要注意的是，函数调用时各实参出现的顺序、个数，应与函数定义时形参的顺序、个数一致，否则会出错。函数调用时，先将实参传递给相应的形参，从而实现参数传递，然后再执行函数的功能。</p><p>2．函数的递归调用<br>在MATLAB中，函数可以嵌套调用，即一个函数可以调用别的函数，甚至调用它自身。一个函数调用它自身称为函数的递归调用。</p><p>例： 利用函数的递归调用，求n！。<br>    n!本身就是以递归的形式定义的：<br>   显然，求n!需要求(n-1)!，这时可采用递归调用。递归调用函数文件</p><p>factor.m如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>=<span class="title">factor</span><span class="params">(n)</span></span></span><br><span class="line"><span class="keyword">if</span> n&lt;=<span class="number">1</span></span><br><span class="line">   f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   f=<span class="built_in">factor</span>(n<span class="number">-1</span>)*n;    <span class="comment">%递归调用求(n-1)!</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="4-3-3-函数参数的可调性"><a href="#4-3-3-函数参数的可调性" class="headerlink" title="4.3.3  函数参数的可调性"></a>4.3.3  函数参数的可调性</h5><p>​    在调用函数时，MATLAB用两个<strong>永久变量nargin和nargout</strong>分别记录调用该函数时的输入实参和输出实参的个数。只要在函数文件中包含这两个变量，就可以准确地知道该函数文件被调用时的输入输出参数个数，从而决定函数如何进行处理。</p><blockquote><p>注意：</p><p>for k = [1,2,3,4]与 for k = [1;2;3;4]执行的次数不一样，第一个执行4次，第二只执行1次。</p></blockquote><h5 id="4-3-4-全局变量与局部变量"><a href="#4-3-4-全局变量与局部变量" class="headerlink" title="4.3.4  全局变量与局部变量"></a>4.3.4  全局变量与局部变量</h5><p>函数文件中的变量是局部的，即在一个函数文件中定义的变量不能被另一个函数文件引用。如果在若干函数中都把某一变量定义为全局变量，那么这些函数将共用这个变量，作用域是整个工作空间，即全程有效。<br>全局变量用global命令定义，格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> 变量名</span><br></pre></td></tr></table></figure><h3 id="4-4特殊形式的函数"><a href="#4-4特殊形式的函数" class="headerlink" title="4.4特殊形式的函数"></a>4.4特殊形式的函数</h3><h4 id="4-3-1、子函数"><a href="#4-3-1、子函数" class="headerlink" title="4.3.1、子函数"></a>4.3.1、子函数</h4><p>在MATLAB中，可以在一个M文件中同时定义多个函数，其中M文件中出现的第一个函数称为主函数（primary function），其他函数称为子函数（subfunction），但需要注意的是子函数只能由同一M文件中的函数调用。在保存M文件时，M文件名一般和主函数名相同，外部程序只能对主函数进行调用。</p><h4 id="2-内联函数"><a href="#2-内联函数" class="headerlink" title="2. 内联函数"></a>2. 内联函数</h4><p>以字符串形式存在的函数表达式可以通过inline函数转化成内联函数。例如a=’(x+y)^2’，可以通过f=inline(a)生成内联函数f(x,y)=(x+y)^2。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a=<span class="string">&#x27;(x+y)^2&#x27;</span>;</span><br><span class="line">f=inline(a)</span><br><span class="line">f =</span><br><span class="line">     内联函数:</span><br><span class="line">     f(x,y) = (x+y)^<span class="number">2</span></span><br><span class="line">f(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">49</span></span><br></pre></td></tr></table></figure><h4 id="3-匿名函数"><a href="#3-匿名函数" class="headerlink" title="3. 匿名函数"></a>3. 匿名函数</h4><p>匿名函数的基本格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匿名函数名=@(输入参数) 匿名函数表达式</span><br></pre></td></tr></table></figure><p>其中，匿名函数的输入参数可以是一个，也可以是多个，有多个参数时，参数间用逗号分隔。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; f=@(x,y) x^<span class="number">2</span>+y^<span class="number">2</span>;</span><br><span class="line">f(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">25</span></span><br></pre></td></tr></table></figure><h3 id="4-5程序调试与优化"><a href="#4-5程序调试与优化" class="headerlink" title="4.5程序调试与优化"></a>4.5程序调试与优化</h3><h4 id="4-5-1-程序调试方法"><a href="#4-5-1-程序调试方法" class="headerlink" title="4.5.1  程序调试方法"></a>4.5.1  程序调试方法</h4><p>一般来说，应用程序的错误有两类，一类是语法错误，另一类是运行时的错误。语法错误包括词法或文法的错误，例如函数名的拼写错、表达式书写错等。</p><h5 id="程序优化"><a href="#程序优化" class="headerlink" title="程序优化"></a>程序优化</h5><p>（1）采用向量化运算<br>在实际MATLAB程序设计中，为了提高程序的执行速度，常用向量或矩阵运算来代替循环操作。<br>（2）预分配内存空间<br>通过在循环之前预分配向量或数组的内存空间可以提高for循环的处理速度。<br>（3）减小运算强度<br>在实现有关运算时，尽量采用运算量更小的运算，从而提高运算速度。一般来说，乘法比乘方运算快，加法比乘法运算快。</p>]]></content>
      
      
      <categories>
          
          <category> MATLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、MATLAB数据及其运算</title>
      <link href="/2021/11/09/5%E3%80%81matlab/%E4%BA%8C%E3%80%81MATLAB%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/"/>
      <url>/2021/11/09/5%E3%80%81matlab/%E4%BA%8C%E3%80%81MATLAB%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="二、MATLAB数据及其运算"><a href="#二、MATLAB数据及其运算" class="headerlink" title="二、MATLAB数据及其运算"></a>二、MATLAB数据及其运算</h2><blockquote><p><strong>声明：</strong><br>笔记是学习慕课网《科学计算与MATLAB语言》课程和刘卫国主编的《MATLAB程序设计与应用（第3版）》后的个人总结，方便自己以后巩固和复习！</p></blockquote><h3 id="2-1-Matlab数值数据"><a href="#2-1-Matlab数值数据" class="headerlink" title="2.1  Matlab数值数据"></a>2.1  Matlab数值数据</h3><h4 id="2-1-1-数值数据类型的分类"><a href="#2-1-1-数值数据类型的分类" class="headerlink" title="2.1.1  数值数据类型的分类"></a>2.1.1  数值数据类型的分类</h4><h5 id="1．整型"><a href="#1．整型" class="headerlink" title="1．整型"></a>1．整型</h5><p>整型数据是不带小数的数，分为有带符号整数和无符号整数。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/0.png"></p><h5 id="2．浮点型"><a href="#2．浮点型" class="headerlink" title="2．浮点型"></a>2．浮点型</h5><p>浮点型数据有单精度（single）和双精度（double）之分，单精度型实数在内存中占用4个字节，双精度型实数在内存中占用8个字节，双精度型的数据精度更高。</p><p>在Matlab中，数据默认为双精度型。</p><blockquote><p>single函数 可以将其他类型的数据转换为单精度型；利用class可以得到参数的数据类型。</p><p>double函数 可以将其他类型的数据转换为双精度型。</p></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/1.png"></p><h5 id="3．复型"><a href="#3．复型" class="headerlink" title="3．复型"></a>3．复型</h5><p>复型数据包括实部和虚部两个部分，实部和虚部默认为双精度型。</p><p>在MATLAB中，虚数单位用i或j表示。</p><blockquote><p>例如，6+5i与6+5j表示的是同一个复数，也可以写成6+5<em>i或6+5</em>j，这里将i或j看作一个运算量参与表达式的运算。</p></blockquote><h4 id="2-1-2-数据的输出格式"><a href="#2-1-2-数据的输出格式" class="headerlink" title="2.1.2  数据的输出格式"></a>2.1.2  数据的输出格式</h4><p>MATLAB用十进制数表示一个常数，具体可采用日常记数法和科学记数法两种表示方法。</p><p>format命令的格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format 格式符  </span><br></pre></td></tr></table></figure><p>其中，格式符决定数据的输出格式，各种格式符及其含义如表所示。</p><table><thead><tr><th><strong>格式符</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>short</strong></td><td><strong>输出小数点后4位，最多不超过7位有效数字。对于大于1000的实数，用5位有效数字的科学记数形式输出</strong></td></tr><tr><td><strong>long</strong></td><td><strong>15位有效数字形式输出</strong></td></tr><tr><td><strong>short e</strong></td><td><strong>5位有效数字的科学记数形式输出</strong></td></tr><tr><td><strong>long e</strong></td><td><strong>15位有效数字的科学记数形式输出</strong></td></tr><tr><td><strong>short g</strong></td><td><strong>从short和short e中自动选择最佳输出方式</strong></td></tr><tr><td><strong>long g</strong></td><td><strong>从long和long e中自动选择最佳输出方式</strong></td></tr><tr><td><strong>rat</strong></td><td><strong>近似有理数表示</strong></td></tr><tr><td><strong>hex</strong></td><td><strong>十六进制表示</strong></td></tr><tr><td><strong>+</strong></td><td><strong>正数、负数、零分别用+、-、空格表示</strong></td></tr><tr><td><strong>bank</strong></td><td><strong>银行格式，用元、角、分表示</strong></td></tr><tr><td><strong>compact</strong></td><td><strong>输出变量之间没有空行</strong></td></tr><tr><td><strong>loose</strong></td><td><strong>输出变量之间有空行</strong></td></tr></tbody></table><blockquote><p><strong>注意：format命令只影响数据输出格式，而不影响数据的计算和存储。</strong></p></blockquote><h3 id="2-2-MATLAB矩阵的表示"><a href="#2-2-MATLAB矩阵的表示" class="headerlink" title="2.2 MATLAB矩阵的表示"></a>2.2 MATLAB矩阵的表示</h3><h4 id="2-2-1-矩阵的建立"><a href="#2-2-1-矩阵的建立" class="headerlink" title="2.2.1  矩阵的建立"></a>2.2.1  矩阵的建立</h4><p>1．直接输入法:</p><p>最简单的建立矩阵的方法是从键盘直接输入矩阵的元素。</p><p>具体方法如下：将矩阵的元素用方括号括起来，按矩阵行的顺序输入各元素，同一行的各元素之间用空格或逗号分隔，不同行的元素之间用分号分隔。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/2.png"></p><h4 id="2-2-2-冒号表达式"><a href="#2-2-2-冒号表达式" class="headerlink" title="2.2.2   冒号表达式"></a>2.2.2   冒号表达式</h4><p>冒号表达式可以产生一个行向量，</p><p>一般格式是： </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e1:e2:e3</span><br></pre></td></tr></table></figure><p>其中e1为初始值，e2为步长，e3为终止值。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/3.png"></p><p>初始值:4 步长:3 终止值:12。</p><p>在MATLAB中，还可以用linspace函数产生行向量。</p><p>其调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">linspace</span>(a,b,n)</span><br></pre></td></tr></table></figure><p>其中a和b是生成向量的第一个和最后一个元素，n是元素总数。</p><blockquote><p>显然，linspace(a,b,n)与a:(b-a)/(n-1):b等价</p></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/4.png"></p><h4 id="2-2-3-矩阵的引用"><a href="#2-2-3-矩阵的引用" class="headerlink" title="2.2.3  矩阵的引用"></a>2.2.3  矩阵的引用</h4><h5 id="1．矩阵元素的引用方式"><a href="#1．矩阵元素的引用方式" class="headerlink" title="1．矩阵元素的引用方式"></a>1．矩阵元素的引用方式</h5><p>MATLAB通过下标引用矩阵的元素</p><blockquote><p>例如：A(3,2)=200</p></blockquote><p>也可以采用矩阵元素的序号来引用矩阵元素。矩阵元素的序号就是相应元素在内存中的排列顺序。</p><p>在MATLAB中，矩阵元素按列存储，先第一列，再第二列，依次类推。<br> 显然，序号(Index)与下标(Subscript )是一一对应的，以m×n矩阵A为例，矩阵元素A(i,j)的序号为(j-1)*m+i。其相互转换关系也可利用sub2ind和ind2sub函数求得。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/5.png"></p><h5 id="2-利用冒号表达式获得子矩阵"><a href="#2-利用冒号表达式获得子矩阵" class="headerlink" title="2.利用冒号表达式获得子矩阵"></a>2.利用冒号表达式获得子矩阵</h5><p>① A(:,j)表示取A矩阵的第j列全部元素；A(i,:)表示A矩阵第i行的全部元素；A(i,j)表示取A矩阵第i行、第j列的元素。</p><p>② A(i:i+m,:)表示取A矩阵第i～i+m行的全部元素；A(:,k:k+m)表示取A矩阵第k～k+m列的全部元素，A(i:i+m,k:k+m)表示取A矩阵第i～i+m行内，并在第k～k+m列中的所有元素。 ③A(:)将矩阵A每一列元素堆叠起来，成为一个列向量，而这也是MATLAB变量的内部储存方式。</p><h5 id="3-利用空矩阵删除矩阵的元素"><a href="#3-利用空矩阵删除矩阵的元素" class="headerlink" title="3.利用空矩阵删除矩阵的元素"></a>3.利用空矩阵删除矩阵的元素</h5><p>在MATLAB中，定义[]为空矩阵。给变量X赋空矩阵的语句为</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=[]</span><br></pre></td></tr></table></figure><p>注意，X=[]与clear X不同，clear是将X从工作空间中删除，而空矩阵则存在于工作空间中，只是维数为0。</p><h5 id="4．改变矩阵的形状"><a href="#4．改变矩阵的形状" class="headerlink" title="4．改变矩阵的形状"></a>4．改变矩阵的形状</h5><p>reshape(A,m,n)函数在矩阵总元素保持不变的前提下，将矩阵A重新排成m×n的二维矩阵。</p><p>例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="number">23</span>,<span class="number">45</span>,<span class="number">65</span>,<span class="number">34</span>,<span class="number">65</span>,<span class="number">34</span>,<span class="number">98</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">65</span>,<span class="number">43</span>,<span class="number">76</span></span><br><span class="line">y=<span class="built_in">reshape</span>(x,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">y =</span><br><span class="line">    <span class="number">23</span>    <span class="number">34</span>    <span class="number">98</span>    <span class="number">65</span></span><br><span class="line">    <span class="number">45</span>    <span class="number">65</span>    <span class="number">45</span>    <span class="number">43</span></span><br><span class="line">    <span class="number">65</span>    <span class="number">34</span>    <span class="number">78</span>    <span class="number">76</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>reshape函数只是改变原矩阵的行数和列数，即改变其逻辑结构，但并不改变原矩阵元素个数及其存储顺序。<br>A(:)将矩阵A的每一列元素堆叠起来，成为一个列向量，从而改变了矩阵的形状。</p></blockquote><h3 id="2-3-变量及其操作"><a href="#2-3-变量及其操作" class="headerlink" title="2.3  变量及其操作"></a>2.3  变量及其操作</h3><h4 id="2-3-1-变量与赋值语句"><a href="#2-3-1-变量与赋值语句" class="headerlink" title="2.3.1  变量与赋值语句"></a>2.3.1  变量与赋值语句</h4><h5 id="1．变量命名"><a href="#1．变量命名" class="headerlink" title="1．变量命名"></a>1．变量命名</h5><p>在MATLAB 7.0中，<strong>变量名是以字母开头，后接字母、数字或下划线的字符序列，最多63个字符。</strong>在MATLAB中，变量名区分字母的大小写。</p><h5 id="2．赋值语句"><a href="#2．赋值语句" class="headerlink" title="2．赋值语句"></a>2．赋值语句</h5><blockquote><p>(1) 变量=表达式 </p><p>(2) 表达式</p></blockquote><p>其中表达式是用运算符将有关运算量连接起来的式子，其结果是一个矩阵。</p><p>例如：计算表达式的值，并显示计算结果</p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/6.png" style="zoom:33%;" /><p>在MATLAB命令窗口输入命令：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; x=<span class="built_in">sqrt</span>(<span class="number">7</span>)<span class="number">-2</span><span class="built_in">i</span>;</span><br><span class="line">y=<span class="built_in">exp</span>(<span class="built_in">pi</span>/<span class="number">2</span>);</span><br><span class="line">z=(<span class="number">5</span>+<span class="built_in">cos</span>(<span class="number">47</span>*<span class="built_in">pi</span>/<span class="number">180</span>))/(<span class="number">1</span>+<span class="built_in">abs</span>(x-y))</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/7.png"></p><h4 id="2-3-2预定义变量"><a href="#2-3-2预定义变量" class="headerlink" title="2.3.2预定义变量"></a>2.3.2预定义变量</h4><p> 在MATLAB工作空间中，还驻留几个由系统本身定义的变量。例如，用pi表示圆周率π的近似值，用i，j表示虚数单位。</p><p><strong>预定义变量有特定的含义，在使用时，应尽量避免对这些变量重新赋值。</strong></p><h4 id="2-3-3-变量的管理"><a href="#2-3-3-变量的管理" class="headerlink" title="2.3.3  变量的管理"></a>2.3.3  变量的管理</h4><h5 id="1．内存变量的删除与修改"><a href="#1．内存变量的删除与修改" class="headerlink" title="1．内存变量的删除与修改"></a>1．内存变量的删除与修改</h5><p>MATLAB工作区窗口专门用于内存变量的管理。在工作区窗口中可以显示所有内存变量的属性。</p><p>who和whos这两个命令用于显示在MATLAB工作空间中已经驻留的变量名清单。</p><blockquote><p>who命令只显示出驻留变量的名称；</p><p>whos在给出变量名的同时，还给出它们的大小、所占字节数及数据类型等信息。 </p></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/8.png"></p><blockquote><p>clear命令用于删除MATLAB工作空间中的变量。</p></blockquote><p>2．内存变量文件利用MAT文件可以把当前MATLAB工作空间中的一些有用变量长久地保留下来，扩展名是.mat。MAT文件的生成和装入由save和load命令来完成。常用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save 文件名 [变量名表]  [-append] [-ascii]</span><br><span class="line">load 文件名  [变量名表]  [-ascii]</span><br></pre></td></tr></table></figure><p>其中，文件名可以带路径，但不需带扩展名.mat，命令隐含一定对.mat文件进行操作。变量名表中的变量个数不限，只要内存或文件中存在即可，变量名之间以空格分隔。当变量名表省略时，保存或装入全部变量。-ascii选项使文件以ASCII格式处理，省略该选项时文件将以二进制格式处理。save命令中的-append选项控制将变量追加到MAT文件中。</p><h3 id="2-4-MATLAB常用内部函数"><a href="#2-4-MATLAB常用内部函数" class="headerlink" title="2.4  MATLAB常用内部函数"></a>2.4  MATLAB常用内部函数</h3><h4 id="2-4-1-常用数学函数"><a href="#2-4-1-常用数学函数" class="headerlink" title="2.4.1  常用数学函数"></a>2.4.1  常用数学函数</h4><p>MATLAB提供了许多数学函数，函数的自变量规定为矩阵变量，运算法则是将函数逐项作用于矩阵的元素上，因而运算的结果是一个与自变量同维数的矩阵。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/9.png"></p><h4 id="2-4-2-矩阵的超越函数"><a href="#2-4-2-矩阵的超越函数" class="headerlink" title="2.4.2  矩阵的超越函数"></a>2.4.2  矩阵的超越函数</h4><p>MATLAB还提供了一些直接作用于矩阵的超越函数，这些函数名都在上述内部函数名之后缀以m，并规定输入参数A必须是方阵。</p><h5 id="1．矩阵平方根"><a href="#1．矩阵平方根" class="headerlink" title="1．矩阵平方根"></a>1．矩阵平方根</h5><p>sqrtm(A)计算矩阵A的平方根。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/10.png"></p><h5 id="2．矩阵对数"><a href="#2．矩阵对数" class="headerlink" title="2．矩阵对数"></a>2．矩阵对数</h5><p>logm(A)计算矩阵A的自然对数。此函数输入参数的条件与输出结果间的关系和函数sqrtm(A)完全一样。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/11.png"></p><h5 id="3．矩阵指数"><a href="#3．矩阵指数" class="headerlink" title="3．矩阵指数"></a>3．矩阵指数</h5><p>expm(A)的功能都是求矩阵指数eA。例如，对上面计算所得到的A的自然对数b.</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/12.png"></p><h5 id="4．普通矩阵函数"><a href="#4．普通矩阵函数" class="headerlink" title="4．普通矩阵函数"></a>4．普通矩阵函数</h5><p>funm(A,@fun)对方阵A计算由fun定义的函数的矩阵函数值。例如，当fun取exp时，funm(A,@exp)可以计算矩阵A的指数，与expm(A)的计算结果一样。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/13.png"></p><h3 id="2-5-MATLAB运算"><a href="#2-5-MATLAB运算" class="headerlink" title="2.5 MATLAB运算"></a>2.5 MATLAB运算</h3><h4 id="2-5-1-算术运算"><a href="#2-5-1-算术运算" class="headerlink" title="2.5.1  算术运算"></a>2.5.1  算术运算</h4><h5 id="1．基本算术运算"><a href="#1．基本算术运算" class="headerlink" title="1．基本算术运算"></a>1．基本算术运算</h5><p>MATLAB的基本算术运算有：＋(加)、－(减)、*(乘)、/(右除)、(左除)、^(乘方)。</p><p>注意，运算是在矩阵意义下进行的，单个数据的算术运算只是一种特例。</p><p> (1) 矩阵加减运算</p><blockquote><p>假定有两个矩阵A和B，则可以由A+B和A-B实现矩阵的加减运算。运算规则是：若A和B矩阵的维数相同，则可以执行矩阵的加减运算，A和B矩阵的相应元素相加减。如果A与B的维数不相同，则MATLAB将给出错误信息，提示用户两个矩阵的维数不匹配。</p></blockquote><p>(2) 矩阵乘法</p><blockquote><p>假定有两个矩阵A和B，若A为m×n矩阵，B为n×p矩阵，则C=A*B为m×p矩阵。</p></blockquote><p>(3) 矩阵除法</p><blockquote><p>在MATLAB中，有两种矩阵除法运算：\和/，分别表示左除和右除。</p><p>如果A矩阵是非奇异方阵，则A\B和B/A运算可以实现。</p><blockquote><p>A\B等效于A的逆左乘B矩阵，也就是inv(A) *B，</p><p>而B/A等效于A矩阵的逆右乘B矩阵，也就是B*inv(A)。</p></blockquote></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/14.png"></p><p>  (4) 矩阵的乘方</p><p>一个矩阵的乘方运算可以表示成A^x，要求A为方阵，x为标量。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A^<span class="number">2</span> = A*A</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/15.png"></p><h5 id="2．点运算"><a href="#2．点运算" class="headerlink" title="2．点运算"></a>2．点运算</h5><p>在MATLAB中，有一种特殊的运算，因为其运算符是在有关算术运算符前面加点，所以叫点运算。点运算符有.*、./、.\和.^。两矩阵进行点运算是指它们的对应元素进行相关运算，要求两矩阵的维参数相同。</p><h4 id="2-5-2-关系运算"><a href="#2-5-2-关系运算" class="headerlink" title="2.5.2  关系运算"></a>2.5.2  关系运算</h4><blockquote><p> MATLAB提供了6种关系运算符：</p><p> &lt;(小于)、&lt;=(小于或等于)、&gt;(大于)、&gt;=(大于或等于)、==(等于)、～=(不等于)。<br> 它们的含义不难理解，但要注意其书写方法与数学中的不等式符号不尽相同。</p></blockquote><p>关系运算符的运算法则为：</p><blockquote><p> (1) 当两个比较量是标量时，直接比较两数的大小。若关系成立，关系表达式结果为1，否则为0。</p><p> (2) 当参与比较的量是两个维数相同的矩阵时，比较是对两矩阵相同位置的元素按标量关系运算规则逐个进行，并给出元素比较结果。最终的关系运算的结果是一个维数与原矩阵相同的矩阵，它的元素由0或1组成。</p><p> (3) 当参与比较的一个是标量，而另一个是矩阵时，则把标量与矩阵的每一个元素按标量关系运算规则逐个比较，并给出元素比较结果。最终的关系运算的结果是一个维数与原矩阵相同的矩阵，它的元素由0或1组成。</p></blockquote><p>   例如：</p><p>建立5阶方阵A，判断A的元素是否能被3整除</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/16.png"></p><blockquote><p>其中，rem(A,3)是矩阵A的每个元素除以3的余数矩阵。此时，0被扩展为与A同维数的零矩阵，P是进行等于(==)比较的结果矩阵。</p></blockquote><h4 id="2-5-3-逻辑运算"><a href="#2-5-3-逻辑运算" class="headerlink" title="2.5.3  逻辑运算"></a>2.5.3  逻辑运算</h4><p> MATLAB提供了3种逻辑运算符：&amp;(与)、|(或)和～(非)。</p><p>逻辑运算的运算法则为：</p><blockquote><p>(1) 在逻辑运算中，确认非零元素为真，用1表示，零元素为假，用0表示。</p><p>(2) 设参与逻辑运算的是两个标量a和b，</p><p>那么，a&amp;b  a,b全为非零时，运算结果为1，否则为0。</p><p>a|b  a,b中只要有一个非零，运算结果为1。</p><p>～a  当a是零时，运算结果为1；当a非零时，运算结果为0。</p><p>(3) 若参与逻辑运算的是两个同维矩阵，那么运算将对矩阵相同位置上的元素按标量规则逐个进行。最终运算结果是一个与原矩阵同维的矩阵，其元素由1或0组成。</p><p>(4) 若参与逻辑运算的一个是标量，一个是矩阵，那么运算将在标量与矩阵中的每个元素之间按标量规则逐个进行。最终运算结果是一个与矩阵同维的矩阵，其元素由1或0组成。</p><p>(5) 逻辑非是单目运算符，也服从矩阵运算规则。</p><p>(6) 在算术、关系、逻辑运算中，算术运算优先级最高，逻辑运算优先级最低。</p></blockquote><h3 id="2-6-字符串"><a href="#2-6-字符串" class="headerlink" title="2.6  字符串"></a>2.6  字符串</h3><p>在MATLAB中，字符串是用单撇号括起来的字符序列。</p><p>MATLAB将字符串当作一个行向量，每个元素对应一个字符，其标识方法和数值向量相同。也可以建立多行字符串矩阵。</p><h5 id="2-6-1-字符串的表示"><a href="#2-6-1-字符串的表示" class="headerlink" title="2.6.1  字符串的表示"></a>2.6.1  字符串的表示</h5><p>在MATLAB中，字符串是用单引号括起来的字符序列。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xm=<span class="string">&#x27;Central South University&#x27;</span></span><br></pre></td></tr></table></figure><p>例：建立一个字符串向量，然后对该向量做如下处理：</p><blockquote><p>(1) 取第1～5个字符组成的子字符串。</p><p>(2) 将字符串倒过来重新排列。</p><p>(3) 将字符串中的小写字母变成相应的大写字母，其余字符不变。</p><p>(4) 统计字符串中小写字母的个数。</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch=<span class="string">&#x27;ABc123d4e56Fg9&#x27;</span>;</span><br><span class="line">subch=ch(<span class="number">1</span>:<span class="number">5</span>)           <span class="comment">%取子字符串</span></span><br><span class="line">revch=ch(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>)       <span class="comment">%将字符串倒排</span></span><br><span class="line">k=<span class="built_in">find</span>(ch&gt;=<span class="string">&#x27;a&#x27;</span>&amp;ch&lt;=<span class="string">&#x27;z&#x27;</span>);     <span class="comment">%找小写字母的位置</span></span><br><span class="line">ch(k)=ch(k)-(<span class="string">&#x27;a&#x27;</span>-<span class="string">&#x27;A&#x27;</span>);         <span class="comment">%将小写字母变成相应的大写字母</span></span><br><span class="line">char(ch)                </span><br><span class="line"><span class="built_in">length</span>(k)                  <span class="comment">%统计小写字母的个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意是英文下的单撇号；’ABc123d4e56Fg9’，不是‘ABc123d4e56Fg9’</p></blockquote><h5 id="2-6-2-字符串的操作"><a href="#2-6-2-字符串的操作" class="headerlink" title="2.6.2  字符串的操作"></a>2.6.2  字符串的操作</h5><p>1．字符串的执行<br>与字符串有关的一个重要函数是eval，它的作用是把字符串的内容作为对应的MATLAB命令来执行，其调用格式为：<br>eval(s)<br>其中s为字符串。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; t=<span class="built_in">pi</span>;</span><br><span class="line">m=<span class="string">&#x27;[t,sin(t),cos(t)]&#x27;</span>;</span><br><span class="line">y=eval(m)</span><br><span class="line">y =</span><br><span class="line">    <span class="number">3.1416</span>    <span class="number">0.0000</span>   <span class="number">-1.0000</span></span><br></pre></td></tr></table></figure><p>2．字符串与数值之间的转换<br>字符串是以ASCII码形式存储的，abs和double函数都可以用来获取字符串矩阵所对应的ASCII码数值矩阵。</p><p>3．字符串的连接<br>在MATLAB中，要将两个字符串连接在一起，有两种常见方法：一是用字符串向量，二是用strcat函数。</p><p>4．字符串的比较<br>字符串的比较有两种方法：<strong>利用关系运算符</strong>或<strong>字符串比较函数</strong>。<br>当两个字符串拥有相同的长度时，可以利用关系运算符对字符串进行比较，比较的规则是按ASCII值大小逐个字符进行比较，比较的结果是一个数值向量，其元素为对应字符比较的结果。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="string">&#x27;www0&#x27;</span>&gt;=<span class="string">&#x27;W123&#x27;</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure><p>字符串比较函数用于判断字符串是否相等，有4种比较方式，函数如下：</p><blockquote><p>① strcmp(s1,s2)：用来比较字符串s1和s2是否相等，如果相等，返回1，否则返回0。<br>② strncmp(s1,s2,n)：用来比较前n个字符是否相等，如果相等，返回1，否则返回0。<br>③ strcmpi(s1,s2)：在忽略字母大小写前提下，比较字符串s1和s2是否相等，如果相等，返回1，否则返回0。<br>④ strncmpi(s1,s2,n)：在忽略字符串大小写前提下，比较前n个字符是否相等，如果相等，返回1，否则返回0。</p></blockquote><h3 id="2-7-结构数据和单元数据"><a href="#2-7-结构数据和单元数据" class="headerlink" title="2.7  结构数据和单元数据"></a>2.7  结构数据和单元数据</h3><h5 id="2-7-1-结构数据"><a href="#2-7-1-结构数据" class="headerlink" title="2.7.1  结构数据"></a>2.7.1  结构数据</h5><p>1．结构矩阵的建立与引用</p><p>建立一个结构矩阵可采用给结构成员赋值的办法。</p><p>具体格式为：</p><blockquote><p>结构矩阵名.成员名=表达式</p><p>其中表达式应理解为矩阵表达式。</p></blockquote><p>2．结构成员的修改</p><p>可以根据需要增加或删除结构的成员。</p><p>例如要给结构矩阵a增加一个成员x4，可给a中任意一个元素增加成员x4：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a(<span class="number">1</span>).x4=‘<span class="number">410075</span>’;</span><br></pre></td></tr></table></figure><p>但其他成员均为空矩阵，可以使用赋值语句给它赋确定的值。</p><p>要删除结构的成员，则可以使用rmfield函数来完成。</p><p>例如，删除成员x4：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=rmfield(a,‘x4’);</span><br></pre></td></tr></table></figure><h5 id="2-7-2-单元数据"><a href="#2-7-2-单元数据" class="headerlink" title="2.7.2  单元数据"></a>2.7.2  单元数据</h5><p>建立单元矩阵和一般矩阵相似，只是矩阵元素用大括号括起来。</p><p>可以用带有大括号下标的形式引用单元矩阵元素。例如b{3,3}。单元矩阵的元素可以是结构或单元数据。</p><p>可以使用celldisp函数来显示整个单元矩阵，如celldisp(b)。</p>]]></content>
      
      
      <categories>
          
          <category> MATLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写博客的意义</title>
      <link href="/2021/11/08/0%E3%80%81hello_Blog/hello-world/"/>
      <url>/2021/11/08/0%E3%80%81hello_Blog/hello-world/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/CSDN_51che/src=http---www.mianfeiwendang.com-pic-19484a0c6efc11aab2a7cef732243488c7b81bc4-1-810-jpg_6-1080-0-0-1080.jpg&refer=http---www.mianfeiwendang.jpg"></p><blockquote><p>2021年11月7日创建了这个博客。</p></blockquote><blockquote><h3 id="搭建个人博客和写博客的意义："><a href="#搭建个人博客和写博客的意义：" class="headerlink" title="搭建个人博客和写博客的意义："></a>搭建个人博客和写博客的意义：</h3><p>①、便于以后对知识点的巩固复习；</p><p>②、建立起自己的知识清单；</p><p>③、记录学习中遇到的一些问题；</p><p>④、提高自己的写作能力；</p><p>⑤、为自己以后面试加分；</p><p>⑥、认识很多有意思的朋友；</p><p>⑦、提高阅读量，认识度。</p><p>⑧、在浩瀚无穷的网络世界留下属于我的足迹！</p></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/CSDN_51che/src=http---inews.gtimg.com-newsapp_match-0-5577924328-0.jpg&refer=http---inews.gtimg.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
