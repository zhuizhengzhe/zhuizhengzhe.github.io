<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>五、leetcode 3. 无重复字符的最长子串</title>
      <link href="/2021/11/22/1%E3%80%81C++/6.%E5%89%91%E6%8C%87offer+%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/leetcode%203.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2021/11/22/1%E3%80%81C++/6.%E5%89%91%E6%8C%87offer+%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/leetcode%203.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-3-无重复字符的最长子串"><a href="#leetcode-3-无重复字符的最长子串" class="headerlink" title="leetcode 3. 无重复字符的最长子串"></a>leetcode 3. 无重复字符的最长子串</h3><h4 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h4><blockquote><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。<br>示例 1:<br>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>示例 2:<br>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p>示例 3:<br>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p>示例 4:<br>输入: s = “”<br>输出: 0</p><p>提示：<br>    0 &lt;= s.length &lt;= 5 * 104<br>    s 由英文字母、数字、符号和空格组成</p></blockquote><p>二、解题思路</p><blockquote><p>使用「滑动窗口」解决问题：</p><p>①、使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指代表着「枚举子串的起始位置」，而右指不包含重复字符的最长子串的结束位置</p><p>②、在每一步的操作中，我们会将左指针向右移动一格，表示我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；</p><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一：使用unordered_map来实现哈希操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;         <span class="comment">// res记录最长无重复子串的长度</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;    <span class="comment">// left表示最左边的位置</span></span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;   <span class="comment">// 无序的哈希表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">left = <span class="built_in">max</span>(left, m[s[i]]);</span><br><span class="line">m[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">res = <span class="built_in">max</span>(res, <span class="built_in"><span class="keyword">int</span></span>(i - left + <span class="number">1</span>)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">unordered_set&lt;<span class="keyword">char</span>&gt; lookup;</span><br><span class="line"><span class="keyword">int</span> maxStr = <span class="number">0</span>;<span class="comment">//存放最大的长度</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;<span class="comment">//标记最左端位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) <span class="comment">//循环遍历每个字符</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">while</span> (lookup.<span class="built_in">find</span>(s[i]) != lookup.<span class="built_in">end</span>()) <span class="comment">//判断是否有重复字符</span></span><br><span class="line">            &#123;</span><br><span class="line">lookup.<span class="built_in">erase</span>(s[left]);<span class="comment">//有重复字符就将最左端移动出去</span></span><br><span class="line">left++;<span class="comment">//左端位置+1</span></span><br><span class="line">&#125;</span><br><span class="line">maxStr = <span class="built_in">max</span>(maxStr, i - left + <span class="number">1</span>);<span class="comment">//与之前的maxStr比较</span></span><br><span class="line">lookup.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxStr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Solution S1;</span><br><span class="line">vector&lt;<span class="keyword">char</span>&gt; str;</span><br><span class="line">string s = <span class="string">&quot;s = &quot;</span>pwwkew<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> n = S1.<span class="built_in">lengthOfLongestSubstring</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">str.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nums = <span class="built_in">lengthOfLongestSubstring</span>(str);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串最的长无重复子串的长度为: &quot;</span> &lt;&lt; nums &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无重复子串的长度为: &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>程序实现的具体流程：</strong></p><p>以s = “pwwkew”为例</p><p>①、</p></blockquote><p><img src="C:\Users\16226\AppData\Roaming\Typora\typora-user-images\image-20211122224114921.png" alt="image-20211122224114921"></p><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、C++ STL--标准模板库：map、multimap和unordered_map容器</title>
      <link href="/2021/11/22/1%E3%80%81C++/3.C++%20STL/6%E3%80%81C++%20STL%EF%BC%9Amap%E3%80%81multimap%E5%92%8Cunordered_map%E5%AE%B9%E5%99%A8/"/>
      <url>/2021/11/22/1%E3%80%81C++/3.C++%20STL/6%E3%80%81C++%20STL%EF%BC%9Amap%E3%80%81multimap%E5%92%8Cunordered_map%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h3 id="map、multimap和unordered-map容器"><a href="#map、multimap和unordered-map容器" class="headerlink" title="map、multimap和unordered_map容器"></a>map、multimap和unordered_map容器</h3><h4 id="map基本概念"><a href="#map基本概念" class="headerlink" title="map基本概念"></a>map基本概念</h4><p><strong>简介：</strong></p><ul><li>map中所有元素都是<code>pair</code></li><li><code>pair</code>中第一个元素为<code>key</code>（键值），起到索引作用，第二个元素为<code>value</code>（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><ul><li><code>map/multimap</code>属于<strong>关联式容器</strong>，底层结构是基于红黑树实现。</li></ul><p><strong>优点：</strong></p><ul><li>可以根据<code>key</code>值快速找到<code>value</code>值</li></ul><p><strong>map和multimap区别：</strong></p><ul><li><code>map</code>不允许容器中有重复key值元素</li><li><code>multimap</code>允许容器中有重复key值元素</li></ul><h4 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h4><p>使用map前要包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>功能描述：</strong></p><ul><li>对<code>map</code>容器进行构造和赋值操作</li></ul><p><strong>函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数: </li><li><code>map(const map &amp;mp);</code>             //拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;<span class="built_in">m2</span>(m); <span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m3;</span><br><span class="line">m3 = m2; <span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h4 id="map大小和交换"><a href="#map大小和交换" class="headerlink" title="map大小和交换"></a>map大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计map容器大小以及交换map容器</li></ul><p>函数原型：</p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2;</span><br><span class="line">m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"><span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">m.<span class="built_in">swap</span>(m2);</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"><span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   — size</li><li>判断是否为空   — empty</li><li>交换容器   — swap</li></ul><h4 id="map插入和删除"><a href="#map插入和删除" class="headerlink" title="map插入和删除"></a>map插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code>            //删除容器中值为key的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="comment">//第一种插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line"><span class="comment">//第二种插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//第三种插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="comment">//第四种插入方式</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">m.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>map插入方式很多，记住其一即可</li></ul><ul><li>插入   — insert </li><li>删除   — erase</li><li>清空   — clear</li></ul><h4 id="map查找和统计"><a href="#map查找和统计" class="headerlink" title="map查找和统计"></a>map查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m; </span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != m.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="keyword">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —  find    （返回的是迭代器）</li><li>统计   —  count  （对于map，结果为0或者1）</li></ul><h4 id="map容器排序"><a href="#map容器排序" class="headerlink" title="map容器排序"></a>map容器排序</h4><p><strong>学习目标：</strong></p><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点:</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//默认从小到大排序</span></span><br><span class="line"><span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><h4 id="unordered-map的使用"><a href="#unordered-map的使用" class="headerlink" title="unordered_map的使用"></a>unordered_map的使用</h4><h5 id="map和unordered-map区别："><a href="#map和unordered-map区别：" class="headerlink" title="map和unordered_map区别："></a><strong>map和unordered_map区别：</strong></h5><p><strong>map的优点及缺点：</strong></p><blockquote><p><strong>优点：</strong></p><p>①、<code>map</code>基于红黑树实现，红黑树具有<strong>自动排序的功能</strong>，因此map内部所有的数据，在任何时候，都是<strong>有序的</strong>；</p><p>②、<code>map</code>内部实现基于红黑树，使得map的很多操作在<code>lgn</code>的时间复杂度下就可以实现，因此<strong>效率非常的高</strong>。</p><p><strong>缺点：</strong></p><p> <strong>空间占用率高</strong>，因为map内部基于红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间。</p><p>应用场景：适用于有顺序要求的问题，使用map会更高效一些；</p></blockquote><p><strong>unordered_map的优点及缺点：</strong></p><blockquote><p><strong>优点：</strong></p><p><code>unordered_map</code>内部基于哈希表，所以数据插入和查找的时间复杂度很低，几乎是常数时间</p><p><strong>缺点:</strong></p><p><strong>代价是消耗比较多的内存，无自动排序功能。</strong>底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用<code>hash</code>函数对<code>key</code>进行映射到不同区域进行保存。</p><p>应用场景：对于查找问题，<code>unordered_map</code>会更加高效一些。</p></blockquote><p><strong>map和unordered_map的使用</strong></p><blockquote><p><code>unordered_map</code>的用法和<code>map</code>是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unordered_map&lt;string, <span class="keyword">int</span>&gt;  dict; <span class="comment">// 声明unordered_map对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据的三种方式</span></span><br><span class="line">dict.<span class="built_in">insert</span>(pair&lt;string,<span class="keyword">int</span>&gt;(<span class="string">&quot;apple&quot;</span>,<span class="number">2</span>));</span><br><span class="line">dict.<span class="built_in">insert</span>(unordered_map&lt;string, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="string">&quot;orange&quot;</span>,<span class="number">3</span>));</span><br><span class="line">dict[<span class="string">&quot;banana&quot;</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否有元素</span></span><br><span class="line"><span class="keyword">if</span>(dict.<span class="built_in">empty</span>())</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;该字典无元素&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;该字典共有&quot;</span>&lt;&lt;dict.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;个元素&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">unordered_map&lt;string, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">for</span>(iter=dict.<span class="built_in">begin</span>();iter!=dict.<span class="built_in">end</span>();iter++)</span><br><span class="line">cout&lt;&lt;iter-&gt;first&lt;&lt;ends&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">if</span>(dict.<span class="built_in">count</span>(<span class="string">&quot;boluo&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;can&#x27;t find boluo!&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;find boluo!&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((iter=dict.<span class="built_in">find</span>(<span class="string">&quot;banana&quot;</span>))!=dict.<span class="built_in">end</span>())</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;banana=&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;can&#x27;t find boluo!&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="例：leetcode3-无重复字符的最长子串"><a href="#例：leetcode3-无重复字符的最长子串" class="headerlink" title="例：leetcode3.无重复字符的最长子串"></a>例：leetcode3.无重复字符的最长子串</h5><blockquote><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用unordered_map来实现哈希操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;         <span class="comment">// res记录最长无重复子串的长度</span></span><br><span class="line"><span class="keyword">size_t</span> left = <span class="number">0</span>;    <span class="comment">// left表示最左边的位置</span></span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">size_t</span>&gt; m;   <span class="comment">// 无序的哈希表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">left = <span class="built_in">max</span>(left, m[s[i]]);</span><br><span class="line">m[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">res = <span class="built_in">max</span>(res, <span class="built_in"><span class="keyword">int</span></span>(i - left + <span class="number">1</span>)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">char</span>&gt; str;</span><br><span class="line">string s = <span class="string">&quot;abcdabcdbb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">str.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nums = <span class="built_in">lengthOfLongestSubstring</span>(str);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串最的长无重复子串的长度为: &quot;</span> &lt;&lt; nums &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串最的长无重复子串的长度为: <span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++-STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++-STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、C++ STL--标准模板库：stack和queue容器</title>
      <link href="/2021/11/22/1%E3%80%81C++/3.C++%20STL/4%E3%80%81C++%20STL%EF%BC%9Astack%E5%92%8Cqueue%E5%AE%B9%E5%99%A8/"/>
      <url>/2021/11/22/1%E3%80%81C++/3.C++%20STL/4%E3%80%81C++%20STL%EF%BC%9Astack%E5%92%8Cqueue%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h3 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h3><h4 id="stack-基本概念"><a href="#stack-基本概念" class="headerlink" title="stack 基本概念"></a>stack 基本概念</h4><p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为  — <strong>入栈</strong>  <code>push</code></p><p>栈中弹出数据称为  — <strong>出栈</strong>  <code>pop</code></p><p>![](<a href="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++STL">https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++STL</a> /src=http—iqchen.github.io-img-stack.png&amp;refer=http—iqchen.github.jpg)</p><h4 id="stack-常用函数"><a href="#stack-常用函数" class="headerlink" title="stack 常用函数"></a>stack 常用函数</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>      //向栈顶添加元素</li><li><code>pop();</code>                //从栈顶移除第一个元素</li><li><code>top(); </code>                //返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size(); </code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="comment">//输出栈顶元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//弹出栈顶元素</span></span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">栈顶元素为： <span class="number">3</span></span><br><span class="line">栈顶元素为： <span class="number">2</span></span><br><span class="line">栈顶元素为： <span class="number">1</span></span><br><span class="line">栈的大小为：<span class="number">0</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入栈   — push</li><li>出栈   — pop</li><li>返回栈顶   — top</li><li>判断栈是否为空   — empty</li><li>返回栈大小   — size</li></ul><h3 id="queue-容器"><a href="#queue-容器" class="headerlink" title="queue 容器"></a>queue 容器</h3><h4 id="queue-基本概念"><a href="#queue-基本概念" class="headerlink" title="queue 基本概念"></a>queue 基本概念</h4><p><strong>概念：</strong>队列–Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口;</p><p><strong>队列容器允许从一端新增元素，从另一端移除元素</strong>;</p><p><strong>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</strong>;</p><p>队列中进数据称为 — <strong>入队</strong>    <code>push</code></p><p>队列中出数据称为 — <strong>出队</strong>    <code>pop</code></p><h4 id="queue-常用接口"><a href="#queue-常用接口" class="headerlink" title="queue 常用接口"></a>queue 常用接口</h4><p>![](<a href="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++STL">https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++STL</a> /2-1P913113140553.jpg)</p><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>                             //往队尾添加元素</li><li><code>pop();</code>                                      //从队头移除第一个元素</li><li><code>back();</code>                                    //返回最后一个元素</li><li><code>front(); </code>                                  //返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size(); </code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line">queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;kevin&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;A1&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;B&quot;</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;C&quot;</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">q.<span class="built_in">push</span>(p1);</span><br><span class="line">q.<span class="built_in">push</span>(p2);</span><br><span class="line">q.<span class="built_in">push</span>(p3);</span><br><span class="line">q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列不提供迭代器，更不支持随机访问</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="comment">//输出队头元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name</span><br><span class="line">&lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name</span><br><span class="line">&lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//弹出队头元素</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">队头元素-- 姓名： kevin 年龄： <span class="number">20</span></span><br><span class="line">队尾元素-- 姓名： C 年龄： <span class="number">8</span></span><br><span class="line"></span><br><span class="line">队头元素-- 姓名： A1 年龄： <span class="number">10</span></span><br><span class="line">队尾元素-- 姓名： C 年龄： <span class="number">8</span></span><br><span class="line"></span><br><span class="line">队头元素-- 姓名： B 年龄： <span class="number">9</span></span><br><span class="line">队尾元素-- 姓名： C 年龄： <span class="number">8</span></span><br><span class="line"></span><br><span class="line">队头元素-- 姓名： C 年龄： <span class="number">8</span></span><br><span class="line">队尾元素-- 姓名： C 年龄： <span class="number">8</span></span><br><span class="line"></span><br><span class="line">队列大小为：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>入队   — push</li><li>出队   — pop</li><li>返回队头元素   — front</li><li>返回队尾元素   — back</li><li>判断队是否为空   — empty</li><li>返回队列大小   — size</li><li><strong>pop()虽然会移除下一个元素，但是并不返回它。front()和back()返回下一个元素但并不移除该元素。</strong></li><li><strong>stack中的函数与queue很类似，但是stack中要返回元素时，只能返回最后一个元素，且函数名不一样（stack中为s.top()），需要区分。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++-STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++-STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、剑指offer：06. 从尾到头打印链表</title>
      <link href="/2021/11/21/1%E3%80%81C++/6.%E5%89%91%E6%8C%87offer+%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/06.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/11/21/1%E3%80%81C++/6.%E5%89%91%E6%8C%87offer+%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/06.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06. 从尾到头打印链表"></a>06. 从尾到头打印链表</h2><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><blockquote><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>示例 1：</p><p>输入：head = [1,3,2]<br>输出：[2,3,1]</p><p>限制：</p><p>0 &lt;= 链表长度 &lt;= 10000</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p><strong>方法一：用栈实现</strong></p><blockquote><p>链表只能 从前至后 访问每个节点，而题目要求 倒序输出 各节点值，这种 <strong>先入后出</strong> 的需求可以借助 栈 来实现。<br><strong>算法流程：</strong></p><p>1.入栈： 遍历链表，将各节点值 push 入栈。<br>2.出栈： 将各节点值 pop 出栈，存储于数组并返回。</p></blockquote><p>复杂度分析：</p><blockquote><p>时间复杂度 O(N)： 入栈和出栈共使用 O(N) 时间。<br>空间复杂度 O(N)： 辅助栈 stack 和数组 res 共使用 O(N) 的额外空间。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方法二：使用C++自带的翻转函数reverse实现反转</strong></p><p>（头文件为algorithm）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方法三：递归法</strong></p><p>利用递归，先递推至链表末端；回溯时，依次将节点值加入列表，即可实现链表值的倒序输出。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Linux/2021031823334559.gif"></p><p>递归解析：</p><blockquote><p>终止条件： 当 head == None 时，代表越过了链表尾节点，则返回空列表；<br>递推工作： 访问下一节点 head.next ；<br>回溯阶段：<br>    C++： 将当前节点值 head.val 加入列表 tmp ；</p></blockquote><p>复杂度分析：</p><blockquote><p>时间复杂度 O(N)： 遍历链表，递归N 次。<br>空间复杂度 O(N)： 系统递归需要使用 O(N) 的栈空间。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printListFromTailToHead</span>(head-&gt;next);</span><br><span class="line">            v.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法四：迭代法</p><p>①、先定义三个节点p、q、m;p头结点之后的第1个节点;q头结点之后的第2节点;m头结点之后的第3个节点。然后将头结点的next指向为null</p><p>②、判断m是否为空，实现逆序每个节点，达到直接next指向掉头；</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Linux/20200826095014237.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代实现链表反转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List::reverse1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LINKNODE* p = head-&gt;next;<span class="comment">//头结点之后的第1个节点</span></span><br><span class="line">LINKNODE* q = head-&gt;next-&gt;next;<span class="comment">//头结点之后的第2节点</span></span><br><span class="line">LINKNODE* m = head-&gt;next-&gt;next-&gt;next;<span class="comment">//头结点之后的第3个节点</span></span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;<span class="comment">//将头接点之后的第1个节点的next指针置为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据m是否为空来判断 以此逆序每一个节点</span></span><br><span class="line"><span class="keyword">while</span> (m) &#123;</span><br><span class="line">q-&gt;next = p;</span><br><span class="line">p = q;</span><br><span class="line">q = m;</span><br><span class="line">m = m-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将最后一个节点逆序</span></span><br><span class="line">q-&gt;next = p;</span><br><span class="line"><span class="comment">//将头从新指向新的的第1个节点(之前的最后一个节点)</span></span><br><span class="line">head-&gt;next = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、具体程序实现"><a href="#三、具体程序实现" class="headerlink" title="三、具体程序实现"></a>三、具体程序实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">List</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">create_List</span>();</span><br><span class="line">&#125;;</span><br><span class="line">~<span class="built_in">List</span>() &#123; <span class="built_in">clear</span>(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_List</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LINKNODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">LINKNODE* next;</span><br><span class="line"><span class="built_in">LINKNODE</span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp; d) : <span class="built_in">data</span>(d), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LINKNODE* head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LINKNODE* p = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">LINKNODE* q = p-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//链表创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List::create_List</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">head = <span class="keyword">new</span> <span class="built_in">LINKNODE</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表头插</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List::insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LINKNODE* p = <span class="keyword">new</span> <span class="built_in">LINKNODE</span>(d);</span><br><span class="line">p-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代实现链表反转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List::reverse1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LINKNODE* p = head-&gt;next;<span class="comment">//头结点之后的第1个节点</span></span><br><span class="line">LINKNODE* q = head-&gt;next-&gt;next;<span class="comment">//头结点之后的第2节点</span></span><br><span class="line">LINKNODE* m = head-&gt;next-&gt;next-&gt;next;<span class="comment">//头结点之后的第3个节点</span></span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;<span class="comment">//将头接点之后的第1个节点的next指针置为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据m是否为空来判断 以此逆序每一个节点</span></span><br><span class="line"><span class="keyword">while</span> (m) &#123;</span><br><span class="line">q-&gt;next = p;</span><br><span class="line">p = q;</span><br><span class="line">q = m;</span><br><span class="line">m = m-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将最后一个节点逆序</span></span><br><span class="line">q-&gt;next = p;</span><br><span class="line"><span class="comment">//将头从新指向新的的第1个节点(之前的最后一个节点)</span></span><br><span class="line">head-&gt;next = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (LINKNODE* p = head-&gt;next; p; p = p-&gt;next) &#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">List list;</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;新建链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">list.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;反转链表1：&quot;</span> &lt;&lt; endl;</span><br><span class="line">list.<span class="built_in">reverse1</span>();</span><br><span class="line">list.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以递归法为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) :</span><br><span class="line">        <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、递归实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printListFromTailToHead</span>(head-&gt;next);</span><br><span class="line">            v.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、栈实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用STL算法reverse实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *one=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode *two=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    ListNode *three=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">    ListNode *four=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">    ListNode *five=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">    ListNode *six=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">6</span>);</span><br><span class="line">    one-&gt;next=two;</span><br><span class="line">    two-&gt;next=three;</span><br><span class="line">    three-&gt;next=four;</span><br><span class="line">    four-&gt;next=five;</span><br><span class="line">    five-&gt;next=six;</span><br><span class="line">    six-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//Solution1 s;</span></span><br><span class="line"><span class="comment">//Solution2 s;</span></span><br><span class="line">Solution3 s;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v=s.<span class="built_in">printListFromTailToHead</span>(one);</span><br><span class="line">    <span class="keyword">int</span> len=v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        cout&lt;&lt;v[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考链接：<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/mian-shi-ti-06-cong-wei-dao-tou-da-yin-lian-biao-d/">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/mian-shi-ti-06-cong-wei-dao-tou-da-yin-lian-biao-d/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、剑指offer：05. 替换空格</title>
      <link href="/2021/11/20/1%E3%80%81C++/6.%E5%89%91%E6%8C%87offer+%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/05.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2021/11/20/1%E3%80%81C++/6.%E5%89%91%E6%8C%87offer+%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/05.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a>05. 替换空格</h2><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><blockquote><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><p>限制：</p><p>0 &lt;= s 的长度 &lt;= 10000</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>由于需要将空格替换为 “%20” ，字符串的总字符数增加，因此需要扩展原字符串 s 的长度，计算公式为：<code>新字符串长度 = 原字符串长度 + 2 * 空格个数</code></p><p><strong>算法流程：</strong></p><blockquote><p>①、初始化：定义空格数量 count = 0 ，通过string.size()计算字符串长度 len ；<br>②、统计空格数量：遍历 s ，遇空格则 count++ ；<br>③、修改 s 长度：添加完 “%20” 后的字符串长度应为<code>len + 2 * count</code>；<br>④、倒序遍历修改：i 指向原字符串尾部元素， j 指向新字符串尾部元素；当 i = j 时跳出（代表左方已没有空格，无需继续遍历）；</p><p>​    a、当 s[i] 不为空格时：执行 s[j] = s[i] ；<br>​    b、当 s[i] 为空格时：将字符串闭区间 [j-2, j] 的元素修改为 “%20” ；由于修改了 3 个元素，因此需要 j -= 2 ；</p><p>⑤、返回值：已修改的字符串 s ；</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) <span class="comment">//从前向后</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                count++;<span class="comment">//记录空格数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=length<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) <span class="comment">//从后向前</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                str[j+<span class="number">2</span>*count]=str[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count--;</span><br><span class="line">                str[j+<span class="number">2</span>*count]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                str[j+<span class="number">2</span>*count+<span class="number">1</span>]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                str[j+<span class="number">2</span>*count+<span class="number">2</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三、具体程序实现"><a href="#三、具体程序实现" class="headerlink" title="三、具体程序实现"></a>三、具体程序实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span><span class="comment">//strlen函数的头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) <span class="comment">//从前向后</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                count++;<span class="comment">//记录空格数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=length<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) <span class="comment">//从后向前</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                str[j+<span class="number">2</span>*count]=str[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count--;</span><br><span class="line">                str[j+<span class="number">2</span>*count]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                str[j+<span class="number">2</span>*count+<span class="number">1</span>]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                str[j+<span class="number">2</span>*count+<span class="number">2</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[]=<span class="string">&quot;we are happy.&quot;</span>;</span><br><span class="line">    Solution s;</span><br><span class="line">    s.<span class="built_in">replaceSpace</span>(str,<span class="built_in">strlen</span>(str));<span class="comment">//strlen函数测字符数组长度</span></span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;<span class="comment">//字符数组直接这样输出就可以</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、剑指offer：04. 二维数组中的查找</title>
      <link href="/2021/11/20/1%E3%80%81C++/6.%E5%89%91%E6%8C%87offer+%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/04.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2021/11/20/1%E3%80%81C++/6.%E5%89%91%E6%8C%87offer+%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/04.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a>04. 二维数组中的查找</h2><h5 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h5><blockquote><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br>示例：<br>现有矩阵 matrix 如下：<br>[<br>[1,   4,  7, 11, 15],<br>[2,   5,  8, 12, 19],<br>[3,   6,  9, 16, 22],<br>[10, 13, 14, 17, 24],<br>[18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。<br>限制：<br>0 &lt;= n &lt;= 1000<br>0 &lt;= m &lt;= 1000</p></blockquote><h5 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h5><p><strong>1、线性查找法</strong></p><p>思路：</p><blockquote><p>由提示例可以观测到，二维数组的行从左至右依次增大，从上之下依次增大；<br>那么就可以利用这个规律进行查找；有两种思路：</p></blockquote><blockquote><p>1、从第一行最后一列matrix[0] [j]开始与目标值target比较<br>①、如果二维数组为空，则返回false；<br>②、如果当前值大于目标值target，则列-1；<br>③、如果当前值小于目标值target，则行+1;<br>④、当前值等于目标值target，则返回true；</p><p>伪代码：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断二维数组是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;<span class="comment">//定义行</span></span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//定义列</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span>(row &lt; matrix.<span class="built_in">size</span>() &amp;&amp; col &gt;= <span class="number">0</span>)<span class="comment">//循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] &gt; target)<span class="comment">//从矩阵 matrix右上角元素开始遍历与target比较</span></span><br><span class="line">                col--;<span class="comment">//大于target则列递减</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &lt; target)</span><br><span class="line">                row++;<span class="comment">//小于target则行递减</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//等于target则返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>2、从最后一行第一列matrix[i]  [0]开始与目标值 (target) 比较<br>①、如果二维数组为空，则返回false；<br>②、如果当前值大于目标值target，则行-1；<br>③、如果当前值小于目标值target，则列+1;<br>④、当前值等于目标值target，则返回true；</p></blockquote><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//首先判断二维数组是否为空</span></span><br><span class="line">   <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//定义左下角最后一行</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//定义右上角第一列</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &gt; target) i--;<span class="comment">//小于target，行上移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target) j++;<span class="comment">//大于target，列下移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><blockquote><p>时间复杂度：O(n+m)。访问到的下标的行最多增加 n 次，列最多减少 m 次，因此循环体最多执行 n + m 次。<br>空间复杂度：O(1)。</p></blockquote><p><strong>2、具体程序实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; v, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、判断二维数组是否为空</span></span><br><span class="line"><span class="keyword">if</span>(v.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//二维数组行</span></span><br><span class="line"><span class="keyword">int</span> j = v[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//二维数组列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i &lt; v.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//2、如果当前数值大于target，则列-1</span></span><br><span class="line"><span class="keyword">if</span>(v[i][j] &gt; target)</span><br><span class="line">&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(v[i][j] &lt; target) <span class="comment">//3、如果当前值小于target则行+1</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(v[i][j] == target)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">v1</span>(<span class="number">5</span>,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>));</span><br><span class="line"><span class="keyword">int</span> arry[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>&#125;,</span><br><span class="line">&#123;<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>&#125;,</span><br><span class="line">&#123;<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">v1[i][j] = arry[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Solution s;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">findNumberIn2DArray</span>(v1,<span class="number">12</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没有找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到了</span><br></pre></td></tr></table></figure><p>程序具体的实现流程：</p><blockquote><p>①、v[0] [5] = 15 &lt; 12，因此列 j-1;<br>②、v[0] [4] = 11 &lt; 12,因此行 i+1;<br>③、v[1] [4] = 12 = 12,输出找到了</p></blockquote><blockquote><p>参考链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、Makefile基础</title>
      <link href="/2021/11/20/2%E3%80%81Linux/%E4%B8%89%E3%80%81Makefile%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/11/20/2%E3%80%81Linux/%E4%B8%89%E3%80%81Makefile%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Makefile基础"><a href="#Makefile基础" class="headerlink" title="Makefile基础"></a>Makefile基础</h2><h3 id="Makefile简介"><a href="#Makefile简介" class="headerlink" title="Makefile简介"></a>Makefile简介</h3><p><strong>什么是makefile？</strong></p><blockquote><p>如果以前一直使用 IDE来编写 C/C++ 语言的话肯定没有听说过 Makefile 这个东西，因为这些 IDE对makefile文件进行了封装，提供给的是已经经过封装后的图形界面，我们在 IDE 中添加要编译的 C/C++文件，然后点击按钮就完成了编译。而在 Linux 下用的最多的是 GCC 编译器，这是个没有 UI的编译器，因此 Makefile 就需要我们自己来编写了。  </p></blockquote><p><strong>Makefile：是描述哪些文件需要编译、哪些需要重新编译的文件；  而make就是工程编译的工具，相当于IDE中图形界面的按钮。</strong></p><p><strong>为什么要引入Makefile？</strong></p><blockquote><p>使用 GCC 的命令行进行程序编译在单个文件下是比较方便的，但当工程中的文件有几十、上百甚至上万个的时候，用终端输入 GCC 命令的方法显然是不现实的  。这种情况下我们需要借助项目构造工具 make 帮助我们完成这个艰巨的任务。</p></blockquote><h3 id="Makefile语法"><a href="#Makefile语法" class="headerlink" title="Makefile语法"></a>Makefile语法</h3><h4 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h4><blockquote><p>Makefile 的框架是由规则构成的。make 命令执行时先在 Makefile 文件中查找各种规则，对各种规则进行解析后运行规则。规则的基本格式为：</p></blockquote><p>Makefile规则的语法格式:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : depend ...</span><br><span class="line">command1</span><br><span class="line">command2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>每条规则由三个部分组成分别是目标(target), 依赖(depend) 和命令(command)。</p><blockquote><p>①、目标(target)： 规则中的目标，这个目标和规则中的命令是对应的<br>    通过执行规则中的命令，可以生成一个和目标同名的文件<br>    规则中可以有多个命令，因此可以通过这多条命令来生成多个目标，所有目标也可以有很多个<br>    通过执行规则中的命令，可以只执行一个动作，不生成任何文件，这样的目标被称为伪目标</p><p>②、依赖(depend): 规则所必需的依赖条件，在规则的命令中可以使用这些依赖。<br>    例如：生成可执行文件的目标文件（*.o）可以作为依赖使用<br>    如果规则的命令中不需要任何依赖，那么规则的依赖可以为空<br>    当前规则中的依赖可以是其他规则中的某个目标，这样就形成了规则之间的嵌套<br>    依赖可以根据要执行的命令的实际需求，指定很多个</p><p>③、命令(command): 当前这条规则的动作，一般情况下这个动作就是一个 shell 命令<br>    例如：通过某个命令编译文件、生成库文件、进入目录等。<br>    动作可以是多个，<strong>命令列表中的每条命令必须以 TAB 键开始，不能使用空格！</strong>  并且独占占一行。</p><p>​    如果命令太长，可以使用反斜框（‘\’）作为换行符。  </p></blockquote><p>例：通过键盘输入两个数字，计算出它们的乘积；</p><p>input.c   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;input.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_int</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input two num:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, a, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input.h  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _INPUT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INPUT_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_int</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>multiply .c  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>multiply .h  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _CALCU_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CALCU_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main.c  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;input.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;multiply .h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b, num;</span><br><span class="line">input_int(&amp;a, &amp;b);</span><br><span class="line">    num = multiply (a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\r\n&quot;</span>, a, b, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工程中有 main.c、 input.c 和 multiply .c 这三个 C 文件和 input.h、 multiply .h 这两个头文件  </p><p>例1：Makefile  编写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 规则1 main是通过编译 main.o input.o multiply.o</span></span><br><span class="line">main: main.o input.o multiply.o</span><br><span class="line">gcc -o main main.o input.o multiply.o</span><br><span class="line"><span class="meta">#</span><span class="bash"> 规则2 main.o是通过编译main.c生成的</span></span><br><span class="line">main.o: main.c</span><br><span class="line">gcc -c main.c</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 规则3 input.o是通过编译input.c生成的</span></span><br><span class="line">input.o: input.c</span><br><span class="line">gcc -c input.c</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 规则4 multiply.o是通过编译multiply.c生成的</span></span><br><span class="line">multiply.o: multiply.c</span><br><span class="line">gcc -c multiply.c</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 规则5 通过make clean 删除所有的.o和main文件</span></span><br><span class="line">clean:</span><br><span class="line">rm *.o</span><br><span class="line">rm main</span><br></pre></td></tr></table></figure><blockquote><p><strong>规则的执行顺序：</strong></p><p>需要注意的是在调用 make 命令编译程序的时候，make 会首先找到 Makefile 文件中的第 1 个规则，分析并执行相关的动作。但好多时候要执行的命令中使用的依赖是不存在的，如果使用的依赖不存在，这个动作也就不会被执行。</p><p>解决方案：将不存在的依赖作为这个新的规则中的目标，当这条新的规则对应的命令执行完毕，对应的目标就被生成了，同时另一条规则中需要的依赖也就存在了。这样，makefile 中的某一条规则在需要的时候，就会被其他的规则调用，直到 makefile 中的第一条规则中的所有的依赖全部被生成，第一条规则中的命令就可以基于这些依赖生成对应的目标，make 的任务也就完成了。</p><p>如上例中：规则1中main.o 、input.o、 multiply.o先没有存在，那么就先执行规则2、规则3、规则4，生成main.o 、input.o、 multiply.o后再执行规则1</p></blockquote><h4 id="Makefile变量"><a href="#Makefile变量" class="headerlink" title="Makefile变量"></a>Makefile变量</h4><p>跟C/C++语言一样 Makefile 也支持变量 ;但不像 C/C++语言中的变量有 int、char等各种类型， Makefile 中的变量都是字符串。</p><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“$”符号，但最好用小括号“（）”或是大号“{}”把变量给包括起来。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o input.o multiply.o</span><br><span class="line">main: $(objects)</span><br><span class="line">gcc -o main $(objects)</span><br></pre></td></tr></table></figure><p>Makefile变量的赋值符还有其它两个“:=”和“?=”</p><blockquote><p>1、赋值符“=” : 使用“=”在给变量的赋值的时候，不一定要用已经定义好的值，也可以使用后面定义的值;  </p><p>2、赋值符“:=”  :赋值符“:=”不会使用后面定义的变量，只能使用前面已经定义好的;相当于在C/C++ 变量前添加了const；</p><p>3、赋值符“?=”  ：如果变量没有被赋值，那就使用=号后的值，如果已经定义，那就不改变；</p><p>4、变量追加“+=”  ：Makefile 中的变量是字符串，有时候我们需要给前面已经定义好的变量添加一些字符串进去，此时就要使用到符号“+=”  </p></blockquote><p>3.2 预定义变量</p><pre><code>在 Makefile 中有一些已经定义的变量，用户可以直接使用这些变量，不用进行定义。在进行编译的时候，某些条件下 Makefile 会使用这些预定义变量的值进行编译。这些预定义变量的名字一般都是大写的，经常采用的预定义变量如下表所示：</code></pre><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Linux/20211120143016.png"></p><h4 id="Makefile模式"><a href="#Makefile模式" class="headerlink" title="Makefile模式"></a>Makefile模式</h4><p>模式规则中，至少在规则的目标定定义中要包涵“%”，否则就是一般规则，目标中的“%”表示对文件名的配，“%”表示长度任意的非空字符串，比如“%.c”就是所有的以.c 结尾的文件，类似与通配符， a.%.c 就表示以 a.开头，以.c 结束的所有文件。  </p><h4 id="Makefile自动化变量"><a href="#Makefile自动化变量" class="headerlink" title="Makefile自动化变量"></a>Makefile自动化变量</h4><blockquote><p>Makefile 中的变量除了用户自定义变量和预定义变量外，还有一类自动变量。Makefile 中的规则语句中经常会出现目标文件和依赖文件，自动变量用来代表这些规则中的目标文件和依赖文件，并且它们只能在规则的命令中使用。</p></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Linux/20211120143021.png"></p><p>常用的三种： $@、 $&lt;和$^ </p><p>使用Makefile模式规则和自动化变量对例1中Makefile文件进行精简：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">规则1</span></span><br><span class="line">objects = main.o input.o calcu.o</span><br><span class="line">main: $(objects)</span><br><span class="line">gcc -o main $(objects)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">规则2</span></span><br><span class="line"><span class="meta">%</span><span class="bash">.o : %.c</span></span><br><span class="line">gcc -c $&lt;  #使用自动化变量：$&lt;，将所有的.c文件编译成.o文件</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">规则3</span></span><br><span class="line">clean:</span><br><span class="line">rm *.o</span><br><span class="line">rm main</span><br></pre></td></tr></table></figure><h4 id="Makefile伪目标"><a href="#Makefile伪目标" class="headerlink" title="Makefile伪目标"></a>Makefile伪目标</h4><p>Makefile 有一种特殊的目标——<strong>伪目标</strong>，一般的目标名都是要生成的文件，而伪目标不代表真正的目标名，在执行 make 命令的时候通过指定这个伪目标来执行其所在规则的定义的命令。  </p><p>使用伪目标的目的：主要是为了避免 Makefile 中定义的只执行命令的目标和工作目录下的实际文件出现名字冲突，有时候我们需要编写一个规则用来执行一些命令，但是这个规则不是用来创建文件的，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">rm *.o</span><br><span class="line">rm main</span><br></pre></td></tr></table></figure><p>规则中并没有创建文件 clean 的命令，因此工作目录下永远都不会存在文件 clean，当我们输入“make clean”以后，后面的“rm *.o”和“rm main”总是会执行。但当出错在工作目录下创建一个名为“clean”的文件时，当执行“make clean”的时候，规则因为没有依赖文件，所以目标被认为是最新的，因此后面的 rm 命令也就不会执行，预先设想的清理工程的功能也就无法完成。为了避免这个问题，可以将 clean 声明为伪目标，声明方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean  </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">规则1</span></span><br><span class="line">objects = main.o input.o calcu.o</span><br><span class="line">main: $(objects)</span><br><span class="line">gcc -o main $(objects)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">伪命令</span></span><br><span class="line">.PHONY : clean  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">规则2</span></span><br><span class="line"><span class="meta">%</span><span class="bash">.o : %.c</span></span><br><span class="line">gcc -c $&lt;  #使用自动化变量：$&lt;，将所有的.c文件编译成.o文件</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">规则3</span></span><br><span class="line">clean:</span><br><span class="line">rm *.o</span><br><span class="line">rm main</span><br></pre></td></tr></table></figure><blockquote><p>clean 为伪目标，声明 clean 为伪目标以后不管当前目录下是否存在名为“clean”的文件，输入“make clean”的话规则后面的 rm 命令都会执行。  </p></blockquote><h4 id="Makefile的条件判断"><a href="#Makefile的条件判断" class="headerlink" title="Makefile的条件判断"></a>Makefile的条件判断</h4><h5 id="Makefile-也支持条件判断，语法有两种："><a href="#Makefile-也支持条件判断，语法有两种：" class="headerlink" title="Makefile 也支持条件判断，语法有两种："></a>Makefile 也支持条件判断，语法有两种：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;条件关键字&gt;</span><br><span class="line">&lt;条件为真时执行的语句&gt;</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>以及：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;条件关键字&gt;</span><br><span class="line">&lt;条件为真时执行的语句&gt;</span><br><span class="line">else</span><br><span class="line">&lt;条件为假时执行的语句&gt;</span><br><span class="line">endif  </span><br></pre></td></tr></table></figure><h5 id="条件关键字有-4-个："><a href="#条件关键字有-4-个：" class="headerlink" title="条件关键字有 4 个："></a>条件关键字有 4 个：</h5><blockquote><p> ifeq、 ifneq、 ifdef 和 ifndef，这四个关键字其实分为两对、 ifeq 与ifneq、 ifdef 与 ifndef。</p></blockquote><p><strong>①、ifeq 和 ifneq</strong></p><p> ifeq 用来判断是否相等， ifneq 就是判断是否不相等， ifeq 用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifeq (&lt;参数 1&gt;, &lt;参数 2&gt;)</span><br><span class="line">ifeq ‘&lt;参数 1 &gt;’ ,‘ &lt;参数 2&gt;’</span><br><span class="line">ifeq “&lt;参数 1&gt;” , “&lt;参数 2&gt;”</span><br><span class="line">ifeq “&lt;参数 1&gt;” , ‘&lt;参数 2&gt;’</span><br><span class="line">ifeq ‘&lt;参数 1&gt;’ , “&lt;参数 2&gt;”  </span><br></pre></td></tr></table></figure><blockquote><p>用来比较“参数 1”和“参数 2”是否相同，如果相同则为真，“参数 1”和“参数 2”可以为函数返回值。 ifneq 的用法类似，只不过 ifneq 是用来了比较“参数 1”和“参数 2”是否不相等，如果不相等的话就为真。  </p></blockquote><p><strong>②、ifdef 和 ifndef</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifdef &lt;变量名&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果“变量名”的值非空，那么表示表达式为真，否则表达式为假。“变量名”同样可以是一个函数的返回值。 ifndef 用法类似，但是含义用户 ifdef 相反。  </p></blockquote><h4 id="Makefile函数"><a href="#Makefile函数" class="headerlink" title="Makefile函数"></a>Makefile函数</h4><p>Makefile 中的函数是已经定义好的，可以直接使用，但不支持自定义函数。</p><h5 id="函数的用法"><a href="#函数的用法" class="headerlink" title="函数的用法:"></a>函数的用法:</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(函数名 参数集合)</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;函数名 参数集合&#125;</span>  </span><br></pre></td></tr></table></figure><blockquote><p>调用函数和调用普通变量一样，使用符号“$”来标识。参数集合是函数的多个参数，参数之间以逗号“,”隔开，函数名和参数之间以“空格”分隔开，函数的调用以“$”开头。  </p></blockquote><h5 id="常用的Makefile函数："><a href="#常用的Makefile函数：" class="headerlink" title="常用的Makefile函数："></a>常用的Makefile函数：</h5><p><strong>①、函数 subst</strong>  </p><p>函数 subst 用来完成字符串替换，调用形式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><p>此函数的功能是将字符串<text>中的<from>内容替换为<to>，函数返回被替换以后的字符串；  </p><p><strong>②、、函数 patsubst</strong>  </p><p>函数 patsubst 用来完成模式字符串替换，使用方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><p>此函数查找字符串<text>中的单词是否符合模式<pattern>，如果匹配就用<replacement>来替换掉，<pattern>可以使用包括通配符“%”，表示任意长度的字符串，函数返回值就是替换后的字符串。如果<replacement>中也包涵“%”，那么<replacement>中的“%”将是<pattern>中的那个“%”所代表的字符串 。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(patsubst %.c,%.o,a.c b.c c.c)</span></span><br></pre></td></tr></table></figure><blockquote><p>将字符串“a.c b.c c.c”中的所有符合“%.c”的字符串，替换为“%.o”，替换完成以后的字符串为“a.o b.o c.o”。</p></blockquote><p><strong>③、、函数 dir</strong><br>函数 dir 用来获取目录，使用方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(dir &lt;names…&gt;)</span>  </span><br></pre></td></tr></table></figure><p><strong>④、、函数 notdir</strong><br>函数 notdir 看名字就是知道去除文件中的目录部分，也就是提取文件名，用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(notdir &lt;names…&gt;)</span></span><br></pre></td></tr></table></figure><p>此函数用与从文件名序列<names>中提取出文件名非目录部分，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(notdir &lt;/src/a.c&gt;)</span></span><br></pre></td></tr></table></figure><p>提取文件“/src/a.c”中的非目录部分，也就是文件名“a.c”。  </p><p><strong>⑤、、函数 foreach</strong><br>foreach 函数用来完成循环，用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(foreach &lt;var&gt;, &lt;list&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><p>此函数的意思就是把参数<list>中的单词逐一取出来放到参数<var>中，然后再执行<text>所<br>包含的表达式。每次<text>都会返回一个字符串，循环的过程中， <text>中所包含的每个字符串<br>会以空格隔开，最后当整个循环结束时， <text>所返回的每个字符串所组成的整个字符串将会是<br>函数 foreach 函数的返回值。  </p><p><strong>⑥、函数 wildcard</strong></p><p>通配符“%”只能用在规则中，只有在规则中它才会展开，如果在变量定义和函数使用时，<br>通配符不会自动展开，这个时候就要用到函数 wildcard，使用方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(wildcard PATTERN…)</span></span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(wildcard *.c)</span></span><br></pre></td></tr></table></figure><p>上面的代码是用来获取当前目录下所有的.c 文件，类似“%”。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、剑指offer：03. 数组中重复的数字</title>
      <link href="/2021/11/19/1%E3%80%81C++/6.%E5%89%91%E6%8C%87offer+%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/03.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2021/11/19/1%E3%80%81C++/6.%E5%89%91%E6%8C%87offer+%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/03.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03. 数组中重复的数字"></a>03. 数组中重复的数字</h2><h5 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h5><blockquote><p>找出数组中重复的数字。 </p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><p>限制：</p><p>2 &lt;= n &lt;= 100000</p></blockquote><h5 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h5><p><strong>1、使用原地置换的法</strong></p><blockquote><p>数组元素的 索引和值是 一对多的关系。 因此，可遍历数组并通过交换操作，使元素的索引与 值一一对应（即 nums[i]=i ）。这样就能通过索引映射对应的值，起到与字典等价的作用。</p></blockquote><table><thead><tr><th align="center">nums[i]</th><th>2</th><th>3</th><th>1</th><th>0</th><th>2</th><th>5</th><th>3</th></tr></thead><tbody><tr><td align="center">i</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr></tbody></table><p>算法流程：</p><p>遍历数组 nums ，设索引初始值为 i=0 :</p><p>若nums[i]=i ： 说明此数字已在对应索引位置，无需交换，因此跳过；</p><p>若nums[nums[i]]=nums[i] ： 代表索引 nums[i] 处和索引 i 处的元素值都为 nums[i] ，即找到一组重复值，返回此值 nums[i] ；</p><p>否则： 交换索引为 i 和 nums[i] 的元素值，将此数字交换至对应索引位置。</p><p>若遍历完毕尚未找到，则返回 −1 。</p><blockquote><p>①、判断vector容器是否为空；</p><p>②、初始值为 i=0开始遍历数组 nums :</p><p>③、判断nums[i]与i的关系，如果nums[i]=i ，则说明此数字已在对应索引位置，无需交换；如果不相等，则进行交换 temp = nums[nums[i]]; nums[nums[i]]=nums[i]; nums[i]=temp; 直到nums[i]=i; i+1进入下一次遍历；</p><p>④、如果nums[nums[i]]=nums[i] ，代表索引 nums[i] 处和索引 i 处的元素值都为 nums[i]，即为我们要找的重复数字</p></blockquote><p>复杂度分析：</p><blockquote><p>时间复杂度 O(N)： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1)；<br>空间复杂度 O(1) ： 使用常数复杂度的额外空间。</p></blockquote><p>具体程序实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVecotr</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用原地置换法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="comment">//首先判断数组是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i]!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[nums[i]])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">int</span> temp = nums[nums[i]];</span><br><span class="line">            nums[nums[i]]=nums[i];</span><br><span class="line">            nums[i]=temp;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> length = <span class="built_in"><span class="keyword">sizeof</span></span>(a)/<span class="built_in"><span class="keyword">sizeof</span></span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVecotr</span>(v1);</span><br><span class="line">cout  &lt;&lt; length &lt;&lt; endl;</span><br><span class="line">Solution S;</span><br><span class="line"><span class="keyword">auto</span> num = S.<span class="built_in">findRepeatNumber</span>(v1);</span><br><span class="line">cout  &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span> </span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>程序具体的实现流程：</p><blockquote><p>①、i = 0, nums[0] = 2 != 0;进入交换：temp = nums[nums[0]] = 1, nums[nums[0] = nums[0] = 2,nums[0] = 1;</p><p>则数组顺序变为：{1,3,2,0,2,5,3}</p><p>②、i = 0, nums[0] = 1 != 0; 进入交换：temp = nums[nums[0]] = 3, nums[nums[0] = nums[0] = 1,nums[0] = 3;</p><p>则数组顺序变为：{3,1,2,0,2,5,3}</p><p>③、i = 0, nums[0] = 3 != 0; 进入交换：temp = nums[nums[0]] = 0, nums[nums[0] = nums[0] = 3,nums[0] = 0;</p><p>则数组顺序变为：{0,1,2,3,2,5,3}</p><p>④、此时有nums[0] = 0；nums[1] = 1；nums[2] = 2；nums[3] = 3；</p><p>⑤、i = 4, nums[4] = 2 != 4; 进入if判断：nums[4] = nums[nums[4]]) = 2，则返回2</p></blockquote><blockquote><p>参考链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、C++ STL--标准模板库：deque 容器</title>
      <link href="/2021/11/18/1%E3%80%81C++/3.C++%20STL/3%E3%80%81C++%20STL%EF%BC%9Adeque%E5%AE%B9%E5%99%A8/"/>
      <url>/2021/11/18/1%E3%80%81C++/3.C++%20STL/3%E3%80%81C++%20STL%EF%BC%9Adeque%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h3 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h4><p><strong>功能：</strong></p><ul><li>双端数组，可以对头端进行插入删除操作，本质是一个动态数组。</li></ul><p><strong>deque与vector区别：</strong></p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低；</li><li>deque两端都能快速的安插元素和移除元素，对头部的插入删除速度回比vector快；</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关；</li><li>deque不支持对容量capacity和内存重新分配控制；</li><li>deque和vector在中段插入、删除的速度都比较慢。</li></ul><p><strong>deque内部工作原理:</strong></p><p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h4 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p><ul><li>deque容器构造</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&lt;T&gt; deqT</code>;                      //默认构造形式</li><li><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"><span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line"><span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt;<span class="built_in">d3</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt;d4 = d3;</span><br><span class="line"><span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">100 100 100 100 100 100 100 100 100 100 </span><br><span class="line">100 100 100 100 100 100 100 100 100 100 </span><br></pre></td></tr></table></figure><h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给deque容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&amp; operator=(const deque &amp;deq); </code>         //重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>       </li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">d2 = d1;</span><br><span class="line"><span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt;d3;</span><br><span class="line">d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt;d4;</span><br><span class="line">d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">100 100 100 100 100 100 100 100 100 100 </span><br></pre></td></tr></table></figure><h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对deque容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque.empty();</code>                       //判断容器是否为空</p></li><li><p><code>deque.size();</code>                         //返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p><p>​                                         //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p><p>​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="keyword">if</span> (d1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//统计大小</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">d1不为空!</span><br><span class="line">d1的大小为：10</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 1 1 1 1 1 </span><br><span class="line">0 1 2 3 4 </span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>deque没有容量的概念</li><li>判断是否为空   — empty</li><li>返回元素个数   — size</li><li>重新指定个数   — resize</li></ul><h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>向deque容器中插入和删除数据</li></ul><p><strong>函数原型：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li><li><code>push_front(elem);</code>        //在容器头部插入一个数据</li><li><code>pop_back();</code>                   //删除容器最后一个数据</li><li><code>pop_front();</code>                 //删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p></li><li><p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p></li><li><p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p></li><li><p><code>clear();</code>                           //清空容器的所有数据</p></li><li><p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p></li><li><p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">d.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">d.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">d.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">200 100 10 20 </span><br><span class="line">100 10 </span><br><span class="line">200 100 10 20 </span><br><span class="line">1000 200 100 10 20 </span><br><span class="line">10000 10000 1000 200 100 10 20 </span><br><span class="line">1 2 3 10000 10000 1000 200 100 10 20 </span><br><span class="line">200 100 10 20 </span><br><span class="line">100 10 20 </span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插   —  push_back</li><li>尾删   —  pop_back</li><li>头插   —  push_front</li><li>头删   —  pop_front</li></ul><h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对deque 中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>      //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">200 100 10 20 </span><br><span class="line">200 100 10 20 </span><br><span class="line">front:200</span><br><span class="line">back:20</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7  deque 排序"></a>3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p><ul><li>利用算法实现对deque容器进行排序</li></ul><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"><span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">200 100 10 20 </span><br><span class="line">10 20 100 200 </span><br></pre></td></tr></table></figure><blockquote><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p></blockquote><p>deque的函数和vector不同点：</p><p>①、deque不提供容量操作：capacity()和reserve()；</p><p>②、deque直接提供函数完成头部元素的安插和删除：push_front()和pop_front()；</p>]]></content>
      
      
      <categories>
          
          <category> C++-STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++-STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、MATLAB数据可视化</title>
      <link href="/2021/11/16/5%E3%80%81matlab/%E4%BA%94%E3%80%81MATLAB%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/2021/11/16/5%E3%80%81matlab/%E4%BA%94%E3%80%81MATLAB%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="五、MATLAB数据可视化"><a href="#五、MATLAB数据可视化" class="headerlink" title="五、MATLAB数据可视化"></a>五、MATLAB数据可视化</h2><h3 id="5-1-二维图形"><a href="#5-1-二维图形" class="headerlink" title="5.1  二维图形"></a>5.1  二维图形</h3><h4 id="5-1-1、绘制二维曲线的基本函数"><a href="#5-1-1、绘制二维曲线的基本函数" class="headerlink" title="5.1.1、绘制二维曲线的基本函数"></a>5.1.1、绘制二维曲线的基本函数</h4><p><strong>1.plot函数的基本用法</strong><br>plot函数的基本调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(x,y) </span><br></pre></td></tr></table></figure><p>其中x和y为长度相同的向量，分别用于存储x坐标和y坐标数据。</p><p>例1:在0≤X≤2区间内，绘制曲线y=2e-0.5xsin(2πx)。<br>    程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);</span><br><span class="line"> <span class="built_in">plot</span>(x,y)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214627.png"></p><p>例2: 绘制曲线。<br><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214643.png"></p><p>程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t=-<span class="built_in">pi</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="built_in">pi</span>;</span><br><span class="line">x=t.*<span class="built_in">cos</span>(<span class="number">3</span>*t);</span><br><span class="line">y=t.*<span class="built_in">sin</span>(t).*<span class="built_in">sin</span>(t);</span><br><span class="line"><span class="built_in">plot</span>(x,y); </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214648.png"></p><blockquote><p>说明：<br>（1）当x是向量，y是矩阵时，x的长度与矩阵y的行数或列数必须相等。如果x的长度等于y的行数，则以x和y的每列为横、纵坐标绘制曲线，曲线的条数等y的列数。如果x的长度等于y的列数，则以x和y的每行为横、纵坐标绘制曲线，曲线的条数等y的行数。<br>（2）当x、y是同维矩阵时，则以x、y对应列元素为横、纵坐标分别绘制曲线，曲线条数等于矩阵的列数。<br>（3）plot函数最简单的调用格式是只包含一个输入参数：plot(x)。</p></blockquote><p><strong>2．含多个输入参数的plot函数</strong><br>含多个输入参数的plot函数调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(x1,y1,x2,y2,…,xn,yn)</span><br></pre></td></tr></table></figure><p><strong>3．含选项的plot函数</strong><br>含选项的plot函数调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(x1,y1,选项<span class="number">1</span>,x2,y2, 选项<span class="number">2</span>,…,xn,yn,选项n)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214653.png"></p><p>例3   用不同线型和颜色在同一坐标内绘制曲线</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214700.png"></p><p>及其包络线。<br>程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>)&#x27;;</span><br><span class="line">y1=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x)*[<span class="number">1</span>,<span class="number">-1</span>];</span><br><span class="line">y2=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);</span><br><span class="line">x1=(<span class="number">0</span>:<span class="number">12</span>)/<span class="number">2</span>;</span><br><span class="line">y3=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x1).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x1);</span><br><span class="line"><span class="built_in">plot</span>(x,y1,<span class="string">&#x27;g:&#x27;</span>,x,y2,<span class="string">&#x27;b--&#x27;</span>,x1,y3,<span class="string">&#x27;rp&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214706.png"></p><p><strong>4．双纵坐标函数plotyy</strong><br>    plotyy函数是MATLAB 5.X新增的函数。它能把函数值具有不同量纲、不同数量级的两个函数绘制在同一坐标中。调用格式为：<br>    plotyy(x1,y1,x2,y2)<br>   其中x1-y1对应一条曲线，x2-y2对应另一条曲线。横坐标的标度相同，纵坐标有两个，左纵坐标用于x1-y1数据对，右纵坐标用于x2-y2数据对。</p><p>例5-4  用不同标度在同一坐标内绘制曲线<br>y1=e-0.5xsin(2πx)及曲线y2=sin(x)。<br>    程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   x1=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">   x2=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">3</span>*<span class="built_in">pi</span>;</span><br><span class="line">y1=<span class="built_in">exp</span>(<span class="number">-0.5</span>*x1).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x1);</span><br><span class="line">   y2= <span class="built_in">sin</span>(x2);</span><br><span class="line">   plotyy(x1,y1,x2,y2);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214711.png"></p><h4 id="5-1-2-绘制图形的辅助操作"><a href="#5-1-2-绘制图形的辅助操作" class="headerlink" title="5.1.2  绘制图形的辅助操作"></a>5.1.2  绘制图形的辅助操作</h4><p><strong>1.图形标注</strong><br>有关图形标注函数的调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title(图形名称)</span><br><span class="line">xlabel(x轴说明)</span><br><span class="line">ylabel(y轴说明)</span><br><span class="line">text(x,y,图形说明)</span><br><span class="line"><span class="built_in">legend</span>(图例<span class="number">1</span>,图例<span class="number">2</span>,…)</span><br></pre></td></tr></table></figure><p><strong>2.坐标控制</strong><br>函数的调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axis([xmin xmax ymin ymax zmin zmax])</span><br><span class="line">axis函数功能丰富，常用的用法还有：</span><br><span class="line">axis equal    纵、横坐标轴采用等长刻度</span><br><span class="line">axis square   产生正方形坐标系(缺省为矩形)</span><br><span class="line">axis auto     使用缺省设置</span><br><span class="line">axis off      取消坐标轴</span><br><span class="line">axis on      显示坐标轴</span><br><span class="line">grid on/off命令控制是画还是不画网格线，不带参数的grid命令在两种状态之间进行切换。</span><br><span class="line">box on/off命令控制是加还是不加边框线，不带参数的box命令在两种状态之间进行切换。</span><br></pre></td></tr></table></figure><p>例5  绘制分段函数曲线并添加图形标注</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214716.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; x=linspace(0,10,100);</span><br><span class="line">y=[];</span><br><span class="line">for x0=x</span><br><span class="line">   if x0&gt;=8</span><br><span class="line">      y=[y,1];</span><br><span class="line">   elseif x0&gt;=6</span><br><span class="line">      y=[y,5-x0/2];</span><br><span class="line">   elseif x0&gt;=4</span><br><span class="line">      y=[y,2];</span><br><span class="line">   elseif x0&gt;=0</span><br><span class="line">      y=[y,sqrt(x0)];</span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line">plot(x,y)</span><br><span class="line">axis([0 10 0 2.5])            %设置坐标轴</span><br><span class="line">title(&#x27;分段函数曲线&#x27;);          %加图形标题</span><br><span class="line">xlabel(&#x27;Variable X&#x27;);         %加X轴说明</span><br><span class="line">ylabel(&#x27;Variable Y&#x27;);         %加Y轴说明</span><br><span class="line">text(2,1.3,&#x27;y=x^&#123;1/2&#125;&#x27;);      %在指定位置添加图形说明</span><br><span class="line">text(4.5,1.9,&#x27;y=2&#x27;);</span><br><span class="line">text(7.3,1.5,&#x27;y=5-x/2&#x27;);</span><br><span class="line">text(8.5,0.9,&#x27;y=1&#x27;);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214720.png"></p><p><strong>3.图形保持</strong><br>一般情况下，绘图命令每执行一次就刷新当前图形窗口，图形窗口原有图形将不复存在。若希望在已存在的图形上再继续添加新的图形，可使用图形保持命令hold。hold on/off命令控制是保持原有图形还是刷新原有图形，不带参数的hold命令在两种状态之间进行切换。 </p><p>例5-6  用图形保持功能在同一坐标内绘制曲线<img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214725.png">)及其包络线。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x=(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>)&#x27;;</span><br><span class="line">y1=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x)*[<span class="number">1</span>,<span class="number">-1</span>];</span><br><span class="line">y2=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);</span><br><span class="line"><span class="built_in">plot</span>(x,y1,<span class="string">&#x27;b:&#x27;</span>);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-2</span>,<span class="number">2</span>]);        <span class="comment">%设置坐标</span></span><br><span class="line"><span class="built_in">hold</span> on;        <span class="comment">%设置图形保持状态</span></span><br><span class="line"><span class="built_in">plot</span>(x,y2,<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;包络线&#x27;</span>,<span class="string">&#x27;包络线&#x27;</span>,<span class="string">&#x27;曲线y&#x27;</span>);       <span class="comment">%加图例</span></span><br><span class="line"><span class="built_in">hold</span> off;        <span class="comment">%关闭图形保持</span></span><br><span class="line">grid              <span class="comment">%网格线控制</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214729.png"></p><p><strong>4.图形窗口的分割</strong><br>subplot函数的调用格式为：<br>subplot(m,n,p)</p><p>例5-7  在一个图形窗口中以子图形式同时绘制正弦、余弦、正切、余切曲线。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">60</span>);</span><br><span class="line">y=<span class="built_in">sin</span>(x);z=<span class="built_in">cos</span>(x);</span><br><span class="line">t=<span class="built_in">sin</span>(x)./(<span class="built_in">cos</span>(x)+<span class="built_in">eps</span>); ct=<span class="built_in">cos</span>(x)./(<span class="built_in">sin</span>(x)+<span class="built_in">eps</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);     </span><br><span class="line"><span class="built_in">plot</span>(x,y);title(<span class="string">&#x27;sin(x)&#x27;</span>);axis ([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-1</span>,<span class="number">1</span>]);            </span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,z);title(<span class="string">&#x27;cos(x)&#x27;</span>);axis ([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-1</span>,<span class="number">1</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,t);title(<span class="string">&#x27;tangent(x)&#x27;</span>);axis ([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-40</span>,<span class="number">40</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,ct);title(<span class="string">&#x27;cotangent(x)&#x27;</span>);axis ([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-40</span>,<span class="number">40</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214733.png"></p><h3 id="5-2-其他形式的二维图形"><a href="#5-2-其他形式的二维图形" class="headerlink" title="5.2  其他形式的二维图形"></a>5.2  其他形式的二维图形</h3><h4 id="5-2-1-对函数自适应采样的绘图函数"><a href="#5-2-1-对函数自适应采样的绘图函数" class="headerlink" title="5.2.1  对函数自适应采样的绘图函数"></a>5.2.1  对函数自适应采样的绘图函数</h4><p>fplot函数的调用格式为：   </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fplot(fname,lims,tol,选项)</span><br></pre></td></tr></table></figure><p>例8 用fplot函数绘制f(x)=cos(tan(πx))的曲线。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fplot(@(x)<span class="built_in">cos</span>(<span class="built_in">tan</span>(<span class="built_in">pi</span>*x)),[<span class="number">0</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h4 id="5-2-2-其他坐标系下的二维曲线图"><a href="#5-2-2-其他坐标系下的二维曲线图" class="headerlink" title="5.2.2  其他坐标系下的二维曲线图"></a>5.2.2  其他坐标系下的二维曲线图</h4><p><strong>1．对数坐标图形</strong><br>    MATLAB提供了绘制对数和半对数坐标曲线的函数，调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semilogx(x1,y1,选项<span class="number">1</span>,x2,y2,选项<span class="number">2</span>,…)</span><br><span class="line">semilogy(x1,y1,选项<span class="number">1</span>,x2,y2,选项<span class="number">2</span>,…)</span><br><span class="line">loglog(x1,y1,选项<span class="number">1</span>,x2,y2,选项<span class="number">2</span>,…)</span><br></pre></td></tr></table></figure><p>​    例9  绘制<img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214739.png">的对数坐标图并与直角线性坐标图进行比较。<br>​    程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">y=<span class="number">10</span>*x.*x;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y);title(<span class="string">&#x27;plot(x,y)&#x27;</span>);grid on;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">semilogx(x,y);title(<span class="string">&#x27;semilogx(x,y)&#x27;</span>);grid on;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">semilogy(x,y);title(<span class="string">&#x27;semilogy(x,y)&#x27;</span>);grid on;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">loglog(x,y);title(<span class="string">&#x27;loglog(x,y)&#x27;</span>);grid on; </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116215250.png"></p><p><strong>2．极坐标图</strong><br>polar函数用来绘制极坐标图，其调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">polar(theta,rho,LineSpec)</span><br></pre></td></tr></table></figure><p>其中theta为极坐标极角，rho为极坐标矢径，选项的内容与plot函数相似。</p><p>例5-10  绘制极坐标图。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214747.png"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">20</span>*<span class="built_in">pi</span>;</span><br><span class="line">r1=<span class="built_in">exp</span>(<span class="built_in">cos</span>(t))<span class="number">-2</span>*<span class="built_in">cos</span>(<span class="number">4</span>*t)+<span class="built_in">sin</span>(t/<span class="number">12</span>).^<span class="number">5</span>;</span><br><span class="line">r2=<span class="built_in">exp</span>(<span class="built_in">cos</span>(t-<span class="built_in">pi</span>/<span class="number">2</span>))<span class="number">-2</span>*<span class="built_in">cos</span>(<span class="number">4</span>*(t-<span class="built_in">pi</span>/<span class="number">2</span>))+<span class="built_in">sin</span>((t-<span class="built_in">pi</span>/<span class="number">2</span>)/<span class="number">12</span>).^<span class="number">5</span>;</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">polar(t,r1);title(<span class="string">&#x27;蝴蝶曲线&#x27;</span>);    <span class="comment">%绘制蝴蝶曲线</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">polar(t,r2);title(<span class="string">&#x27;旋转90度的蝴蝶曲线&#x27;</span>);    <span class="comment">%旋转90度的蝴蝶曲线</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214752.png"></p><h4 id="5-2-3-其他特殊二维图形"><a href="#5-2-3-其他特殊二维图形" class="headerlink" title="5.2.3  其他特殊二维图形"></a>5.2.3  其他特殊二维图形</h4><h5 id="1-其他形式的线性直角坐标图"><a href="#1-其他形式的线性直角坐标图" class="headerlink" title="1.其他形式的线性直角坐标图"></a><strong>1.其他形式的线性直角坐标图</strong></h5><p>在线性直角坐标系中，其他形式的图形有条形图、阶梯图、杆图和填充图等<br><strong>(1) 条形类图形</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar(y)</span><br><span class="line">bar(x,y,选项)</span><br></pre></td></tr></table></figure><p>例11  条形图应用示例。<br>程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">-1</span>:<span class="number">1</span>;  y=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);bar(x,y,<span class="string">&#x27;grouped&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Group&#x27;</span>);axis([<span class="number">-3</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>])</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);barh(x,y,<span class="string">&#x27;stacked&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Stack&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214756.png"></p><p><strong>（2）直方图</strong><br>在MATLAB中，绘制直方图的函数有两个：hist函数和rose函数，分别用于绘制直角坐标系下的直方图和极坐标系下的直方图，后者也称为玫瑰花图。<br>hist函数的应用更为广泛一些，其调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist(y[,x])</span><br></pre></td></tr></table></figure><p>例12  绘制服从高斯分布的直方图，再将这些数据分到指定范围的区间中，并绘制直方图中。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y=<span class="built_in">randn</span>(<span class="number">500</span>,<span class="number">1</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">hist(y);title(<span class="string">&#x27;高斯分布直方图&#x27;</span>)</span><br><span class="line">x=<span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">hist(y,x);title(<span class="string">&#x27;指定范围的高斯分布直方图&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214821.png"></p><p>rose函数的调用格式与hist函数非常相似，调用方法如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rose(theta[,x])</span><br></pre></td></tr></table></figure><p>例13  绘制例5-12中高斯分布数据在极坐标下的直方图。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y=<span class="built_in">randn</span>(<span class="number">500</span>,<span class="number">1</span>);</span><br><span class="line">theta=y*<span class="built_in">pi</span>;</span><br><span class="line">rose(theta)</span><br><span class="line">title(<span class="string">&#x27;在极坐标下的直方图&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214828.png"></p><h5 id="2．面积类图形"><a href="#2．面积类图形" class="headerlink" title="2．面积类图形"></a><strong>2．面积类图形</strong></h5><p><strong>（1）扇形统计图</strong><br>扇形统计图又称为饼图，反映一个数据系列中各个分量在总数量中所占的比重。MATLAB提供了pie函数来绘制扇形统计图，其调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pie(x,explode)</span><br></pre></td></tr></table></figure><p>例14  某次考试优秀、良好、中等、及格、不及格的人数分别为：7、17、23、19、5，试用扇形统计图作成绩统计分析。<br>程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pie([<span class="number">7</span>,<span class="number">17</span>,<span class="number">23</span>,<span class="number">19</span>,<span class="number">5</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>])   <span class="comment">%对应第5分量部分从饼图中心分离</span></span><br><span class="line">title(<span class="string">&#x27;饼图&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;优秀&#x27;</span>,<span class="string">&#x27;良好&#x27;</span>,<span class="string">&#x27;中等&#x27;</span>,<span class="string">&#x27;及格&#x27;</span>,<span class="string">&#x27;不及格&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214833.png"></p><p>注意：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pie([<span class="number">7</span>,<span class="number">17</span>,<span class="number">23</span>,<span class="number">19</span>,<span class="number">5</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>])  <span class="comment">%中1对应的是将5%突出、分开</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pie([<span class="number">7</span>,<span class="number">17</span>,<span class="number">23</span>,<span class="number">19</span>,<span class="number">5</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>])   <span class="comment">%对应第5分量部分从饼图中心分离</span></span><br><span class="line">title(<span class="string">&#x27;饼图&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;优秀&#x27;</span>,<span class="string">&#x27;良好&#x27;</span>,<span class="string">&#x27;中等&#x27;</span>,<span class="string">&#x27;及格&#x27;</span>,<span class="string">&#x27;不及格&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214837.png"></p><p><strong>（2）面积统计图</strong><br>面积统计图反映数量变化的趋势，在实际中可以表现不同部分对整体的影响。在MATLAB中，绘制面积统计图的函数是area，其调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">① area(x)。</span><br><span class="line">② area(x,y)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span>:<span class="number">2</span>:<span class="number">9</span>;</span><br><span class="line">y=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>;<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">2</span>]&#x27;;</span><br><span class="line">area(x,y);</span><br><span class="line">grid on;title(<span class="string">&#x27;面积统计图&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214841.png"></p><p><strong>（3）实心图</strong><br>实心图是将数据的起点和终点连成多边形，并填充颜色。绘制实心图的函数是fill，其调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill(x,y,颜色)</span><br></pre></td></tr></table></figure><p>例15  绘制一个红色的正八边形。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="number">0</span>:<span class="number">2</span>*<span class="built_in">pi</span>/<span class="number">8</span>:<span class="number">2</span>*<span class="built_in">pi</span>; <span class="comment">%取正八边形坐标点</span></span><br><span class="line">t=[t,t(<span class="number">1</span>)];      <span class="comment">%数据向量的首尾重合，使图形封闭。</span></span><br><span class="line">x=<span class="built_in">sin</span>(t);</span><br><span class="line">y=<span class="built_in">cos</span>(t);</span><br><span class="line">fill(x,y,<span class="string">&#x27;r&#x27;</span>)    <span class="comment">%x、y是圆周坐标，数据间隔足够小时可以画圆</span></span><br><span class="line">axis equal;axis([<span class="number">-1.5</span>,<span class="number">1.5</span>,<span class="number">-1.5</span>,<span class="number">1.5</span>])</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214845.png"></p><h5 id="3．散点类图形"><a href="#3．散点类图形" class="headerlink" title="3．散点类图形"></a><strong>3．散点类图形</strong></h5><p>MATLAB提供了绘制散点类图形的函数scatter、stairs和stem，分别用于绘制散点图、阶梯图和杆图。3个函数的调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scatter</span>(x,y[,<span class="string">&#x27;filled&#x27;</span>][,颜色])</span><br><span class="line">stairs(x,y,选项)</span><br><span class="line">stem(x,y,选项)</span><br></pre></td></tr></table></figure><p>例16  分别以散点图、阶梯图和杆图形式绘制曲线<img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116221019.png"><br>程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; x=<span class="number">0</span>:<span class="number">0.35</span>:<span class="number">7</span>;y=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>);<span class="built_in">scatter</span>(x,y,<span class="string">&#x27;g&#x27;</span>);title(<span class="string">&#x27;scatter(x,y,&#x27;&#x27;g&#x27;&#x27;)&#x27;</span>);axis([<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>);stairs(x,y,<span class="string">&#x27;b&#x27;</span>);title(<span class="string">&#x27;stairs(x,y,&#x27;&#x27;b&#x27;&#x27;)&#x27;</span>);axis([<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>);stem(x,y,<span class="string">&#x27;k&#x27;</span>);title(<span class="string">&#x27;stem(x,y,&#x27;&#x27;k&#x27;&#x27;)&#x27;</span>);axis([<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116215133.png"></p><p>例17<img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214855.png"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">x = <span class="number">16</span>*<span class="built_in">sin</span>(t).^<span class="number">3</span>;</span><br><span class="line">y = <span class="number">13</span>*<span class="built_in">cos</span>(t) - <span class="number">5</span>*<span class="built_in">cos</span>(<span class="number">2</span>*t) - <span class="number">2</span>*<span class="built_in">cos</span>(<span class="number">3</span>*t) - <span class="built_in">cos</span>(<span class="number">4</span>*t);</span><br><span class="line"><span class="built_in">scatter</span>(x,y,<span class="string">&#x27;rd&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214858.png"></p><h5 id="4．矢量类图形"><a href="#4．矢量类图形" class="headerlink" title="4．矢量类图形"></a>4．矢量类图形</h5><p><strong>（1）罗盘图</strong><br>罗盘图表示起点为坐标原点的向量，同时还在坐标系中显示圆形的分隔线。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">① compass(x,y) 。</span><br><span class="line">② compass(z) </span><br></pre></td></tr></table></figure><p><strong>（2）羽毛图</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">① feather(x,y) 。</span><br><span class="line">② feather(z) 。</span><br></pre></td></tr></table></figure><p><strong>（3）箭头图</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quiver([x,y,]u,v)</span><br></pre></td></tr></table></figure><p>例18  分别以罗盘图、羽毛图和箭头图形式绘制绘制正弦曲线。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x=-<span class="built_in">pi</span>:<span class="built_in">pi</span>/<span class="number">8</span>:<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="built_in">sin</span>(x);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);compass(x,y)</span><br><span class="line">title(<span class="string">&#x27;罗盘图&#x27;</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);feather(x,y)</span><br><span class="line">title(<span class="string">&#x27;羽毛图&#x27;</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);quiver(x,y)</span><br><span class="line">title(<span class="string">&#x27;箭头图&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116215110.png"></p><h3 id="5-3-三维图形"><a href="#5-3-三维图形" class="headerlink" title="5.3  三维图形"></a>5.3  三维图形</h3><h4 id="5-3-1-绘制三维曲线的基本函数"><a href="#5-3-1-绘制三维曲线的基本函数" class="headerlink" title="5.3.1  绘制三维曲线的基本函数"></a>5.3.1  绘制三维曲线的基本函数</h4><p>​    plot3将二维绘图函数plot的有关功能扩展到三维空间。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot3</span>(x1,y1,z1,选项<span class="number">1</span>,x2,y2,z2,选项<span class="number">2</span>,…,xn,yn,zn,选项n)</span><br></pre></td></tr></table></figure><p>例5-18   绘制空间曲线。<img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214910.png"></p><p>先求出曲线所对应的参数方程：<img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214914.png"></p><p>程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">  x=<span class="number">8</span>*<span class="built_in">cos</span>(t);</span><br><span class="line">  y=<span class="number">4</span>*<span class="built_in">sqrt</span>(<span class="number">2</span>)*<span class="built_in">sin</span>(t);</span><br><span class="line">  z=<span class="number">-4</span>*<span class="built_in">sqrt</span>(<span class="number">2</span>)*<span class="built_in">sin</span>(t);</span><br><span class="line">  <span class="built_in">plot3</span>(x,y,z,<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">  title(<span class="string">&#x27;Line in 3-D Space&#x27;</span>);text(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;origin&#x27;</span>);</span><br><span class="line">  xlabel(<span class="string">&#x27;X&#x27;</span>),ylabel(<span class="string">&#x27;Y&#x27;</span>),zlabel(<span class="string">&#x27;Z&#x27;</span>);grid;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214918.png"></p><h4 id="5-3-2-三维曲面"><a href="#5-3-2-三维曲面" class="headerlink" title="5.3.2  三维曲面"></a>5.3.2  三维曲面</h4><h5 id="1．平面网格坐标矩阵的生成"><a href="#1．平面网格坐标矩阵的生成" class="headerlink" title="1．平面网格坐标矩阵的生成"></a>1．平面网格坐标矩阵的生成</h5><p>(1)利用矩阵运算生成。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=a:dx:b; y=(c:dy:d)&#x27;;</span><br><span class="line">X=<span class="built_in">ones</span>(<span class="built_in">size</span>(y))*x;</span><br><span class="line">Y=y*<span class="built_in">ones</span>(<span class="built_in">size</span>(x));</span><br></pre></td></tr></table></figure><p>(2)利用meshgrid函数生成。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=a:dx:b; y=c:dy:d;</span><br><span class="line">[X,Y]=<span class="built_in">meshgrid</span>(x,y);</span><br></pre></td></tr></table></figure><p>例19  已知6&lt;x&lt;30，15&lt;y&lt;36，求不定方程2x+5y=126的整数解。<br>程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">7</span>:<span class="number">29</span>;</span><br><span class="line">y=<span class="number">16</span>:<span class="number">35</span>;</span><br><span class="line">[x,y]=<span class="built_in">meshgrid</span>(x,y);  <span class="comment">%在[7,29]×[16,35]区域生成网格坐标</span></span><br><span class="line">z=<span class="number">2</span>*x+<span class="number">5</span>*y;</span><br><span class="line">k=<span class="built_in">find</span>(z==<span class="number">126</span>);        <span class="comment">%找出解的位置   </span></span><br><span class="line">x(k)&#x27;,y(k)&#x27;             <span class="comment">%输出对应位置的x,y即方程的解</span></span><br></pre></td></tr></table></figure><h5 id="2-绘制三维曲面的函数"><a href="#2-绘制三维曲面的函数" class="headerlink" title="2.绘制三维曲面的函数"></a>2.绘制三维曲面的函数</h5><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mesh(x,y,z,c)</span><br><span class="line">surf(x,y,z,c)</span><br></pre></td></tr></table></figure><p>例20  用三维曲面图z=sin(y)cos(x)。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%程序1：</span></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;[x,y]=<span class="built_in">meshgrid</span>(x);z=<span class="built_in">sin</span>(y).*<span class="built_in">cos</span>(x);</span><br><span class="line">mesh(x,y,z);xlabel(<span class="string">&#x27;x-axis&#x27;</span>),ylabel(<span class="string">&#x27;y-axis&#x27;</span>),zlabel(<span class="string">&#x27;z-axis&#x27;</span>);title(<span class="string">&#x27;mesh&#x27;</span>);</span><br><span class="line"><span class="comment">%程序2：</span></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;[x,y]=<span class="built_in">meshgrid</span>(x);z=<span class="built_in">sin</span>(y).*<span class="built_in">cos</span>(x);</span><br><span class="line">surf(x,y,z);xlabel(<span class="string">&#x27;x-axis&#x27;</span>),ylabel(<span class="string">&#x27;y-axis&#x27;</span>),zlabel(<span class="string">&#x27;z-axis&#x27;</span>);title(<span class="string">&#x27;surf&#x27;</span>);</span><br><span class="line"><span class="comment">%程序3：</span></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;[x,y]=<span class="built_in">meshgrid</span>(x);z=<span class="built_in">sin</span>(y).*<span class="built_in">cos</span>(x);</span><br><span class="line"><span class="built_in">plot3</span>(x,y,z);xlabel(<span class="string">&#x27;x-axis&#x27;</span>),ylabel(<span class="string">&#x27;y-axis&#x27;</span>),zlabel(<span class="string">&#x27;z-axis&#x27;</span>);title(<span class="string">&#x27;plot3-1&#x27;</span>);grid;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214922.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214926.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116215015.png"></p><p>例21  绘制两个直径相等的圆管的相交图形。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="number">30</span>;z=<span class="number">1.2</span>*(<span class="number">0</span>:m)/m;r=<span class="built_in">ones</span>(<span class="built_in">size</span>(z));theta=(<span class="number">0</span>:m)/m*<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">x1=r&#x27;*<span class="built_in">cos</span>(theta);                  <span class="comment">%生成第一个圆柱体的坐标矩阵</span></span><br><span class="line">y1=r&#x27;*<span class="built_in">sin</span>(theta);    </span><br><span class="line">z1=z&#x27;*<span class="built_in">ones</span>(<span class="number">1</span>,m+<span class="number">1</span>);</span><br><span class="line">x=(-m:<span class="number">2</span>:m)/m;</span><br><span class="line">x2=x&#x27;*<span class="built_in">ones</span>(<span class="number">1</span>,m+<span class="number">1</span>);                <span class="comment">%生成第二个圆柱体的坐标矩阵</span></span><br><span class="line">y2=r&#x27;*<span class="built_in">cos</span>(theta); </span><br><span class="line">z2=r&#x27;*<span class="built_in">sin</span>(theta);</span><br><span class="line">surf(x1,y1,z1)                  <span class="comment">%绘制垂直的圆柱体</span></span><br><span class="line">axis equal,axis off</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">surf(x2,y2,z2)                 <span class="comment">%绘制水平的圆柱体</span></span><br><span class="line">axis equal,axis off</span><br><span class="line">title(<span class="string">&#x27;两个圆柱体的相交图形&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214933.png"></p><h5 id="3-标准三维曲面"><a href="#3-标准三维曲面" class="headerlink" title="3.标准三维曲面"></a>3.标准三维曲面</h5><p>sphere函数的调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x,y,z]=sphere(n)</span><br></pre></td></tr></table></figure><p>cylinder函数的调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x,y,z]=sphere(R,n)</span><br></pre></td></tr></table></figure><p>MATLAB还有一个peaks 函数，称为多峰函数，常用于三维曲面的演示。</p><h4 id="5-2-3-其他三维图形"><a href="#5-2-3-其他三维图形" class="headerlink" title="5.2.3  其他三维图形"></a>5.2.3  其他三维图形</h4><p>1．三维条形图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar3(y)</span><br><span class="line">bar3(x,y)</span><br></pre></td></tr></table></figure><p>2．三维饼图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pie3(x,explode)</span><br></pre></td></tr></table></figure><p>3．三维实心图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill3(x,y,z,c)</span><br></pre></td></tr></table></figure><p>4．三维散点图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scatter3</span>(x,y,z,c)</span><br></pre></td></tr></table></figure><p>5．三维杆图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stem3(z)</span><br><span class="line">stem3(x,y,z)</span><br></pre></td></tr></table></figure><p>6．三维箭头图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quiver3(x,y,z,u,v,w)</span><br></pre></td></tr></table></figure><p>例22  绘制三维图形：<br>(1)绘制魔方阵的三维条形图。<br>(2)以三维杆图形式绘制曲线y=2sin(x)。<br>(3)已知x=[2347,1827,2043,3025]，绘制三维饼图。<br>(4)用随机的顶点坐标值画出五个黄色三角形。<br>程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">bar3(<span class="built_in">magic</span>(<span class="number">4</span>))</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">y=<span class="number">2</span>*<span class="built_in">sin</span>(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">10</span>:<span class="number">2</span>*<span class="built_in">pi</span>);</span><br><span class="line">stem3(y);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">pie3([<span class="number">2347</span>,<span class="number">1827</span>,<span class="number">2043</span>,<span class="number">3025</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">fill3(<span class="built_in">rand</span>(<span class="number">3</span>,<span class="number">5</span>),<span class="built_in">rand</span>(<span class="number">3</span>,<span class="number">5</span>),<span class="built_in">rand</span>(<span class="number">3</span>,<span class="number">5</span>), <span class="string">&#x27;y&#x27;</span> )</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab5/20211116214938.png"></p>]]></content>
      
      
      <categories>
          
          <category> MATLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六、C++11新特性：final/override关键字</title>
      <link href="/2021/11/16/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/6%E3%80%81finaloverride%E6%8E%A7%E5%88%B6/"/>
      <url>/2021/11/16/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/6%E3%80%81finaloverride%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h2 id="final-override控制"><a href="#final-override控制" class="headerlink" title="final/override控制"></a>final/override控制</h2><blockquote><p>声明：该笔记是在学习《深入理解C++11》、《C++11/14高级编程 Boost程序库探秘》时做的总结，方便以后巩固复习！</p></blockquote><p>函数重载的概念：</p><p>一个类A中声明的虚函数fun在其派生类B中再次被定义，且B中的函数fun跟A中fun的原型一样（函数名、参数列表等一样），那么我们就称B重载（overload）了A的fun函数。</p><h3 id="final关键字的作用"><a href="#final关键字的作用" class="headerlink" title="final关键字的作用"></a>final关键字的作用</h3><p><strong>限制某个类不能被继承，或者某个虚函数不能被重写</strong></p><blockquote><p>使用 <code>final</code> 修饰函数，只能修饰虚函数，并且要把<code>final</code>关键字放到类或者函数的后面。</p><p>使用<code>final</code>关键字修饰过的类是不允许被继承的，也就是说这个类不能有派生类。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Object class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> :</span> <span class="keyword">public</span> object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 语法错误, 不允许重写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>派生于Object的Base类重载了Object的fun接口，并将本类中的fun函数声明为<code>final</code>的。那么派生于Base的Derived类对接口fun的重载则会导致编译时的错误。</p></blockquote><h3 id="override关键字的作用"><a href="#override关键字的作用" class="headerlink" title="override关键字的作用"></a>override关键字的作用</h3><blockquote><p><code>override</code> 关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，这样可以保证重写的虚函数的正确性，提高代码的可读性。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Turing</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">VNeumann</span><span class="params">(<span class="keyword">int</span> g)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DKnuth</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DerivedMid</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// void VNeumann(double g);</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DerivedTop</span> :</span> <span class="keyword">public</span> DerivedMid</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Turing</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dikjstra</span><span class="params">()</span> <span class="keyword">override</span></span>;              <span class="comment">// 无法通过编译，拼写错误，并非重载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VNeumann</span><span class="params">(<span class="keyword">double</span> g)</span> <span class="keyword">override</span></span>;      <span class="comment">// 无法通过编译，参数不一致，并非重载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DKnuth</span><span class="params">()</span> <span class="keyword">override</span></span>;                <span class="comment">// 无法通过编译，常量性不一致，并非重载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">override</span></span>;                 <span class="comment">// 无法通过编译，非虚函数重载</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>从上例中可以看出使用<code>override</code>后，假设在重写过程中因为误操作，写错了函数名或者函数参数或者返回值或者常量性；编译器都会提示语法错误，提高了程序的正确性，降低了出错的概率。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、C++11新特性：追踪返回类型</title>
      <link href="/2021/11/15/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/5%E3%80%81%E8%BF%BD%E8%B8%AA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B/"/>
      <url>/2021/11/15/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/5%E3%80%81%E8%BF%BD%E8%B8%AA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h2 id="四、追踪返回类型"><a href="#四、追踪返回类型" class="headerlink" title="四、追踪返回类型"></a>四、追踪返回类型</h2><blockquote><p>声明：该笔记是在学习《深入理解C++11》、《C++11/14高级编程 Boost程序库探秘》时做的总结，方便以后巩固复习！</p></blockquote><h3 id="引入追踪返回类型的目的："><a href="#引入追踪返回类型的目的：" class="headerlink" title="引入追踪返回类型的目的："></a>引入追踪返回类型的目的：</h3><p><strong>追踪返回类型配合<code>auto</code>与<code>decltype</code>会真正释放C++11中泛型编程的能力；简化函数的定义，提高代码的可读性。</strong></p><p>对返回类型进行类型推导书写方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(t1 + t2)</span> <span class="title">Sum</span><span class="params">(T1 &amp; t1, T2 &amp; t2)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样的写法虽然看似不错，不过对编译器来说有些小问题。编译器在推导<code>decltype(t1 + t2)</code>时的，表达</p><p>式中的<code>t1</code>和<code>t2</code>都未声明；<strong>而变量使用前必须已经声明</strong>。</p></blockquote><p>为了解决变量使用前必须已经声明这个问题，C++11引入了新语法——<code>追踪返回类型</code>，来声明和定义这样的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(T1 &amp; t1, T2 &amp; t2)</span> -&gt; <span class="title">decltype</span><span class="params">(t1 + t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>把函数的返回值移至参数声明之后，复合符号<code>-&gt; decltype(t1 + t2)</code>被称为<code>追踪返回类型</code>。而原本函数返回值的位置由<code>auto</code>关键字占据。这样，我们就可以让编译器来推导Sum函数模板的返回类型了。而<code>auto占位符</code>和<code>-&gt;return_type</code>也就是构成追踪返回类型函数的两个基本元素。</p></blockquote><h3 id="使用追踪返回类型的函数"><a href="#使用追踪返回类型的函数" class="headerlink" title="使用追踪返回类型的函数"></a>使用追踪返回类型的函数</h3><p>参数的类型和返回值都可在实例化时再确定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(<span class="keyword">const</span> T1 &amp; t1, <span class="keyword">const</span> T2 &amp; t2)</span> -&gt; <span class="title">decltype</span><span class="params">(t1 + t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Mul</span><span class="params">(<span class="keyword">const</span> T1 &amp; t1, <span class="keyword">const</span> T2 &amp; t2)</span> -&gt; <span class="title">decltype</span><span class="params">(t1 * t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t1 * t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">4L</span>;</span><br><span class="line">    <span class="keyword">auto</span> pi = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="built_in">Sum</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; c &lt;&lt; endl;   </span><br><span class="line">    <span class="keyword">auto</span> d = <span class="built_in">Mul</span>(c, pi);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;   </span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="number">7</span></span><br><span class="line">d = <span class="number">21.98</span></span><br></pre></td></tr></table></figure><blockquote><p>定义了两个模板函数Sum和Mul，它们的参数的类型和返回值都在实例化时决定。而由于main函数中还使用了auto，整个例子中没有看到一个“具体”的类型声明。</p><p>auto 会追踪 decltype() 推导出的类型。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、无人驾驶--路径规划算法：Dijkstra</title>
      <link href="/2021/11/13/7%E3%80%81%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/2%E3%80%81%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6-%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%EF%BC%9ADijkstra/"/>
      <url>/2021/11/13/7%E3%80%81%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/2%E3%80%81%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6-%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%EF%BC%9ADijkstra/</url>
      
        <content type="html"><![CDATA[<h3 id="2、Dijkstra"><a href="#2、Dijkstra" class="headerlink" title="2、Dijkstra"></a>2、Dijkstra</h3><h4 id="2-1、算法简介"><a href="#2-1、算法简介" class="headerlink" title="2.1、算法简介"></a>2.1、算法简介</h4><p>迪杰斯特拉算法是由荷兰计算机科学家狄克斯特拉于1959年提出的，因此又称为狄克斯特拉算法；</p><p>它是从一个节点遍历其余各个节点的最短路径算法，解决的是有权图中最短路径问题。</p><p>主要特点：从起点开始，采用贪心算法的策略，每次遍历到初始点距离最近且未访问过的顶点的邻接点，直到扩展到终点为止。</p><h4 id="2-2、算法思路"><a href="#2-2、算法思路" class="headerlink" title="2.2、算法思路"></a>2.2、算法思路</h4><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161052.png"></p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/路径规划/20211113161110.png"  /><p>如上图G=(V,E)是一个带权有向图，把图中节点集合V分成两组：</p><p>第一组为已经求出最短路径的节点集合（用S表示，初始时S只有一个源点，即：D(0),之后每求得一条最短路径，就将该节点加入到集合S中，指导全部节点都加入到S中，算法就结束了）；第二组为其余未确定最短路径的节点集合（U表示），按最短路径长度的递增次序把第二组的节点加入S中。在加入的过程中，总保持从源点V到S中节点的最短路径长度不大于从源点V到U中任何节点的最短路径长度。</p><p>此外，每个节点对应一个距离,S中的节点的距离就是从V到此节点的最短路径长度,U中的节点的距离，是从V到此节点只包含S中的节点为中间节点的当前最短路径长度。</p><h5 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h5><p>设D为起点，A为终点，找到D~A的最短路径</p><p>1、S中只包含起节点D（0）；U包含除S外的其它节点，如C节点，C与D相邻，所以C（3）表示C到D的距离为3，而F与D不相邻，所以设F到D的距离为∞。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161117.png"></p><p>2、在U中选出最短节点，这里为C（3），将C移到S中，并在U中删除。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161122.png"></p><p>3、按上述方法依次选出，在U中选出最短节点，此时为E（4），将E移到S中，并在U中删除。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161127.png"></p><p>4、此时就要对比D<del>C</del>B=13;D<del>C</del>F=9;D<del>E</del>F=6;D<del>E</del>G=12的距离，所以将F（6）移到S中，并在U中删除；</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161130.png"></p><p>5、依次按照上述方法推算</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161134.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161353.png"></p><p>6、直到U为空集，此时，可以得到最短距离：A(22) = D<del>E</del>F~A =4+2+16；</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161142.png"></p><h4 id="2-3、算法具体实现"><a href="#2-3、算法具体实现" class="headerlink" title="2.3、算法具体实现"></a>2.3、算法具体实现</h4><p>defColorMap.m文件：</p><blockquote><p>作用：生成栅格图</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[field,cmap]</span> = <span class="title">defColorMap</span><span class="params">(rows, cols)</span></span></span><br><span class="line">cmap = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>; ...       <span class="comment">% 1-白色-空地</span></span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; ...           <span class="comment">% 2-黑色-静态障碍</span></span><br><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; ...           <span class="comment">% 3-红色-动态障碍</span></span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>;...            <span class="comment">% 4-黄色-起始点 </span></span><br><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;...            <span class="comment">% 5-品红-目标点</span></span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>; ...           <span class="comment">% 6-绿色-到目标点的规划路径   </span></span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>];              <span class="comment">% 7-青色-动态规划的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 构建颜色MAP图</span></span><br><span class="line">colormap(cmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义栅格地图全域，并初始化空白区域</span></span><br><span class="line">field = <span class="built_in">ones</span>(rows, cols);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 障碍物区域</span></span><br><span class="line">obsRate = <span class="number">0.3</span>;</span><br><span class="line">obsNum = <span class="built_in">floor</span>(rows*cols*obsRate);</span><br><span class="line">obsIndex = randi([<span class="number">1</span>,rows*cols],obsNum,<span class="number">1</span>);</span><br><span class="line">field(obsIndex) = <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>getNeighborNodes.m文件：</p><blockquote><p>作用：搭建个节点之间的关系；实现查找当前父节点临近的周围8个子节点</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">neighborNodes</span> = <span class="title">getNeighborNodes</span><span class="params">(rows, cols, lineIndex, field)</span></span></span><br><span class="line">[row, col] = <span class="built_in">ind2sub</span>([rows,cols], lineIndex);</span><br><span class="line">neighborNodes = <span class="built_in">inf</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 查找当前父节点临近的周围8个子节点</span></span><br><span class="line"><span class="comment">% 左上节点</span></span><br><span class="line"><span class="keyword">if</span> row<span class="number">-1</span> &gt; <span class="number">0</span> &amp;&amp; col<span class="number">-1</span> &gt; <span class="number">0</span></span><br><span class="line">    child_node_sub = [row<span class="number">-1</span>, col<span class="number">-1</span>];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">1</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">1</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 上节点</span></span><br><span class="line"><span class="keyword">if</span> row<span class="number">-1</span> &gt; <span class="number">0</span></span><br><span class="line">    child_node_sub = [row<span class="number">-1</span>, col];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">2</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">2</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 右上节点</span></span><br><span class="line"><span class="keyword">if</span> row<span class="number">-1</span> &gt; <span class="number">0</span> &amp;&amp; col+<span class="number">1</span> &lt;= cols</span><br><span class="line">    child_node_sub = [row<span class="number">-1</span>, col+<span class="number">1</span>];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">3</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">3</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 左节点</span></span><br><span class="line"><span class="keyword">if</span>  col<span class="number">-1</span> &gt; <span class="number">0</span></span><br><span class="line">    child_node_sub = [row, col<span class="number">-1</span>];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">4</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">4</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 右节点</span></span><br><span class="line"><span class="keyword">if</span>  col+<span class="number">1</span> &lt;= cols</span><br><span class="line">    child_node_sub = [row, col+<span class="number">1</span>];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">5</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">5</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 左下节点</span></span><br><span class="line"><span class="keyword">if</span> row+<span class="number">1</span> &lt;= rows &amp;&amp; col<span class="number">-1</span> &gt; <span class="number">0</span></span><br><span class="line">    child_node_sub = [row+<span class="number">1</span>, col<span class="number">-1</span>];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">6</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">6</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 7.下节点</span></span><br><span class="line"><span class="keyword">if</span> row+<span class="number">1</span> &lt;= rows</span><br><span class="line">    child_node_sub = [row+<span class="number">1</span>, col];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">7</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">7</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 8.右下节点</span></span><br><span class="line"><span class="keyword">if</span> row+<span class="number">1</span> &lt;= rows &amp;&amp; col+<span class="number">1</span> &lt;= cols</span><br><span class="line">    child_node_sub = [row+<span class="number">1</span>, col+<span class="number">1</span>];</span><br><span class="line">    child_node_line = <span class="built_in">sub2ind</span>([rows,cols], child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>));</span><br><span class="line">    neighborNodes(<span class="number">8</span>,<span class="number">1</span>) = child_node_line;</span><br><span class="line">    <span class="keyword">if</span> field(child_node_sub(<span class="number">1</span>), child_node_sub(<span class="number">2</span>)) ~= <span class="number">2</span></span><br><span class="line">        cost = norm(child_node_sub - [row, col]);</span><br><span class="line">        neighborNodes(<span class="number">8</span>,<span class="number">2</span>) = cost;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Dijkstra.m文件：</p><blockquote><p>具体的算法实现</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 基于栅格地图的机器人路径规划算法</span></span><br><span class="line"><span class="comment">% 第2节：Dijkstra算法</span></span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 栅格界面、场景定义</span></span><br><span class="line"><span class="comment">% 行数和列数</span></span><br><span class="line">rows = <span class="number">10</span>;</span><br><span class="line">cols = <span class="number">20</span>;</span><br><span class="line">[field,cmap] = defColorMap(rows, cols);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 起点、终点、障碍物区域</span></span><br><span class="line">startPos = <span class="number">2</span>;</span><br><span class="line">goalPos = rows*cols<span class="number">-2</span>;</span><br><span class="line">field(startPos) = <span class="number">4</span>;</span><br><span class="line">field(goalPos) = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 算法初始化</span></span><br><span class="line"><span class="comment">% S/U的第一列表示栅格节点线性索引编号</span></span><br><span class="line"><span class="comment">% 对于S，第二列表示从源节点到本节点已求得的最小距离，不再变更；</span></span><br><span class="line"><span class="comment">% 对于U，第二列表示从源节点到本节点暂时求得的最小距离，可能会变更</span></span><br><span class="line">U(:,<span class="number">1</span>) = (<span class="number">1</span>: rows*cols)&#x27;;</span><br><span class="line">U(:,<span class="number">2</span>) = <span class="built_in">inf</span>;</span><br><span class="line">S = [startPos, <span class="number">0</span>];</span><br><span class="line">U(startPos,:) = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">% 更新起点的邻节点及代价</span></span><br><span class="line">neighborNodes = getNeighborNodes(rows, cols, startPos, field);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">    childNode = neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 判断该子节点是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isinf</span>(childNode)</span><br><span class="line">        idx = <span class="built_in">find</span>(U(:,<span class="number">1</span>) == childNode);</span><br><span class="line">        U(idx,<span class="number">2</span>) = neighborNodes(<span class="built_in">i</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% S集合的最优路径集合</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:rows*cols</span><br><span class="line">    path&#123;<span class="built_in">i</span>,<span class="number">1</span>&#125; = <span class="built_in">i</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">    childNode =  neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isinf</span>(neighborNodes(<span class="built_in">i</span>,<span class="number">2</span>))</span><br><span class="line">        path&#123;childNode,<span class="number">2</span>&#125; = [startPos,neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 循环遍历</span></span><br><span class="line"><span class="keyword">while</span> ~<span class="built_in">isempty</span>(U)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 在U集合找出当前最小距离值的节点,视为父节点，并移除该节点至S集合中</span></span><br><span class="line">    [dist_min, idx] = <span class="built_in">min</span>(U(:,<span class="number">2</span>));</span><br><span class="line">    parentNode = U(idx, <span class="number">1</span>);</span><br><span class="line">    S(<span class="keyword">end</span>+<span class="number">1</span>,:) = [parentNode, dist_min];</span><br><span class="line">    U(idx,:) = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 获得当前节点的临近子节点</span></span><br><span class="line">    neighborNodes = getNeighborNodes(rows, cols, parentNode, field);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 依次遍历邻近子节点，判断是否在U集合中更新邻节点的距离值</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 需要判断的子节点</span></span><br><span class="line">        childNode = neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">        cost = neighborNodes(<span class="built_in">i</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ~<span class="built_in">isinf</span>(childNode)  &amp;&amp; ~<span class="built_in">ismember</span>(childNode, S)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">% 找出U集合中节点childNode的索引值</span></span><br><span class="line">            idx_U = <span class="built_in">find</span>(childNode == U(:,<span class="number">1</span>));            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">% 判断是否更新</span></span><br><span class="line">            <span class="keyword">if</span> dist_min + cost &lt; U(idx_U, <span class="number">2</span>)</span><br><span class="line">                U(idx_U, <span class="number">2</span>) = dist_min + cost;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">% 更新最优路径</span></span><br><span class="line">                path&#123;childNode, <span class="number">2</span>&#125; = [path&#123;parentNode, <span class="number">2</span>&#125;, childNode];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 画栅格界面</span></span><br><span class="line"><span class="comment">% 找出目标最优路径</span></span><br><span class="line">path_opt = path&#123;goalPos,<span class="number">2</span>&#125;;</span><br><span class="line">field(path_opt(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>)) = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 画栅格图</span></span><br><span class="line">image(<span class="number">1.5</span>,<span class="number">1.5</span>,field);</span><br><span class="line">grid on;</span><br><span class="line">set(gca,<span class="string">&#x27;gridline&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;gridcolor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;GridAlpha&#x27;</span>,<span class="number">0.5</span>);</span><br><span class="line">set(gca,<span class="string">&#x27;xtick&#x27;</span>,<span class="number">1</span>:cols+<span class="number">1</span>,<span class="string">&#x27;ytick&#x27;</span>,<span class="number">1</span>:rows+<span class="number">1</span>);</span><br><span class="line">axis image;</span><br></pre></td></tr></table></figure><h5 id="2-3-1、程序详解"><a href="#2-3-1、程序详解" class="headerlink" title="2.3.1、程序详解"></a>2.3.1、程序详解</h5><p>①、 算法初始化</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 算法初始化</span></span><br><span class="line"><span class="comment">% S/U的第一列表示栅格节点线性索引编号</span></span><br><span class="line"><span class="comment">% 对于S，第二列表示从源节点到本节点已求得的最小距离，不再变更；</span></span><br><span class="line"><span class="comment">% 对于U，第二列表示从源节点到本节点暂时求得的最小距离，可能会变更</span></span><br><span class="line">U(:,<span class="number">1</span>) = (<span class="number">1</span>: rows*cols)&#x27;;</span><br><span class="line">U(:,<span class="number">2</span>) = <span class="built_in">inf</span>;</span><br><span class="line">S = [startPos, <span class="number">0</span>];</span><br><span class="line">U(startPos,:) = [];</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对U集合进程初始化，生成如下表，第一列未线性索引值，第二列为距离都设为∞</span><br><span class="line">U(:,<span class="number">1</span>) = (<span class="number">1</span>: rows*cols)&#x27;;</span><br><span class="line">U(:,<span class="number">2</span>) = <span class="built_in">inf</span>;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/路径规划/20211113161153.png" style="zoom:50%;" /><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%将初始节点放入S集合中，并设置它的距离为0；再U集合中删除初始节点！</span></span><br><span class="line">S = [startPos, <span class="number">0</span>];</span><br><span class="line">U(startPos,:) = [];</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161156.png"></p><p>②、更新起点的邻节点及代价</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 更新起点的邻节点及代价</span></span><br><span class="line">neighborNodes = getNeighborNodes(rows, cols, startPos, field);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">    childNode = neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 判断该子节点是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isinf</span>(childNode)</span><br><span class="line">        idx = <span class="built_in">find</span>(U(:,<span class="number">1</span>) == childNode);</span><br><span class="line">        U(idx,<span class="number">2</span>) = neighborNodes(<span class="built_in">i</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里调用了getNeighborNodes函数实现查找当前父节点临近的周围8个子节点</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161201.png"></p><blockquote><p>有三种情况：</p><p>①、两列都为inf，即这个节点不存在；</p><p>②、两个都是数字，即此节点存在，且为自由空间（可以走的节点）；</p><p>③、第一列是数字，第二列是inf，即此节点为障碍物</p></blockquote><p><code>for i = 1:8</code>；之后进行8次循环，判断该子节点是否存在，如果子节点存在，则将从父节点到子节点的距离存放到U集合中；</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161205.png"></p><blockquote><p>如上图中D是父节点，它有两个子节点C和E，那么就要再U集合中更新D到这两个节点的距离为3和4。</p></blockquote><p>③、S集合的最优路径集合</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% S集合的最优路径集合</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:rows*cols</span><br><span class="line">    path&#123;<span class="built_in">i</span>,<span class="number">1</span>&#125; = <span class="built_in">i</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">    childNode =  neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isinf</span>(neighborNodes(<span class="built_in">i</span>,<span class="number">2</span>))</span><br><span class="line">        path&#123;childNode,<span class="number">2</span>&#125; = [startPos,neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里是生成初始节点的最优路径</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161210.png"></p><p>④、进行循环，循环的条件是U集合不为空</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ~<span class="built_in">isempty</span>(U)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 在U集合找出当前最小距离值的节点,视为父节点，并移除该节点至S集合中</span></span><br><span class="line">    [dist_min, idx] = <span class="built_in">min</span>(U(:,<span class="number">2</span>));</span><br><span class="line">    parentNode = U(idx, <span class="number">1</span>);</span><br><span class="line">    S(<span class="keyword">end</span>+<span class="number">1</span>,:) = [parentNode, dist_min];</span><br><span class="line">    U(idx,:) = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 获得当前节点的临近子节点</span></span><br><span class="line">    neighborNodes = getNeighborNodes(rows, cols, parentNode, field);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 依次遍历邻近子节点，判断是否在U集合中更新邻节点的距离值</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 需要判断的子节点</span></span><br><span class="line">        childNode = neighborNodes(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">        cost = neighborNodes(<span class="built_in">i</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ~<span class="built_in">isinf</span>(childNode)  &amp;&amp; ~<span class="built_in">ismember</span>(childNode, S)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">% 找出U集合中节点childNode的索引值</span></span><br><span class="line">            idx_U = <span class="built_in">find</span>(childNode == U(:,<span class="number">1</span>));            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">% 判断是否更新</span></span><br><span class="line">            <span class="keyword">if</span> dist_min + cost &lt; U(idx_U, <span class="number">2</span>)</span><br><span class="line">                U(idx_U, <span class="number">2</span>) = dist_min + cost;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">% 更新最优路径</span></span><br><span class="line">                path&#123;childNode, <span class="number">2</span>&#125; = [path&#123;parentNode, <span class="number">2</span>&#125;, childNode];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>得出个节点的距离值，进行排序后得到最优路径！</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161215.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/20211113161221.png"></p><p>Dijkstra算法动态效果实现图：</p><p><img src="G:\我的程序人生\无人驾驶学习\文章总结\无人驾驶公司汇总\2.gif" alt="2"></p>]]></content>
      
      
      <categories>
          
          <category> 路径规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、C++ STL--标准模板库：vector容器</title>
      <link href="/2021/11/13/1%E3%80%81C++/3.C++%20STL/2%E3%80%81C++%20STL%EF%BC%9Avector%E5%AE%B9%E5%99%A8/"/>
      <url>/2021/11/13/1%E3%80%81C++/3.C++%20STL/2%E3%80%81C++%20STL%EF%BC%9Avector%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h3 id="3-2、vector容器"><a href="#3-2、vector容器" class="headerlink" title="3.2、vector容器"></a>3.2、vector容器</h3><blockquote><p>声明：本文是在学习C++ STL–标准模板库的笔记，方便以后复习；主要参考《C++ Prime》、《C++标准库》、<a href="https://www.bilibili.com/video/BV1et411b73Z?from=search&seid=4506595258355469787&spm_id_from=333.337.0.0">《黑马程序员匠心之作|C++教程从0到1入门编程》</a>等。</p></blockquote><h4 id="3-2-1、-vector基本概念"><a href="#3-2-1、-vector基本概念" class="headerlink" title="3.2.1、 vector基本概念"></a>3.2.1、 vector基本概念</h4><p><strong>功能：</strong></p><ul><li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li></ul><p><strong>vector与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong></p><ul><li><strong>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</strong></li><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><p>使用vector前，必须包含头文件<code>#include &lt;vector&gt;</code>;</p><h4 id="3-2-2、-vector构造函数"><a href="#3-2-2、-vector构造函数" class="headerlink" title="3.2.2、 vector构造函数"></a>3.2.2、 vector构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建vector容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v; </code>                            //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());   </code>       //将v[begin(), end())区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li></ul><p><strong>例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) </span><br><span class="line">    &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> </span><br><span class="line"><span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> </span><br></pre></td></tr></table></figure><h4 id="3-2-3、-vector赋值操作"><a href="#3-2-3、-vector赋值操作" class="headerlink" title="3.2.3、 vector赋值操作"></a>3.2.3、 vector赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</li></ul><p><strong>例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) </span><br><span class="line">    &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">v2 = v1;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v4;</span><br><span class="line">v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4、-vector容量和大小"><a href="#3-2-4、-vector容量和大小" class="headerlink" title="3.2.4、  vector容量和大小"></a>3.2.4、  vector容量和大小</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>empty(); </code>                            //判断容器是否为空</p></li><li><p><code>capacity();</code>                      //容器的容量，一般是2的n次方</p></li><li><p><code>size();</code>                              //返回容器中元素的个数</p></li><li><p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><pre><code>                                           //如果容器变短，则末尾超出容器长度的元素被删除。</code></pre></li><li><p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><pre><code>                                         //如果容器变短，则末尾超出容器长度的元素被删除</code></pre></li></ul><p><strong>vector的capacity很重要</strong></p><blockquote><p>①、一旦内存重新分配，vector元素相关的reference、pointer、iterator都会失效；</p><p>②、内存重新分配很消耗时间。    </p></blockquote><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="keyword">if</span> (v1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">v1.<span class="built_in">resize</span>(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line">v1不为空</span><br><span class="line">v1的容量 = <span class="number">16</span></span><br><span class="line">v1的大小 = <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>这里要注意的是为什么v.capacity是16，因为vector的容量是2的n次方，这里因为vector存了10个数，因此capacity是2的4次方！</p></blockquote><p>总结：</p><ul><li>判断是否为空  — empty</li><li>返回元素个数  — size</li><li>返回容器容量  — capacity</li><li>重新指定大小  —  resize</li></ul><h4 id="3-2-5、-vector插入和删除"><a href="#3-2-5、-vector插入和删除" class="headerlink" title="3.2.5、 vector插入和删除"></a>3.2.5、 vector插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code>                                         //尾部插入元素ele</li><li><code>pop_back();</code>                                                //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code>                                                        //删除容器中所有元素</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">v1.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">v1.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span> </span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="number">100</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="number">1000</span> <span class="number">1000</span> <span class="number">100</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="number">1000</span> <span class="number">100</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插  — push_back</li><li>尾删  — pop_back</li><li>插入  — insert    (位置迭代器)</li><li>删除  — erase  （位置迭代器）</li><li>清空  —  clear  </li></ul><h4 id="3-2-6、-vector数据存取"><a href="#3-2-6、-vector数据存取" class="headerlink" title="3.2.6、 vector数据存取"></a>3.2.6、 vector数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>       //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line">v1的第一个元素为： <span class="number">0</span></span><br><span class="line">v1的最后一个元素为： <span class="number">9</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-2-7、-vector互换容器"><a href="#3-2-7、-vector互换容器" class="headerlink" title="3.2.7、 vector互换容器"></a>3.2.7、 vector互换容器</h4><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code>  // 将vec与本身的元素互换</li></ul><p><strong>例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换容器</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">swap</span>(v2);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收缩内存</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换容器</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">swap</span>(v2);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收缩内存</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line">互换后</span><br><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line">v的容量为：<span class="number">131072</span></span><br><span class="line">v的大小为：<span class="number">100000</span></span><br><span class="line">v的容量为：<span class="number">131072</span></span><br><span class="line">v的大小为：<span class="number">3</span></span><br><span class="line">v的容量为：<span class="number">3</span></span><br><span class="line">v的大小为：<span class="number">3</span></span><br></pre></td></tr></table></figure><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="3-2-8、vector预留空间"><a href="#3-2-8、vector预留空间" class="headerlink" title="3.2.8、vector预留空间"></a>3.2.8、vector预留空间</h4><p><strong>功能描述：</strong></p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><p><strong>注意：</strong></p><ul><li>vector不能使用reserve（）缩减容量，调用reserve（）所给的实参如果小于当前vector的容量，将会失效。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预留空间</span></span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">p = &amp;v[<span class="number">0</span>];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num:<span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p><h4 id="3-2-9、vector容器的能力："><a href="#3-2-9、vector容器的能力：" class="headerlink" title="3.2.9、vector容器的能力："></a>3.2.9、vector容器的能力：</h4><p>①、vector是将元素复制到dynamic array中，元素之间存在一定的顺序，所以vector是一种有序集合，支持随机访问；</p><p>②、在末端增加或删除元素，效率比较高；在前端或中段插入或删除元素效率比较低；</p><h4 id="3-2-10、vector异常处理"><a href="#3-2-10、vector异常处理" class="headerlink" title="3.2.10、vector异常处理"></a>3.2.10、vector异常处理</h4><blockquote><p>①、如果push_back（）安插元素时发生异常，函数将不产生效用。<br>②、如果元素的 copy/move 操作（包括构造函数和 assignment 操作符）不抛出异常，那么insert（）、emplace（）、emplace_back（）和push_back（）要么成功，要么不产生效用。<br>③、pop_back（）绝不会抛出任何异常。<br>④、如果元素的copy/move操作（包括构造函数和assignment操作符）不抛出异常，erase（）就不抛出异常。<br>⑤、swap（）和clear（）不抛出异常。<br>⑥、如果元素的copy/move操作（包括构造函数和assignment操作符）不抛出异常，那么所有操作不是成功，就是不产生效用。</p></blockquote><h4 id="3-2-10、vector定义二维数组"><a href="#3-2-10、vector定义二维数组" class="headerlink" title="3.2.10、vector定义二维数组"></a>3.2.10、vector定义二维数组</h4><p>①、使用vector定义二维数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;  &gt; v; <span class="comment">//注意&gt;和&gt;之间的空格。</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; v; <span class="comment">//c++11之前这样定义是错误的，c++11之后支持这种定义方式</span></span><br></pre></td></tr></table></figure><p>②、访问二维vector的元素的三种方式</p><p>如果指定外层和内层向量的大小，就可用operator[]进行读和写；如果只指定列向量大小，就能用push_back()函数进行写，不能用operator[]进行读和写。<br>a、指定vector–列（外层）大小<br>可用push_back函数进行初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line">v[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">cout&lt;&lt;v[<span class="number">1</span>][<span class="number">0</span>];<span class="comment">//用二维形式调用</span></span><br></pre></td></tr></table></figure><p>b、指定vector–行（内层）的大小<br>提前设定好每行vector的大小，就可用operator[]访问，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个m*n的二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">    array[i].<span class="built_in">resize</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">a</span>(<span class="number">10</span>);<span class="comment">//必须定义行数，列可以不定义</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>c、同时制定vector–行列大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">resize</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m));</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>(<span class="number">4</span>, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>));</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>&#125;,&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10</span>&#125;,&#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>&#125;,&#123;<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">13</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">array[i][j] = arr[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++-STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++-STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL--标准模板库</title>
      <link href="/2021/11/13/1%E3%80%81C++/3.C++%20STL/0%E3%80%81C++%20STL--%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
      <url>/2021/11/13/1%E3%80%81C++/3.C++%20STL/0%E3%80%81C++%20STL--%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h2 id="C-STL–标准模板库"><a href="#C-STL–标准模板库" class="headerlink" title="C++ STL–标准模板库"></a>C++ STL–标准模板库</h2><blockquote><p>声明：本文是在学习C++ STL–标准模板库的笔记，主要参考《C++ Prime》和《C++标准库》等。</p></blockquote><p>1、STL的诞生</p><p>为了建立数据结构和算法的一套标准，诞生了<strong>STL</strong></p><h3 id="2-2STL基本概念"><a href="#2-2STL基本概念" class="headerlink" title="2.2STL基本概念"></a>2.2STL基本概念</h3><ul><li><strong>标准模板库</strong></li><li>STL从广义上分为：<strong>容器、算法、迭代器</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接.</li><li>STL几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="2-3STL六大组件"><a href="#2-3STL六大组件" class="headerlink" title="2.3STL六大组件"></a>2.3STL六大组件</h3><p>STL大体分为六大组件，分别是：<strong>容器、算法、迭代器、仿函数、适配器(配接器)、空间配置器</strong></p><ol><li>容器:各种数据结构，如向量、列表、deque、Set、map等，用来存放数据。</li><li>算法:各种常用的算法，如排序、查找、复制、for_each等</li><li>迭代器:扮演了容器与算法之间的胶合剂.</li><li>仿函数:行为类似函数，可作为算法的某种策略.</li><li>适配器:一种用来修饰容器或者仿函数或迭代器接口的东西.</li><li>空间配置器:负责空间的配置与管理.</li></ol><p>2.4STL中容器、算法、迭代器</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构:数组，链表，树，栈，队列，集合，映射表等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种：</p><p><strong>序列式容器</strong>：：强调值的排序，序列式容器中的每个元素均有固定的位置。<strong>关联式容器</strong>：二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p>算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法:是指运算过程中会更改区间内的元素的内容.例如拷贝，替换，删除等等</p><p>非质变算法:是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p><strong>迭代器：</strong>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式.<strong>每个容器都有自己专属的迭代器</strong>。</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h2 id="3-STL-常用容器"><a href="#3-STL-常用容器" class="headerlink" title="3 STL-常用容器"></a>3 STL-常用容器</h2><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++STL/20211113110505.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++-STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++-STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、C++ STL--标准模板库：string--字符串容器</title>
      <link href="/2021/11/13/1%E3%80%81C++/3.C++%20STL/1%E3%80%81C++%20STL%EF%BC%9Astring%E5%AE%B9%E5%99%A8/"/>
      <url>/2021/11/13/1%E3%80%81C++/3.C++%20STL/1%E3%80%81C++%20STL%EF%BC%9Astring%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h2 id="3-1、string–字符串容器"><a href="#3-1、string–字符串容器" class="headerlink" title="3.1、string–字符串容器"></a>3.1、string–字符串容器</h2><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++STL/20211113113648.png"></p><h4 id="3-1-1、字符串基本概念本质："><a href="#3-1-1、字符串基本概念本质：" class="headerlink" title="3.1.1、字符串基本概念本质："></a>3.1.1、字符串基本概念<strong>本质：</strong></h4><p>字符串是C++风格的字符串，字符串本质上是一个<strong>类</strong></p><p><strong>字符串和char*区别：</strong></p><blockquote><p>char*是一个指针</p><p>字符串是一个类，类内部封装了 char* ，管理这个字符串，是一个char*型的容器。</p></blockquote><p><strong>特点：</strong></p><blockquote><p>字符串类内部封装了很多成员方法；</p><p>例如:查找查找，拷贝复制，删除删除替换替换，插入插入；</p><p>字符串管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责。</p></blockquote><h4 id="3-1-2字符串构造函数"><a href="#3-1-2字符串构造函数" class="headerlink" title="3.1.2字符串构造函数"></a>3.1.2字符串构造函数</h4><p>构造函数原型：</p><blockquote><p><code>string();</code>//创建一个空的字符串例如：Stringstr；<code>string(const char* s);</code>//使用字符串s初始化</p><p><code>string(const string&amp; str);</code>//使用一个字符串对象初始化另一个字符串对象</p><p><code>string(int n, char c);</code>//使用n个字符c初始化</p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;hello world！&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 = </span><br><span class="line">str2 = hello world！</span><br><span class="line">str3 = hello world！</span><br><span class="line">str3 = hello world！</span><br></pre></td></tr></table></figure><p>注：在使用sting容器时，要包含库文件：#include <string></p><h4 id="3-1-3字符串赋值操作"><a href="#3-1-3字符串赋值操作" class="headerlink" title="3.1.3字符串赋值操作"></a>3.1.3字符串赋值操作</h4><p>功能描述：</p><ul><li>给字符串字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code>//char*类型字符串赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>//把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>//字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>//把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>//把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>//把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>//用n个字符c赋给当前字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//赋值</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">string str1;</span><br><span class="line">str1 = &quot;hello world&quot;;</span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str2;</span><br><span class="line">str2 = str1;</span><br><span class="line">cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//字符赋值给当前的字符串</span><br><span class="line">string str3;</span><br><span class="line">str3 = &#x27;a&#x27;;</span><br><span class="line">cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str4;</span><br><span class="line">str4.assign(&quot;hello c++&quot;);</span><br><span class="line">cout &lt;&lt; &quot;str4 = &quot; &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str5;</span><br><span class="line">str5.assign(&quot;hello c++&quot;,5);</span><br><span class="line">cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//把字符串s赋给当前字符串</span><br><span class="line">string str6;</span><br><span class="line">str6.assign(str5);</span><br><span class="line">cout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//用n个字符c赋给当前字符串</span><br><span class="line">string str7;</span><br><span class="line">str7.assign(5, &#x27;x&#x27;);</span><br><span class="line">cout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1 = hello world</span><br><span class="line">str2 = hello world</span><br><span class="line">str3 = a</span><br><span class="line">str4 = hello c++</span><br><span class="line">str5 = hello</span><br><span class="line">str6 = hello</span><br><span class="line">str7 = xxxxx</span><br></pre></td></tr></table></figure><h4 id="3-1-4字符串拼接"><a href="#3-1-4字符串拼接" class="headerlink" title="3.1.4字符串拼接"></a>3.1.4字符串拼接</h4><p><strong>功能描述：</strong></p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator+=(const char* str);</code>//重载+=操作符</li><li><code>string&amp; operator+=(const char c);</code>//重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>//重载+=操作符</li><li><code>string&amp; append(const char *s); </code>//把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code>//把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>//同运算符+=(ConstString&amp;str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//字符串拼接</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;我&quot;;</span><br><span class="line"></span><br><span class="line">//重载+=操作符</span><br><span class="line">str1 += &quot;爱玩游戏&quot;;</span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str1 += &#x27;:&#x27;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str2 = &quot;LOL DNF&quot;;</span><br><span class="line"></span><br><span class="line">str1 += str2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str3 = &quot;I&quot;;</span><br><span class="line">str3.append(&quot; love &quot;);</span><br><span class="line">str3.append(&quot;game abcde&quot;, 4);</span><br><span class="line">//str3.append(str2);</span><br><span class="line">str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span><br><span class="line">cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-5字符串查找和替换"><a href="#3-1-5字符串查找和替换" class="headerlink" title="3.1.5字符串查找和替换"></a>3.1.5字符串查找和替换</h4><p><strong>功能描述：</strong></p><ul><li>查找:查找指定字符串是否存在</li><li>替换:在指定的位置替换字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>//查找str第一次出现位置，从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const; </code>//查找的第一次出现位置，从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const; </code>//从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const; </code>//查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>//查找str最后一次位置，从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>//查找的最后一次出现位置，从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>//从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const; </code>//查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>//替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s); </code>//替换从pos开始的n个字符为字符串s</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//查找和替换</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">//查找</span><br><span class="line">string str1 = &quot;abcdefgde&quot;;</span><br><span class="line"></span><br><span class="line">//查找str第一次出现位置，从pos开始查找</span><br><span class="line">int pos = str1.find(&quot;de&quot;);</span><br><span class="line"></span><br><span class="line">if (pos == -1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找str最后一次位置，从pos开始查找</span><br><span class="line">pos = str1.rfind(&quot;de&quot;);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">//替换</span><br><span class="line">string str1 = &quot;abcdefgde&quot;;</span><br><span class="line"></span><br><span class="line">str1.replace(1, 3, &quot;1111&quot;);</span><br><span class="line">//替换从pos开始n个字符为字符串str</span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">//test02();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找是从左往后，找到从右往左</li><li>找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4 id="3-1-6字符串比较"><a href="#3-1-6字符串比较" class="headerlink" title="3.1.6字符串比较"></a>3.1.6字符串比较</h4><p><strong>功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><blockquote><p>=返回 0</p><p>&gt;返回 1</p><p>&lt; 返回 -1</p></blockquote><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const; </code>//与字符串s比较</li><li><code>int compare(const char *s) const;</code>//与字符串s比较</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//字符串比较</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">string s1 = &quot;hello&quot;;</span><br><span class="line">string s2 = &quot;aello&quot;;</span><br><span class="line"></span><br><span class="line">int ret = s1.compare(s2);</span><br><span class="line"></span><br><span class="line">if (ret == 0) &#123;</span><br><span class="line">cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else if (ret &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 大于 s2</span><br></pre></td></tr></table></figure><p>总结:字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h4 id="3-1-7字符串字符存取"><a href="#3-1-7字符串字符存取" class="headerlink" title="3.1.7字符串字符存取"></a>3.1.7字符串字符存取</h4><p>字符串中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n); </code>//通过[]方式取字符</li><li><code>char&amp; at(int n); </code>//通过at方法获取字符</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//字符修改</span><br><span class="line">str[0] = &#x27;x&#x27;;</span><br><span class="line">str.at(1) = &#x27;x&#x27;;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h e l l o   w o r l d </span><br><span class="line">h e l l o   w o r l d </span><br><span class="line">xxllo world</span><br></pre></td></tr></table></figure><h4 id="3-1-8字符串插入和删除"><a href="#3-1-8字符串插入和删除" class="headerlink" title="3.1.8字符串插入和删除"></a>3.1.8字符串插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对字符串字符串进行插入和删除字符操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s); </code>//插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str); </code>//插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>//在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code>//删除从pos开始的n个字符</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//字符串插入和删除</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;hello&quot;;</span><br><span class="line">str.insert(1, &quot;111&quot;);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.erase(1, 3);  //从1号位置开始3个字符</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h111ello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p><h4 id="3-1-9字符串子串"><a href="#3-1-9字符串子串" class="headerlink" title="3.1.9字符串子串"></a>3.1.9字符串子串</h4><p><strong>功能描述：</strong></p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code>//返回由pos开始的n个字符组成的字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//获取子串</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">string str = &quot;abcdefg&quot;;</span><br><span class="line">string subStr = str.substr(1, 3);</span><br><span class="line">cout &lt;&lt; &quot;subStr = &quot; &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string email = &quot;hello@sina.com&quot;;</span><br><span class="line">int pos = email.find(&quot;@&quot;);</span><br><span class="line">string username = email.substr(0, pos);</span><br><span class="line">cout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subStr = bcd</span><br><span class="line">username: hello</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>]]></content>
      
      
      <categories>
          
          <category> C++-STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++-STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、C++14新特性：decltype（auto）类型推导</title>
      <link href="/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/4%E3%80%81decltype%EF%BC%88auto%EF%BC%89%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
      <url>/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/4%E3%80%81decltype%EF%BC%88auto%EF%BC%89%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h2 id="decltype（auto）"><a href="#decltype（auto）" class="headerlink" title="decltype（auto）"></a>decltype（auto）</h2><blockquote><p>声明：该笔记是在学习《深入理解C++11》、《C++11/14高级编程 Boost程序库探秘》时做的总结，方便以后巩固复习！</p></blockquote><p>auto和decltype两个关键字都可以推导类型，但用法有所差异。</p><p>auto的使用更加方便，但是用途有限，只能用在赋值语句里；</p><p>decltype用途广，可以推导任意表达式的类型，但使用时必须在括号内写全表达式，用法略有不便。</p><p>因此C++14标准增加了一种新的语言，允许把这两者结合起来，也就是“**decltype(auto)**”，</p><p>使用decltype的语义推导类型，但是用的却是auto语法形式。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>（<span class="keyword">auto</span>） x = <span class="number">6</span>; <span class="comment">//整型类型int ，仅C++14</span></span><br><span class="line"><span class="keyword">decltype</span>（<span class="keyword">auto</span>） y = <span class="number">7L</span>; <span class="comment">//整型类型long ，仅C++14</span></span><br><span class="line"><span class="keyword">decltype</span>（<span class="keyword">auto</span>） z = x + y; <span class="comment">//整型类型long ，仅C++14</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、C++11新特性：指针空值--nullptr</title>
      <link href="/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/3%E3%80%81%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BC--nullptr/"/>
      <url>/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/3%E3%80%81%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BC--nullptr/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h2 id="四、指针空值–nullptr"><a href="#四、指针空值–nullptr" class="headerlink" title="四、指针空值–nullptr"></a>四、指针空值–nullptr</h2><blockquote><p>声明：该笔记是在学习《深入理解C++》、《C++11/14高级编程 Boost程序库探秘》时做的总结，方便以后巩固复习！</p></blockquote><h3 id="引入nullptr的意义："><a href="#引入nullptr的意义：" class="headerlink" title="引入nullptr的意义："></a><strong>引入nullptr的意义：</strong></h3><p>在C++程序开发中，为了提高代码的健壮性，一般会在定义指针的同时会完成初始化操作（避免出现野指针），在指针指向尚未明确的情况下，都会给指针初始化为空指针。在C++98/03标准中，将一个指针初始化为空指针的方式有两种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>在底层源码中 NULL 这个宏是这样定义的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看出,NULL可能被定义为字面常量0，或者是定义为无类型指针(void*)0。<strong>原因：</strong>由于 C++ 中，void * 类型无法隐式转换为其他类型的指针，此时使用 0 代替 ((void *)0)，用于解决空指针的问题。这个 0（0x0000 0000）表示的就是虚拟地址空间中的 0 地址，这块地址是只读的。但是无论采用什么样的定义方式，我们在使用空值的指针时，都不可避免地会遇到一些麻烦；</p><p>如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void func(char *c)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void func(int i)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 想要调用重载函数 void func(char *p)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">NULL</span>);  <span class="comment">//注：如果使用gcc编译，NULL转化为内部标识 __null,该语句会编译失败 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 想要调用重载函数 void func(int i)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>);    </span><br><span class="line">    </span><br><span class="line"><span class="built_in">func</span>((<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *c)</span></span></span><br></pre></td></tr></table></figure><p>虽然调用 func(NULL); 最终链接到的还是 void func(int p) 和预期是不一样的；原因：C++ 中将 NULL 定义为字面常量 0，并不能保证在所有场景下都能很好的工作，比如，函数重载时，NULL 和 0 无法区分；</p><p>在C++11新标准这，出于兼容性的考虑，字面常量0的二义性并没有被消除；但是标准为二义性给出了新的答案，就是使用nullptr；在C++11 新标准中，nullptr是一个所谓“<strong>指针空值类型</strong>”的常量；<strong>指针空值类型</strong>被命名为nullptr_t。</p><p>可以在支持nullptr的头文件（csddef）中找到如下定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="keyword">nullptr_t</span></span>;</span><br></pre></td></tr></table></figure><p>使用nullptr_t的时候必须#include<cstddef>（#include有些头文件也会间接#include<cstddef>，比如<iostream>），而nullptr则不用。</p><p>大概就是由于nullptr是关键字，而nullptr_t是通过推导而来的缘故。</p><p>对上述程序进行修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void func(char *c)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void func(int i)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用重载函数 void func(char *p)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">nullptr</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用重载函数 void func(int i)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br></pre></td></tr></table></figure><p><strong>可以看出，nullptr 无法隐式转换为整形，但是可以隐式匹配指针类型。在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。</strong></p><h3 id="nullptr和nullptr-t"><a href="#nullptr和nullptr-t" class="headerlink" title="nullptr和nullptr_t"></a>nullptr和nullptr_t</h3><p>C++11标准不仅定义了指针空值常量nullptr，也定义了其指针空值类型nullptr_t，也就表示了指针空值类型并非仅有nullptr一个实例。通常情况下，也可以通过nullptr_t来声明一个指针空值类型的变量（即使看起来用途不大）。</p><p>除去nullptr及nullptr_t以外，C++中还存在各种内置类型。C++11标准严格规定了数据间的关系。常见的规则简单地列在了下面：</p><blockquote><p>①、所有定义为nullptr_t类型的数据都是等价的，行为也是完全一致。</p><p>②、nullptr_t类型数据可以隐式转换成任意一个指针类型。</p><p>③、nullptr_t类型数据不能转换为非指针类型，即使使用reinterpret_cast<nullptr_t>()的方式也是不可以的。</p><p>④、 nullptr_t类型数据不适用于算术运算表达式。</p><p>⑤、nullptr_t类型数据可以用于关系运算表达式，但仅能与nullptr_t类型数据或者指针类型数据进行比较，当且仅当关系运算符为==、&lt;=、&gt;=等时返回true。</p></blockquote><h3 id="关于nullptr规则的一些讨论"><a href="#关于nullptr规则的一些讨论" class="headerlink" title="关于nullptr规则的一些讨论"></a>关于nullptr规则的一些讨论</h3><p>①、在C++11标准中，nullptr类型数据所占用的内存空间大小跟void*相同的，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">nullptr_t</span>) == <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*)</span><br></pre></td></tr></table></figure><p><em><em>注：那么nullptr是否是(void</em>)0的一个别名？</em>*</p><p>不是，尽管两者看起来很相似，都可以被转换为任何类型的指针，但两者在语法层面有着不同的内涵。nullptr是一个编译时期的常量，它的名字是一个编译时期的关键字，能够为编译器所识别。而(void*)0只是一个强制转换表达式，其返回的也是一个 void <em>指针类型。**最为重要的是，在C++语言中，nullptr到任何指针的转换是隐式的，而(void <em>)0则必须经过类型转换后才能使用。</em></em></p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、C++11新特性：decltype类型推导</title>
      <link href="/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/2%E3%80%81decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
      <url>/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/2%E3%80%81decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h2 id="二、decltype类型推导"><a href="#二、decltype类型推导" class="headerlink" title="二、decltype类型推导"></a>二、decltype类型推导</h2><blockquote><p>声明：该笔记是在学习《深入理解C++11》、《C++11/14高级编程 Boost程序库探秘》时做的总结，方便以后巩固复习！</p></blockquote><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>auto关键字能够在赋值语句里推导类型，但这只是C++语言里一种很少见的应用场景，要想在任意的场景都能够得到表达式的类型就需要使用关键字：<strong>decltype</strong></p><p>decltype的形式和函数调用很像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression)  <span class="comment">//获取表达式的类型--在编译期计算</span></span><br></pre></td></tr></table></figure><p>decltype在技术和使用上和sizeof非常像，都需要编译器在编译期计算类型，但是sizeof返回的是<strong>整数</strong>，而decltype得到的是<strong>类型</strong>。</p><h4 id="decltype和auto的异同："><a href="#decltype和auto的异同：" class="headerlink" title="decltype和auto的异同："></a>decltype和auto的异同：</h4><blockquote><p>与auto不同点：</p><p>decltypr的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，decltype总是以一个普通的表达式为参数，返回该表达式的类型。</p><p>与auto相同点：</p><p>①、作为一个类型指示符，decltype可以将获得的类型来定义另外一个变量；</p><p>②、declttype类型推导也是在编译时进行的</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">0</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a的类型是&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(a).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b的类型是&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(b).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="keyword">decltype</span>(c + d ) e;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;e的类型是&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(e).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a的类型是i  <span class="comment">//i代表int</span></span><br><span class="line">b的类型是i  </span><br><span class="line">e的类型是d   <span class="comment">//ddouble</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到变量b的类型由decltype（a）进行声明，表示b跟a这个表达式返回的类型相同；而e的类型则由（c + d）这个表达式返回的类型相同，c + d的表达式的类型为double，所有e的类型被decltype推导为double。</p></blockquote><h3 id="decltype的应用"><a href="#decltype的应用" class="headerlink" title="decltype的应用"></a>decltype的应用</h3><h4 id="decltype和typedf-using合用"><a href="#decltype和typedf-using合用" class="headerlink" title="decltype和typedf/using合用"></a>decltype和typedf/using合用</h4><p>在C++11 的头文件中常可以看到以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">size_t</span> = <span class="keyword">decltype</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">ptrdiff_t</span> = <span class="keyword">decltype</span>((<span class="keyword">int</span>*)<span class="number">0</span>- (<span class="keyword">int</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">nullptr_t</span> = <span class="keyword">decltype</span>(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><blockquote><p>size_t以及ptrdiff_t及nullptr都是由decltype推导出来的类型</p><p>这种定义方式的意义：</p><p>在一些常量、基本类型、运算符、操作符等基于被定义好的情况下，类型可以按照规则被推导出来。而使用using可以为这些类型取名；这样就颠覆了之前类型扩展需要江类型“映射”到基本类型的常规做法。</p></blockquote><h4 id="deltype在某些场景下使用增加代码的可读性"><a href="#deltype在某些场景下使用增加代码的可读性" class="headerlink" title="deltype在某些场景下使用增加代码的可读性"></a>deltype在某些场景下使用增加代码的可读性</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(vec.begin())</span> vectype</span>;</span><br><span class="line"><span class="keyword">for</span> (vectype i = vec.<span class="built_in">begin</span>(); i &lt; vec.<span class="built_in">end</span>(); i++) </span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(vec)::iterator i = vec.<span class="built_in">begin</span>(); i &lt; vec.<span class="built_in">end</span>(); i++) </span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><p>定义了vector的iterator的类型。这个类型还可以在main函数中重用。</p><p>当遇到一些具有复杂类型的变量或表达式时，就可以利用decltype和typedef/using的组合来将其转化为一个简单的表达式，这样在以后的代码写作中可以提高可读性和可维护性。</p><p>此外可以看到decltype(vec)::iterator这样的灵活用法，这看起来跟auto非常类似，也类似于是一种“占位符”式的替代。</p></blockquote><h4 id="使用decltype重用匿名类型"><a href="#使用decltype重用匿名类型" class="headerlink" title="使用decltype重用匿名类型"></a>使用decltype重用匿名类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span>&#123;</span>K1, K2, K3&#125;anon_e;    <span class="comment">// 匿名的强类型枚举</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">decltype</span>(anon_e) key;</span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line">&#125;anon_u;     <span class="comment">// 匿名的union联合体</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> d;</span><br><span class="line">           <span class="keyword">decltype</span>(anon_u) id;</span><br><span class="line">&#125;anon_s[<span class="number">100</span>];  <span class="comment">// 匿名的struct数组</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">decltype</span>(anon_s) as;</span><br><span class="line">    as[<span class="number">0</span>].id.key = <span class="keyword">decltype</span>(anon_e)::K1;    <span class="comment">// 引用匿名强类型枚举中的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure><blockquote><p>这里我们使用了3种不同的匿名类型：匿名的强类型枚举anon_e（请参见5.1节）、匿名的联合体anon_u，以及匿名的结构体数组anon_s。可以看到，只要通过匿名类型的变量名anon_e、anon_u，以及anon_s，decltype可以推导其类型并且进行重用。这些都是以前C++代码所做不到的。</p><p><strong>不过匿名一般都有匿名理由，一般都不希望匿名后的类型被重用。</strong></p></blockquote><h4 id="decltype可以适当扩大模板泛型的能力"><a href="#decltype可以适当扩大模板泛型的能力" class="headerlink" title="decltype可以适当扩大模板泛型的能力"></a>decltype可以适当扩大模板泛型的能力</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s的类型被声明为decltype(t1 + t2)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sum</span><span class="params">(T1 &amp; t1, T2 &amp; t2, <span class="keyword">decltype</span>(t1 + t2) &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s = t1 + t2;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s的类型是&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(s).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">long</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">float</span> c = <span class="number">1.0f</span>, d = <span class="number">2.3f</span>;</span><br><span class="line"><span class="keyword">long</span> e;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line"><span class="built_in">Sum</span>(a, b, e);    <span class="comment">// s的类型被推导为long</span></span><br><span class="line"><span class="built_in">Sum</span>(c, d, f);    <span class="comment">// s的类型被推导为float</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s的类型是l</span><br><span class="line">s的类型是f</span><br></pre></td></tr></table></figure><blockquote><p>代码中的Sum函数模板增加了类型为decltype(t1+t2)的s作为参数，而函数本身不返回任何值。这样一来，Sum的适用范围增加，其返回的类型是根据t1 + t2推导而来的类型。不过这里还是有一定的限制，可以看到返回值的类型必须一开始就被指定，我们必须清楚Sum运算的结果使用什么样的类型来存储是合适的，这在一些泛型编程中依然不能满足要求。</p><p>解决的方法是结合decltype与auto关键字，使用追踪返回类型的函数定义来使得编译器对函数返回值进行推导。</p></blockquote><h3 id="decltype推导规则"><a href="#decltype推导规则" class="headerlink" title="decltype推导规则"></a>decltype推导规则</h3><h4 id="表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用-decltype-推导出的类型和表达式的类型是一致的。"><a href="#表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用-decltype-推导出的类型和表达式的类型是一致的。" class="headerlink" title="表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用 decltype 推导出的类型和表达式的类型是一致的。"></a>表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用 decltype 推导出的类型和表达式的类型是一致的。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string text;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">110</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;y = x;</span><br><span class="line">    <span class="keyword">decltype</span>(x) a = x;</span><br><span class="line">    <span class="keyword">decltype</span>(y) b = x;</span><br><span class="line">    <span class="keyword">decltype</span>(Test::value) c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">decltype</span>(t.text) d = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 变量 a 被推导为 int 类型<br> 变量 b 被推导为 const int &amp; 类型<br> 变量 c 被推导为 const int 类型<br> 变量 d 被推导为 string 类型</p></blockquote><h4 id="表达式是函数调用，使用-decltype-推导出的类型和函数返回值一致。"><a href="#表达式是函数调用，使用-decltype-推导出的类型和函数返回值一致。" class="headerlink" title="表达式是函数调用，使用 decltype 推导出的类型和函数返回值一致。"></a>表达式是函数调用，使用 decltype 推导出的类型和函数返回值一致。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_int</span><span class="params">()</span></span>;                 <span class="comment">// 返回值为 int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func_int_r</span><span class="params">()</span></span>;              <span class="comment">// 返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">()</span></span>;            <span class="comment">// 返回值为 int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">func_cint</span><span class="params">()</span></span>;          <span class="comment">// 返回值为 const int</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">func_cint_r</span><span class="params">()</span></span>;       <span class="comment">// 返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">()</span></span>;     <span class="comment">// 返回值为 const int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> Test <span class="title">func_ctest</span><span class="params">()</span></span>;        <span class="comment">// 返回值为 const Test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>()) a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>()) b = n;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_rr</span>()) c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint</span>())  d = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_r</span>())  e = n;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_rr</span>()) f = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_ctest</span>()) g = <span class="built_in">Test</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>变量 a 被推导为 int 类型<br>变量 b 被推导为 int&amp; 类型<br>变量 c 被推导为 int&amp;&amp; 类型<br>变量 d 被推导为 int 类型<br>变量 e 被推导为 const int &amp; 类型<br>变量 f 被推导为 const int &amp;&amp; 类型<br>变量 g 被推导为 const Test 类型</p><p>函数 func_cint () 返回的是一个纯右值（在表达式执行结束后不再存在的数据，也就是临时性的数据），对于纯右值而言，只有类类型可以携带const、volatile限定符，除此之外需要忽略掉这两个限定符，因此推导出的变量 d 的类型为 int 而不是 const int。</p></blockquote><h4 id="表达式是一个左值，或者被括号-包围，使用-decltype-推导出的是表达式类型的引用（如果有-const、volatile-限定符不能忽略）。"><a href="#表达式是一个左值，或者被括号-包围，使用-decltype-推导出的是表达式类型的引用（如果有-const、volatile-限定符不能忽略）。" class="headerlink" title="表达式是一个左值，或者被括号 ( ) 包围，使用 decltype 推导出的是表达式类型的引用（如果有 const、volatile 限定符不能忽略）。"></a>表达式是一个左值，或者被括号 ( ) 包围，使用 decltype 推导出的是表达式类型的引用（如果有 const、volatile 限定符不能忽略）。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Test obj;</span><br><span class="line">    <span class="comment">//带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.num) a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>((obj.num)) b = a;</span><br><span class="line">    <span class="comment">//加法表达式</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>obj.num 为类的成员访问表达式，符合场景 1，因此 a 的类型为 int<br>obj.num 带有括号，符合场景 3，因此 b 的类型为 const int&amp;。<br>n+m 得到一个右值，符合场景 1，因此 c 的类型为 int<br>n=n+m 得到一个左值 n，符合场景 3，因此 d 的类型为 int&amp;</p></blockquote><h3 id="cv限制符的继承与冗余的符号"><a href="#cv限制符的继承与冗余的符号" class="headerlink" title="cv限制符的继承与冗余的符号"></a>cv限制符的继承与冗余的符号</h3><h4 id="与auto类型推导时不能“带走”cv限制符不同是："><a href="#与auto类型推导时不能“带走”cv限制符不同是：" class="headerlink" title="与auto类型推导时不能“带走”cv限制符不同是："></a>与auto类型推导时不能“带走”cv限制符不同是：</h4><p><strong>decltype是能够“带走”表达式的cv限制符的</strong>。不过，如果对象的定义中有const或volatile限制符，使用decltype进行推导时，其成员不会继承const或volatile限制符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ic = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> iv;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">int</span> i; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> S a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">volatile</span> S b;</span><br><span class="line"><span class="keyword">volatile</span> S* p = &amp;b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; is_const&lt;<span class="keyword">decltype</span>(ic)&gt;::value &lt;&lt; endl;        <span class="comment">// 1            </span></span><br><span class="line">cout &lt;&lt; is_volatile&lt;<span class="keyword">decltype</span>(iv)&gt;::value &lt;&lt; endl;    <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; is_const&lt;<span class="keyword">decltype</span>(a)&gt;::value &lt;&lt; endl;         <span class="comment">// 1            </span></span><br><span class="line">cout &lt;&lt; is_volatile&lt;<span class="keyword">decltype</span>(b)&gt;::value &lt;&lt; endl;     <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; is_const&lt;<span class="keyword">decltype</span>(a.i)&gt;::value &lt;&lt; endl;      <span class="comment">// 0, 成员不是const  </span></span><br><span class="line">cout &lt;&lt; is_volatile&lt;<span class="keyword">decltype</span>(p-&gt;i)&gt;::value &lt;&lt; endl; <span class="comment">// 0, 成员不volatile</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><blockquote><p>这里使用了C++库提供的is_const和is_volatile来查看类型是否是常量或者易失的。可以看到，结构体变量a、b和结构体指针p的cv限制符并没有出现在其成员的decltype类型推导结果中。</p></blockquote><h4 id="与auto相同的是："><a href="#与auto相同的是：" class="headerlink" title="与auto相同的是："></a>与auto相同的是：</h4><p><strong>decltype从表达式推导出类型后，进行类型定义时，也会允许一些冗余的符号。</strong>比如cv限制符以及引用符号&amp;，通常情况下，如果推导出的类型已经有了这些属性，冗余的符号则会被忽略</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; j = i;</span><br><span class="line"><span class="keyword">int</span> * p = &amp;i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">decltype</span>(i) &amp; var1 = i;</span><br><span class="line">    <span class="keyword">decltype</span>(j) &amp; var2 = i;      <span class="comment">// 冗余的&amp;, 被忽略</span></span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(var1)&gt;::value &lt;&lt; endl;<span class="comment">// 1, 是左值引用</span></span><br><span class="line">    cout &lt;&lt; is_rvalue_reference&lt;<span class="keyword">decltype</span>(var2)&gt;::value &lt;&lt; endl;<span class="comment">// 0, 不是右值引用</span></span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(var2)&gt;::value &lt;&lt; endl;<span class="comment">// 1, 是左值引用</span></span><br><span class="line">    <span class="comment">//decltype(p)* var3 = &amp;i;      // 无法通过编译              </span></span><br><span class="line">    <span class="keyword">decltype</span>(p)* var3 = &amp;p;      <span class="comment">// var3的类型是int**             </span></span><br><span class="line">    <span class="keyword">auto</span>* v3 = p;                  <span class="comment">// v3的类型是int*</span></span><br><span class="line">    v3 = &amp;i;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">decltype</span><span class="params">(k)</span> var4 </span>= <span class="number">1</span>; <span class="comment">// 冗余的const，被忽略</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>这里定义了类型为decltype(i) &amp;的变量var1，以及类型为decltype(j) &amp;的变量var2。</p><p>由于i的类型为int，所以这里的引用符号保证var1成为一个int&amp;引用类型。而由于j本来就是一个int &amp;的引用类型，所以decltype之后的&amp;成为了冗余符号，会被编译器忽略，因此j的类型依然是int &amp;。</p><p>特别要注意的是decltype(p)<em>的情况。可以看到，在定义var3变量的时候，由于p的类型是int</em>，因此var3被定义为了int*<em>类型。这跟auto声明中，</em>也可以是冗余的不同。在decltype后的*号，并不会被编译器忽略。</p><p>var4中const可以被冗余的声明，但会被编译器忽略，同样的情况也会发生在volatile限制符上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、C++11新特性：auto类型推导</title>
      <link href="/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/1%E3%80%81auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
      <url>/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/1%E3%80%81auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/C++/QQ%E5%9B%BE%E7%89%8720210816234232.jpg"></p><h2 id="一、auto类型推导"><a href="#一、auto类型推导" class="headerlink" title="一、auto类型推导"></a>一、auto类型推导</h2><blockquote><p>声明：该笔记是在学习《深入理解C++11》、《C++11/14高级编程 Boost程序库探秘》时做的总结，方便以后巩固复习！</p></blockquote><h3 id="静态类型、动态类型和类型推导"><a href="#静态类型、动态类型和类型推导" class="headerlink" title="静态类型、动态类型和类型推导"></a>静态类型、动态类型和类型推导</h3><p>静态类型：C/C++常被成为静态类型的编程语言，变量必须被定义；</p><p>动态类型：python、Perl、JavaScript语言常被称为动态类型的编程语言，变量不需要声明就可以被使用。</p><p>静态类型和动态类型的区别：是在对变量进行类型检测的时间点；静态类型的类型检测主要发生在编译阶段；动态类型的类型检测主要发生在运行阶段。</p><p>动态类型语言变量“拿来就用”的特性依赖的是类型推导技术；事实上类型推导也可以用于静态类型的语言中；C++11中类型推导的实现方式就有两种：①、auto，②、decltype;先学习auto关键字！</p><p>auto关键字在早期的C/C++标准中的含义：</p><blockquote><p>按照C/C++早期标准，声明时使用auto修饰的变量，是具有自动存储的局部变量；然而几乎无人使用这种含义，因为一般函数内没有被声明为static的变量总是具有自动存储的局部变量。</p></blockquote><p>auto关键字在C++11中的含义：</p><blockquote><p>auto不再是一个存储类型指示符（如static、extern为纯粹类型指示符），而是一个新的类型指示符（int、float等是类型指示符）来指示编译器，<strong>auto声明变量的类型必须由编译器在编译时期推导而得。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>; <span class="comment">//x的类型为int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="built_in">foo</span>(); <span class="comment">//y的类型为double</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">&#125;str; </span><br><span class="line"><span class="keyword">auto</span> str1 = str; <span class="comment">//str1的类型是sturct m</span></span><br><span class="line"><span class="comment">//auto z; //无法推导,不能通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>auto 声明的变量必须被初始化，以使编译能够从其初始化表达式中推导出其类型。这里可以理解为auto并非一种“类型”，而是一个类型声明时的“占位符”，编译器在编译时会将auto替代为变量实际的类型。</p></blockquote><h3 id="auto的优势"><a href="#auto的优势" class="headerlink" title="auto的优势"></a>auto的优势</h3><h4 id="①、最大优势就是在拥有初始化表达式的复杂类型变量声明时简化代码"><a href="#①、最大优势就是在拥有初始化表达式的复杂类型变量声明时简化代码" class="headerlink" title="①、最大优势就是在拥有初始化表达式的复杂类型变量声明时简化代码"></a>①、最大优势就是在拥有初始化表达式的复杂类型变量声明时简化代码</h4><p>由于C++的发展，声明变量类型也变得越来越复杂，很多时候，名字空间、模板成为了类型的一部分，导致程序员在使用库的时候如履薄冰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loopover</span><span class="params">(std::vector&lt;std:string&gt; &amp; vs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;std::string&gt;::iterator i = vs.<span class="built_in">begin</span>(); <span class="comment">//可看出在在不使用命名空间时，使用iterator 需要书写大量代码</span></span><br><span class="line"><span class="keyword">for</span>(; i &lt; vs.<span class="built_in">end</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用auto的话，代码会的可读性可以成倍增长,如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loopover</span><span class="params">(std::vector&lt;std:string&gt; &amp; vs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;std::string&gt;::iterator i = vs.<span class="built_in">begin</span>(); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>  i = vs.<span class="built_in">begin</span>(); i &lt; vs.<span class="built_in">end</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②、第二个优势则在于可以免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误"><a href="#②、第二个优势则在于可以免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误" class="headerlink" title="②、第二个优势则在于可以免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误"></a>②、第二个优势则在于可以免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误</h4><p>在C/C++中，存在着很多隐式或者用户自定义的类型转换规则（比如整型与字符型进行加法运算后，表达式返回的是整型，这是一条隐式规则）。这些规则并非很容易记忆，尤其是在用户自定义了很多操作符之后。而这个时候，auto就有用武之地了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PI</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span>* (<span class="keyword">float</span> v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)val * v;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> val = <span class="number">3.1415927f</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> radius = <span class="number">1.7e10</span>;</span><br><span class="line">    PI pi;</span><br><span class="line">    <span class="keyword">auto</span> circumference = <span class="number">2</span> * (pi * radius);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;circumference = &quot;</span> &lt;&lt; circumference &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">circumference = <span class="number">1.06814e+11</span></span><br></pre></td></tr></table></figure><blockquote><p>这里定义了float型的变量radius（半径）以及一个自定义类型PI变量pi（π值），在计算圆周长的时候，使用了auto类型来定义变量circumference。这里，PI在与float类型数据相乘时，其返回值为double。而PI的定义可能是在其他的地方（头文件里），main函数的程序员可能不知道PI的作者为了避免数据上溢或者精度降低而返回了double类型的浮点数。因此main函数程序员如果使用float类型声明circumference，就可能享受不了PI作者细心设计带来的好处。反之，将circumference声明为auto，则毫无问题，因为编译器已经自动地做了最好的选择。</p></blockquote><h4 id="③、第三个优点就是其“自适应”性能够在一定程度上支持泛型的编程"><a href="#③、第三个优点就是其“自适应”性能够在一定程度上支持泛型的编程" class="headerlink" title="③、第三个优点就是其“自适应”性能够在一定程度上支持泛型的编程"></a>③、第三个优点就是其“自适应”性能够在一定程度上支持泛型的编程</h4><p>再回到上面代码例子，这里假设改动了PI的定义，如将operator*返回值变为long double，此时，main函数并不需要修改，因为auto会“自适应”新的类型。</p><p>同时，对于不同的平台上的代码维护，auto也会带来一些“泛型”的好处。这里我们以strlen函数为例，在32位的编译环境下，strlen返回的为一个4字节的整型，而在64位的编译环境下，strlen会返回一个8字节的整型。虽然系统库<cstring>为其提供了size_t类型来支持多平台间的代码共享支持，但是使用auto关键字我们同样可以达到代码跨平台的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> v = <span class="built_in">strlen</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>由于size_t的适用范围往往局限于<cstring>中定义的函数，auto的适用范围明显更为广泛。</p><p>当auto应用于模板的定义中，其“自适应”性会得到更加充分的体现。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sum</span><span class="params">(T1 &amp; t1, T2 &amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> s = t1 + t2;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">long</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">float</span> c = <span class="number">1.0f</span>, d = <span class="number">2.3f</span>;</span><br><span class="line">    <span class="keyword">auto</span> e = Sum&lt;<span class="keyword">int</span>,<span class="keyword">long</span>&gt;(a,b);<span class="comment">//s的类型被推导为long</span></span><br><span class="line">    <span class="keyword">auto</span> f = Sum&lt;<span class="keyword">float</span>,<span class="keyword">float</span>&gt;(c,d);<span class="comment">//s的类型被推导为float</span></span><br><span class="line">cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; f &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">3.3</span></span><br></pre></td></tr></table></figure><blockquote><p>在上面程序中，由于类型T1、T2要在模板实例化时才能确定，所以在Sum中将变量s的类型声明为auto的。在函数main中我们将模板实例化时，Sum&lt;int,long&gt;中的s变量会被推导为long类型，而Sum&lt;float, float&gt;中的s变量则会被推导为float。可以看到，auto与模板一起使用时，其“自适应”特性能够加强C++中“泛型”的能力。不过在这个例子中，由于总是返回double类型的数据，所以Sum模板函数的适用范围还是受到了一定的限制。</p></blockquote><h4 id="④、在宏定义中，避免出现性能问题"><a href="#④、在宏定义中，避免出现性能问题" class="headerlink" title="④、在宏定义中，避免出现性能问题"></a>④、在宏定义中，避免出现性能问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX1(a, b) ((a) &gt; (b)) ? (a) : (b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX2(a, b) (&#123;\</span></span><br><span class="line"><span class="meta">        auto _a = (a);\</span></span><br><span class="line"><span class="meta">        auto _b = (b);\</span></span><br><span class="line"><span class="meta">        (_a &gt; _b) ? _a : _b;&#125;)</span></span><br><span class="line">        </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> m1 = <span class="built_in">MAX1</span>(<span class="number">1</span>*<span class="number">2</span>*<span class="number">3</span>*<span class="number">4</span>, <span class="number">5</span>+<span class="number">6</span>+<span class="number">7</span>+<span class="number">8</span>);</span><br><span class="line"> <span class="keyword">int</span> m2 = <span class="built_in">MAX2</span>(<span class="number">1</span>*<span class="number">2</span>*<span class="number">3</span>*<span class="number">4</span>, <span class="number">5</span>+<span class="number">6</span>+<span class="number">7</span>+<span class="number">8</span>);</span><br><span class="line"> cout &lt;&lt; m1 &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; m2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义了两种类型的宏Max1和Max2。两者作用相同，都是求a和b中较大者并返回。前者采用传统的三元运算符表达式，这可能会带来一定的性能问题。因为a或者b在三元运算符中都出现了两次，那么无论是取a还是取b，其中之一都会被运算两次。而在Max2中，我们将a和b都先算出来，再使用三元运算符进行比较，就不会存在这样的问题了。</p></blockquote><p>在传统的C++98标准中，由于a和b的类型无法获得，所以我们无法定义Max2这样高性能的宏。而新的标准中的auto则提供了这种可行性。</p><h3 id="auto使用时注意事项"><a href="#auto使用时注意事项" class="headerlink" title="auto使用时注意事项"></a>auto使用时注意事项</h3><h4 id="auto类型指示符与指针和引用之间的关系"><a href="#auto类型指示符与指针和引用之间的关系" class="headerlink" title="auto类型指示符与指针和引用之间的关系"></a>auto类型指示符与指针和引用之间的关系</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> * y = &amp;x;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> * a = &amp;x; <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp; b = x;<span class="comment">// int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> c = y;<span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> * d = y; <span class="comment">// int*</span></span><br><span class="line"><span class="comment">//auto * e = &amp;foo();//编译失败，指针不能指向一个临时变量</span></span><br><span class="line"><span class="comment">//auto &amp; f = foo();//编译失败，nonconst的左值引用不能和一个临时变量绑定</span></span><br><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bar</span>();<span class="comment">// int</span></span><br><span class="line"><span class="keyword">auto</span> &amp; h = <span class="built_in">bar</span>();<span class="comment">// int&amp;</span></span><br></pre></td></tr></table></figure><blockquote><p>变量a、c、d的类型都是指针类型，且都指向变量x。实际上对于a、c、d三个变量而言，声明其为auto *或auto并没有区别。</p><p>而如果要使得auto声明的变量是另一个变量的引用，则必须使用auto &amp;，如同本例中的变量b和h一样。</p></blockquote><h4 id="auto与volatile和const之间也存在着一些相互的联系"><a href="#auto与volatile和const之间也存在着一些相互的联系" class="headerlink" title="auto与volatile和const之间也存在着一些相互的联系"></a>auto与volatile和const之间也存在着一些相互的联系</h4><p>volatile和const代表了变量的两种不同的属性：易变的和常量的。</p><p>在C++标准中，它们常常被一起叫作cv限制符（cv-qualifier）。鉴于cv限制符的特殊性，C++11标准规定auto可以与cv限制符一起使用，<strong>不过声明为auto的变量并不能从其初始化表达式中“带走”cv限制符</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> * <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> a = <span class="built_in">foo</span>(); <span class="comment">//a:const double</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp; b = <span class="built_in">foo</span>(); <span class="comment">//b:const double&amp;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">auto</span> * c = <span class="built_in">bar</span>(); <span class="comment">//c:volatile float*</span></span><br><span class="line"><span class="keyword">auto</span> d = a; <span class="comment">//d:double</span></span><br><span class="line"><span class="keyword">auto</span> &amp; e = e; <span class="comment">//e:const double &amp;</span></span><br><span class="line"><span class="keyword">auto</span> f = c; <span class="comment">//f:float *</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">auto</span> &amp; g = c; <span class="comment">//g:volatile float * &amp;</span></span><br></pre></td></tr></table></figure><p>可以看出通过非cv限制的类型初始化一个cv限制的类型，如变量a、b、c所示。不过通过auto声明的变量d、f却无法带走a和f的常量性或者易失性。这里的例外还是引用，可以看出，声明为引用的变量e、g都保持了其引用的对象相同的属性（事实上，指针也是一样的）。</p><h4 id="auto可以用来声明多个变量的类型，不过这些变量的类型必须相同"><a href="#auto可以用来声明多个变量的类型，不过这些变量的类型必须相同" class="headerlink" title="auto可以用来声明多个变量的类型，不过这些变量的类型必须相同"></a>auto可以用来声明多个变量的类型，不过这些变量的类型必须相同</h4><p>如果这些变量的类型不相同，编译器则会报错。事实上，用auto来声明多个变量类型时，只有第一个变量用于auto的类型推导，然后推导出来的数据类型被作用于其他的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//m是一个指向const int类型变量的指针，n是一个int类型的变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* m = &amp;x, n = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//auto i = 1, j = 3.14f; //编译失败</span></span><br><span class="line"><span class="keyword">auto</span> o = <span class="number">1</span>,&amp;p = o,*q = &amp;p; <span class="comment">//从左向右推导</span></span><br></pre></td></tr></table></figure><blockquote><p>使用auto声明了两个类型相同变量x和y，并用逗号进行分隔，这可以通过编译。而在声明变量i和j的时候，按照我们所说的第一变量用于推导类型的规则，那么由于x所推导出的类型是int，那么对于变量j而言，其声明就变成了int j =3.14f，这无疑会导致精度的损失。而对于变量m和n，就变得非常有趣，这里似乎是auto被替换成了int，所以m是一个int *指针类型，而n只是一个int类型。同样的情况也发生在变量o、p、q上，这里o是一个类型为int的变量，p是o的引用，而q是p的指针。auto的类型推导按照从左往右，且类似于字面替换的方式进行。事实上，标准里称auto是一个将要推导出的类型的“占位符”（placeholder）。这样的规则无疑是直观而让人略感意外的。当然，为了不必要的繁琐记忆，程序员可以选择每一个auto变量的声明写成一行（有些观点也认为这是好的编程规范）。</p></blockquote><h4 id="只要能够进行推导的地方，C-11都为auto指定了详细的规则，保证编译器能够正确地推导出变量的类型"><a href="#只要能够进行推导的地方，C-11都为auto指定了详细的规则，保证编译器能够正确地推导出变量的类型" class="headerlink" title="只要能够进行推导的地方，C++11都为auto指定了详细的规则，保证编译器能够正确地推导出变量的类型"></a>只要能够进行推导的地方，C++11都为auto指定了详细的规则，保证编译器能够正确地推导出变量的类型</h4><p>包括C++11新引入的初始化列表，以及new，都可以使用auto关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> y &#123;<span class="number">1</span>&#125;;      <span class="comment">// 使用初始化列表的auto  </span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in"><span class="keyword">auto</span></span>(<span class="number">1</span>);    <span class="comment">// 可以用于new       </span></span><br></pre></td></tr></table></figure><blockquote><p>auto变量y的初始化使用了初始化列表，编译器可以保证y的类型推导为int。而z指针所指向的堆变量在分配时依然选择让编译器对类型进行推导，同样的，编译器也能够保证这种方式下类型推导的正确性。</p></blockquote><h4 id="不过auto也不是万能的，受制于语法的二义性，或者是实现的困难性，auto往往也会有使用上的限制"><a href="#不过auto也不是万能的，受制于语法的二义性，或者是实现的困难性，auto往往也会有使用上的限制" class="headerlink" title="不过auto也不是万能的，受制于语法的二义性，或者是实现的困难性，auto往往也会有使用上的限制"></a>不过auto也不是万能的，受制于语法的二义性，或者是实现的困难性，auto往往也会有使用上的限制</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>      </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;      </span><br><span class="line"><span class="comment">//void fun(auto x =1)&#123;&#125;  // 1: auto函数参数，无法通过编译</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str</span>&#123;</span></span><br><span class="line"><span class="comment">//auto var = 10;    // 2: auto非静态成员变量，无法通过编译</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> x[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">auto</span> y = x;</span><br><span class="line"><span class="comment">// auto z[3] = x; // 3: auto数组，无法通过编译    // 4: auto模板参数（实例化时），无法通过编译</span></span><br><span class="line">vector&lt;<span class="keyword">auto</span>&gt; v = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><p>①、对于函数fun来说，auto不能是其形参类型。可能读者感觉对于fun来说，由于其有默认参数，所以应该推导fun形参x的类型为int型。但事实却无法符合大家的想象。因为auto是不能做形参的类型的。如果程序员需要泛型的参数，还是需要求助于模板。</p><p>②、对于结构体来说，非静态成员变量的类型不能是auto的。同样的，由于var定义了初始值，读者可能认为auto可以推导str成员var的类型为int的。但编译器阻止auto对结构体中的非静态成员进行推导，即使成员拥有初始值。</p><p>③、声明auto数组。我们可以看到，main中的x是一个数组，y的类型是可以推导的，而声明auto z[3]这样的数组同样会被编译器禁止。</p><p>④、在实例化模板的时候使用auto作为模板参数，如main中我们声明的vector<auto> v。虽然读者可能认为这里一眼而知是int类型，但编译器却阻止了编译。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、Linux开发常用命令</title>
      <link href="/2021/11/10/2%E3%80%81Linux/%E4%BA%8C%E3%80%81Linux%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/10/2%E3%80%81Linux/%E4%BA%8C%E3%80%81Linux%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="二、Linux开发常用命令"><a href="#二、Linux开发常用命令" class="headerlink" title="二、Linux开发常用命令"></a>二、Linux开发常用命令</h2><h3 id="常用的系统工作命令"><a href="#常用的系统工作命令" class="headerlink" title="常用的系统工作命令"></a>常用的系统工作命令</h3><h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量]”。</p><p>使用$变量的方式提取变量SHELL的值，并将其输出到屏幕上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br><span class="line">输出： /bin/bash</span><br></pre></td></tr></table></figure><h4 id="reboot命令"><a href="#reboot命令" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统</p><blockquote><p><strong>语法格式：</strong> reboot [参数]  </p></blockquote><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此默认只能使用root管理员来重启。</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-n</th><th>在重开机前不做将记忆体资料写回硬盘的动作 帮助</th></tr></thead><tbody><tr><td>-w</td><td>并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里</td></tr><tr><td>-d</td><td>不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）</td></tr><tr><td>-f</td><td>强迫重开机，不呼叫 shutdown 这个指令</td></tr><tr><td>-i</td><td>在重开机之前先把所有网络相关的装置先停止</td></tr></tbody></table><h4 id="poweroff命令"><a href="#poweroff命令" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统</p><blockquote><p><strong>语法格式：</strong>poweroff [参数]</p></blockquote><p>该命令与reboot命令相同，都会涉及硬件资源的管理权限，因此默认只有root管理员才可以关闭电脑。</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-n</th><th>关闭操作系统时不执行sync操作</th></tr></thead><tbody><tr><td>-w</td><td>不真正关闭操作系统，仅在日志文件“/var/log/wtmp”中</td></tr><tr><td>-d</td><td>关闭操作系统时，不将操作写入日志文件“/var/log/wtmp”中添加相应的记录</td></tr><tr><td>-f</td><td>强制关闭操作系统</td></tr><tr><td>-i</td><td>关闭操作系统之前关闭所有的网络接口</td></tr><tr><td>-h</td><td>关闭操作系统之前将系统中所有的硬件设置为备用模式</td></tr></tbody></table><h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，</p><blockquote><p><strong>语法格式：</strong>ps [参数] </p></blockquote><p>该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。 </p><p><strong>常用参数：</strong>﻿</p><table><thead><tr><th>-a</th><th>显示所有终端机下执行的程序，除了阶段作业领导者之外</th></tr></thead><tbody><tr><td>a</td><td>显示现行终端机下的所有程序，包括其他用户的程序</td></tr><tr><td>-A</td><td>显示所有程序</td></tr><tr><td>-c</td><td>显示CLS和PRI栏位</td></tr><tr><td>c</td><td>列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示</td></tr><tr><td>-C &lt;指令名称&gt;</td><td>指定执行指令的名称，并列出该指令的程序的状况</td></tr><tr><td>-d</td><td>显示所有程序，但不包括阶段作业领导者的程序</td></tr><tr><td>-e</td><td>此选项的效果和指定”A”选项相同</td></tr><tr><td>e</td><td>列出程序时，显示每个程序所使用的环境变量</td></tr><tr><td>-f</td><td>显示UID,PPIP,C与STIME栏位</td></tr><tr><td>f</td><td>用ASCII字符显示树状结构，表达程序间的相互关系</td></tr><tr><td>-g &lt;群组名称&gt;</td><td>此选项的效果和指定”-G”选项相同，当亦能使用阶段作业领导者的名称来指定</td></tr><tr><td>g</td><td>显示现行终端机下的所有程序，包括群组领导者的程序</td></tr></tbody></table><h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID的服务进程。</p><blockquote><p><strong>语法格式：</strong>kill [参数] [进程号]</p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-l</th><th>列出系统支持的信号</th></tr></thead><tbody><tr><td>-s</td><td>指定向进程发送的信号</td></tr><tr><td>-a</td><td>处理当前进程时不限制命令名和进程号的对应关系</td></tr><tr><td>-p</td><td>指定kill命令只打印相关进程的进程号，而不发送任何信号</td></tr></tbody></table><h4 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，</p><blockquote><p><strong>语法格式：</strong>“killall [参数] [进程名称]”。</p></blockquote><h3 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h3><h4 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h4><p>ifconfig命令用于获取网卡配置与网络状态等信息，</p><blockquote><p>格式为“ifconfig [网络设备] [参数]”。</p></blockquote><h4 id="uname命令"><a href="#uname命令" class="headerlink" title="uname命令"></a>uname命令</h4><p>uname命令用于查看系统内核与系统版本等信息，</p><blockquote><p><strong>语法格式：</strong>uname [参数] </p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-a</th><th>显示系统所有相关信息</th></tr></thead><tbody><tr><td>-m</td><td>显示计算机硬件架构</td></tr><tr><td>-n</td><td>显示主机名称</td></tr><tr><td>-r</td><td>显示内核发行版本号</td></tr><tr><td>-s</td><td>显示内核名称</td></tr><tr><td>-v</td><td>显示内核版本</td></tr><tr><td>-p</td><td>显示主机处理器类型</td></tr><tr><td>-o</td><td>显示操作系统名称</td></tr><tr><td>-i</td><td>显示硬件平台</td></tr></tbody></table><p>在使用uname命令时，一般会固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。</p><h3 id="工作目录切换命令"><a href="#工作目录切换命令" class="headerlink" title="工作目录切换命令"></a>工作目录切换命令</h3><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p>pwd命令用于显示用户当前所处的工作目录，</p><blockquote><p><strong>语法格式:</strong> pwd [参数]</p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-L</th><th>显示逻辑路径</th></tr></thead></table><h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h4><blockquote><p><strong>语法格式：</strong>cd [参数] [目录名] </p></blockquote><p>cd命令用于切换工作路径，格式为“cd [目录名称]”。是最常用的一个Linux命令之一。</p><p>可以通过cd命令迅速、灵活地切换到不同的工作目录。</p><p>除了常见的切换目录方式：</p><blockquote><p>可以使用“cd -”命令返回到上一次所处的目录，</p><p>使用“cd..”命令进入上级目录，</p><p>使用“cd ~”命令切换到当前用户的家目录，</p><p>使用“cd ~username”切换到其他用户的家目录。</p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-P</th><th>如果切换的目标目录是一个符号链接，则直接切换到符号链接指向的目标目录</th></tr></thead><tbody><tr><td>-L</td><td>如果切换的目标目录是一个符号链接，则直接切换到符号链接名所在的目录</td></tr><tr><td>–</td><td>仅使用”-“选项时，当前目录将被切换到环境变量”OLDPWD”对应值的目录</td></tr><tr><td>~</td><td>切换至当前用户目录</td></tr><tr><td>..</td><td>切换至当前目录位置的上一级目录</td></tr></tbody></table><h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><p>ls命令用于显示指定工作目录下的内容及属性信息。</p><blockquote><p><strong>语法格式:</strong> ls [选项] [文件] </p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-a</th><th>显示所有文件及目录 (包括以“.”开头的隐藏文件)</th></tr></thead><tbody><tr><td>-l</td><td>使用长格式列出文件及目录信息</td></tr><tr><td>-r</td><td>将文件以相反次序显示(默认依英文字母次序)</td></tr><tr><td>-t</td><td>根据最后的修改时间排序</td></tr><tr><td>-A</td><td>同 -a ，但不列出 “.” (当前目录) 及 “..” (父目录)</td></tr><tr><td>-S</td><td>根据文件大小排序</td></tr><tr><td>-R</td><td>递归列出所有子目录</td></tr></tbody></table><h3 id="文本文件编辑命令"><a href="#文本文件编辑命令" class="headerlink" title="文本文件编辑命令"></a>文本文件编辑命令</h3><h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><p>cat命令用于查看纯文本文件（内容较少的）。</p><blockquote><p>**语法格式:**“cat [选项] [文件]”</p></blockquote><p>注意：当文件内容较大时，文本内容会在屏幕上快速闪动（滚屏），用户往往看不清所显示的具体内容。因此对于较长文件内容可以按Ctrl+S键，停止滚屏；以及Ctrl+Q键可以恢复滚屏；而按Ctrl+C（中断）键则可以终止该命令的执行。</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-n</th><th>显示行数（空行也编号）</th></tr></thead><tbody><tr><td>-s</td><td>显示行数（多个空行算一个编号）</td></tr><tr><td>-b</td><td>显示行数（空行不编号）</td></tr><tr><td>-E</td><td>每行结束处显示$符号</td></tr><tr><td>-T</td><td>将TAB字符显示为 ^I符号</td></tr><tr><td>-v</td><td>使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外</td></tr><tr><td>-e</td><td>等价于”-vE”组合</td></tr><tr><td>-t</td><td>等价于”-vT”组合</td></tr><tr><td>-A</td><td>等价于 -vET组合</td></tr><tr><td>–help</td><td>显示帮助信息</td></tr><tr><td>–version</td><td>显示版本信息</td></tr></tbody></table><h4 id="more命令-–-显示文本文件内容"><a href="#more命令-–-显示文本文件内容" class="headerlink" title="more命令 – 显示文本文件内容"></a>more命令 – 显示文本文件内容</h4><p>more命令用于将内容较长的文本文件内容（不能在一屏显示完）进行分屏显示，并且支持在显示时定位关键字。而对于内容较少的文本文件内容则推荐使用cat命令查看。</p><blockquote><p><strong>语法格式：</strong>more [参数] [文件] </p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-num</th><th>指定每屏显示的行数</th></tr></thead><tbody><tr><td>-l</td><td>more在通常情况下把 <strong>^L</strong> 当作特殊字符, 遇到这个字符就会暂停,-l选项可以阻止这种特性</td></tr><tr><td>-f</td><td>计算实际的行数，而非自动换行的行数</td></tr><tr><td>-p</td><td>先清除屏幕再显示文本文件的剩余内容</td></tr><tr><td>-c</td><td>与-p相似，不滚屏，先显示内容再清除旧内容</td></tr><tr><td>-s</td><td>多个空行压缩成一行显示</td></tr><tr><td>-u</td><td>禁止下划线</td></tr><tr><td>+/pattern</td><td>在每个文档显示前搜寻该字(pattern)，然后从该字串之后开始显示</td></tr><tr><td>+num</td><td>从第 num 行开始显示</td></tr></tbody></table><h4 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h4><p>head命令以行为单位，取文件的内容,后面不接参数时默认打印前10行。</p><p><strong>语法格式：</strong>head [参数] [文件]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-n</th><th>后面接数字，代表显示几行的意思</th></tr></thead><tbody><tr><td>-c</td><td>指定显示头部内容的字符数</td></tr><tr><td>-v</td><td>总是显示文件名的头信息</td></tr><tr><td>-q</td><td>不显示文件名的头信息</td></tr></tbody></table><h3 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h3><h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><p>touch命令用于创建空白文件或设置文件的时间；</p><blockquote><p><strong>语法格式：</strong>touch [参数] [文件]</p></blockquote><p><strong>常用参数：</strong>﻿</p><table><thead><tr><th>-a</th><th>改变档案的读取时间记录</th></tr></thead><tbody><tr><td>-m</td><td>改变档案的修改时间记录</td></tr><tr><td>-r</td><td>使用参考档的时间记录，与 –file 的效果一样</td></tr><tr><td>-c</td><td>不创建新文件</td></tr><tr><td>-d</td><td>设定时间与日期，可以使用各种不同的格式</td></tr><tr><td>-t</td><td>设定档案的时间记录，格式与 date 命令相同</td></tr><tr><td>–no-create</td><td>不创建新文件</td></tr><tr><td>–help</td><td>显示帮助信息</td></tr><tr><td>–version</td><td>列出版本讯息</td></tr></tbody></table><h4 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h4><p>mkdir命令用于创建空白的目录；</p><p><strong>语法格式 :</strong> mkdir [参数] [目录] </p><p><strong>常用参数：</strong></p><table><thead><tr><th>-p</th><th>递归创建多级目录</th></tr></thead><tbody><tr><td>-m</td><td>建立目录的同时设置目录的权限</td></tr><tr><td>-z</td><td>设置安全上下文</td></tr><tr><td>-v</td><td>显示目录的创建过程</td></tr></tbody></table><p>在工作目录下，建立一个名为 dir 的子目录： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# mkdir dir</span><br></pre></td></tr></table></figure><p> 在目录/usr/linuxcool下建立子目录dir，并且设置文件属主有读、写和执行权限，其他人无权访问 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# mkdir -m 700 /usr/linuxcool/dir</span><br></pre></td></tr></table></figure><h4 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h4><p>cp命令可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。</p><p><strong>语法格式：</strong>cp [参数] [文件] </p><p><strong>常用参数：</strong></p><table><thead><tr><th>-f</th><th>若目标文件已存在，则会直接覆盖原文件</th></tr></thead><tbody><tr><td>-i</td><td>若目标文件已存在，则会询问是否覆盖</td></tr><tr><td>-p</td><td>保留源文件或目录的所有属性</td></tr><tr><td>-r</td><td>递归复制文件和目录</td></tr><tr><td>-d</td><td>当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录</td></tr><tr><td>-l</td><td>对源文件建立硬连接，而非复制文件</td></tr><tr><td>-s</td><td>对源文件建立符号连接，而非复制文件</td></tr><tr><td>-b</td><td>覆盖已存在的文件目标前将目标文件备份</td></tr><tr><td>-v</td><td>详细显示cp命令执行的操作过程</td></tr><tr><td>-a</td><td>等价于“dpr”选项</td></tr></tbody></table><p>例如： 交互式地将目录 /usr/linuxcool 中的所有.c文件复制到目录 dir 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# cp -r /usr/linuxcool/*.c dir</span><br></pre></td></tr></table></figure><h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><p>mv命令用于剪切文件或将文件重命名，mv与cp的结果不同。mv命令好像文件“搬家”，文件名称发生改变，但个数并未增加。而cp命令是对文件进行复制操作，文件个数是有增加的。</p><blockquote><p><strong>语法格式：</strong>mv [参数]</p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-i</th><th>若存在同名文件，则向用户询问是否覆盖</th></tr></thead><tbody><tr><td>-f</td><td>覆盖已有文件时，不进行任何提示</td></tr><tr><td>-b</td><td>当文件存在时，覆盖前为其创建一个备份</td></tr><tr><td>-u</td><td>当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作</td></tr></tbody></table><h4 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h4><p>rm命令用于删除文件或目录，格式为“rm [选项]文件”。</p><p><strong>语法格式：</strong>rm [参数] [文件]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-f</th><th>忽略不存在的文件，不会出现警告信息</th></tr></thead><tbody><tr><td>-i</td><td>删除前会询问用户是否操作</td></tr><tr><td>-r/R</td><td>递归删除</td></tr><tr><td>-v</td><td>显示指令的详细执行过程</td></tr></tbody></table><p>直接删除，不会有任何提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# rm -f test.txt.bz2  </span><br></pre></td></tr></table></figure><p>递归删除目录及目录下所有文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# mkdir /data/log</span><br><span class="line">[root@linuxcool ~]# rm -rf /data/log</span><br></pre></td></tr></table></figure><p>删除当前目录下所有文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# rm -rf *</span><br></pre></td></tr></table></figure><h3 id="打包压缩与搜索命令"><a href="#打包压缩与搜索命令" class="headerlink" title="打包压缩与搜索命令"></a>打包压缩与搜索命令</h3><h4 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h4><p>tar命令用于对文件进行打包压缩或解压，</p><blockquote><p><strong>语法格式：</strong>tar [参数] [文件或目录]</p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-A</th><th>新增文件到以存在的备份文件</th></tr></thead><tbody><tr><td>-B</td><td>设置区块大小</td></tr><tr><td>-c</td><td>建立新的备份文件</td></tr><tr><td>-C &lt;目录&gt;</td><td>切换工作目录，先进入指定目录再执行压缩/解压缩操作，可用于仅压缩特定目录里的内容或解压缩到特定目录</td></tr><tr><td>-d</td><td>记录文件的差别</td></tr><tr><td>-x</td><td>从归档文件中提取文件</td></tr><tr><td>-t</td><td>列出备份文件的内容</td></tr><tr><td>-z</td><td>通过gzip指令压缩/解压缩文件，文件名最好为*.tar.gz</td></tr><tr><td>-Z</td><td>通过compress指令处理备份文件</td></tr><tr><td>-f&lt;备份文件&gt;</td><td>指定备份文件</td></tr><tr><td>-v</td><td>显示指令执行过程</td></tr><tr><td>-r</td><td>添加文件到已经压缩的文件</td></tr><tr><td>-u</td><td>添加改变了和现有的文件到已经存在的压缩文件</td></tr><tr><td>-j</td><td>通过bzip2指令压缩/解压缩文件，文件名最好为*.tar.bz2</td></tr><tr><td>-v</td><td>显示操作过程</td></tr><tr><td>-l</td><td>文件系统边界设置</td></tr><tr><td>-k</td><td>保留原有文件不覆盖</td></tr><tr><td>-m</td><td>保留文件不被覆盖</td></tr><tr><td>-w</td><td>确认压缩文件的正确性</td></tr><tr><td>-p</td><td>保留原来的文件权限与属性</td></tr><tr><td>-P</td><td>使用文件名的绝对路径，不移除文件名称前的“/”号</td></tr><tr><td>-N &lt;日期格式&gt;</td><td>只将较指定日期更新的文件保存到备份文件里</td></tr><tr><td>– -exclude=&lt;范本样式&gt;</td><td>排除符合范本样式的文件</td></tr><tr><td>– -remove-files</td><td>归档/压缩之后删除源文件</td></tr></tbody></table><p>把指定的文件进行打包压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar-czvf压缩包名称．tar.gz要打包的目录</span><br></pre></td></tr></table></figure><p>解压命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf压缩包名称．tar.gz</span><br></pre></td></tr></table></figure><h4 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h4><p> 强大的文本搜索工具，grep命令的选项用于对搜索过程的补充，而其命令的模式十分灵活，可以是变量、字符串、正则表达式。</p><p>需要注意的是：一当模式中包含了空格，务必要用双引号将其引起来。</p><p><strong>语法格式：</strong> grep [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-i</th><th>搜索时，忽略大小写</th></tr></thead><tbody><tr><td>-c</td><td>只输出匹配行的数量</td></tr><tr><td>-l</td><td>只列出符合匹配的文件名，不列出具体的匹配行</td></tr><tr><td>-n</td><td>列出所有的匹配行，显示行号</td></tr><tr><td>-h</td><td>查询多文件时不显示文件名</td></tr><tr><td>-s</td><td>不显示不存在、没有匹配文本的错误信息</td></tr><tr><td>-v</td><td>显示不包含匹配文本的所有行</td></tr><tr><td>-w</td><td>匹配整词</td></tr><tr><td>-x</td><td>匹配整行</td></tr><tr><td>-r</td><td>递归搜索</td></tr><tr><td>-q</td><td>禁止输出任何结果，已退出状态表示搜索是否成功</td></tr><tr><td>-b</td><td>打印匹配行距文件头部的偏移量，以字节为单位</td></tr><tr><td>-o</td><td>与-b结合使用，打印匹配的词据文件头部的偏移量，以字节为单位</td></tr></tbody></table><h3 id="用户身份与文件权限"><a href="#用户身份与文件权限" class="headerlink" title="用户身份与文件权限"></a>用户身份与文件权限</h3><h4 id="sudo-切换用户执行身份命令"><a href="#sudo-切换用户执行身份命令" class="headerlink" title="sudo 切换用户执行身份命令"></a>sudo 切换用户执行身份命令</h4><p>sudo 是一种权限管理机制，管理员可以授权于一些普通用户去执行一些 root 执行的操作，而不需要知道 root 的密码。</p><blockquote><p><strong>语法格式：</strong>sudo [参数]</p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-v</th><th>因为 sudo 在第一次执行时或是在 N分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过N分钟，也会问密码</th></tr></thead><tbody><tr><td>-k</td><td>强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）</td></tr><tr><td>-b</td><td>将要执行的指令放在背景执行</td></tr><tr><td>-p</td><td>prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称，%h 会显示主机名称</td></tr><tr><td>-s</td><td>执行环境变数中的SHELL 所指定的shell ，或是 /etc/passwd 里所指定的 shell</td></tr><tr><td>command</td><td>要以系统管理者身份（或以 -u 更改为其他人）执行的指令</td></tr></tbody></table><h4 id="adduser-添加用户命令"><a href="#adduser-添加用户命令" class="headerlink" title="adduser 添加用户命令"></a>adduser 添加用户命令</h4><p>该命令用于新增使用者帐号或更新预设的使用者资料。adduser 与 useradd 指令为同一指令（经由符号连结 symbolic link）</p><blockquote><p><strong>语法格式：</strong>adduser [参数] </p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>-c</th><th>加上备注文件，备注文字会存储在 passwd 的备注参数中</th></tr></thead><tbody><tr><td>-d</td><td>指定用户登录时的起始目录</td></tr><tr><td>-D</td><td>变更默认值</td></tr><tr><td>-e</td><td>设定此帐号的使用期限（格式为 YYYY-MM-DD），预设值为永久有效</td></tr><tr><td>-f &lt;缓冲天数&gt;</td><td>指定在密码过期后多少天即关闭该帐号</td></tr><tr><td>-g &lt;群组&gt;</td><td>指定用户所属的群组</td></tr><tr><td>-G &lt;群组&gt;</td><td>指定用户所属的附加群组</td></tr><tr><td>-m</td><td>自动建立用户的登入目录</td></tr><tr><td>-M</td><td>不要自动建立用户的登入目录</td></tr><tr><td>-n</td><td>取消建立以用户名称为名的群组</td></tr><tr><td>-r</td><td>建立系统帐号</td></tr><tr><td>-s <shell></td><td>指定用户登入后所使用的shell</td></tr><tr><td>-u <uid></td><td>指定用户ID</td></tr></tbody></table><h4 id="deluser-删除用户命令"><a href="#deluser-删除用户命令" class="headerlink" title="deluser  删除用户命令"></a>deluser  删除用户命令</h4><p>deluser命令用于删除用户。将一个用户从一个组中删除（即退出用户组）</p><blockquote><p><strong>语法格式：</strong>deluser [参数] </p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>–remove-all-files</th><th>删除用户拥有的所有文件</th></tr></thead><tbody><tr><td>–remove-home</td><td>删除用户的主目录和邮件后台处理程序</td></tr><tr><td>–backup-to</td><td>目标目录进行备份</td></tr><tr><td>–system</td><td>只有系统用户才能删除</td></tr></tbody></table><h4 id="su-切换用户命令"><a href="#su-切换用户命令" class="headerlink" title="su  切换用户命令"></a>su  切换用户命令</h4><p>su命令用于切换当前用户身份到指定用户或者以指定用户的身份执行命令或程序。 </p><p>普通用户切换到root用户，可以使用su – 或su root,但是必须输入root密码才能完成切换。root用户切换到普通用户，可以使用su username,不需要输入任何密码即可完成切换。</p><p><strong>语法格式:</strong> su [选项] [用户名]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-c或–command</th><th>执行完指定的指令后，即恢复原来的身份</th></tr></thead><tbody><tr><td>-f或–fast</td><td>适用于csh与tsch，使shell不用去读取启动文件</td></tr><tr><td>-l或–login</td><td>改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,logname,此外，也会变更PATH变量</td></tr><tr><td>-m,-p或–preserve-environment</td><td>变更身份时，不要变更环境变量</td></tr><tr><td>-s或–shell</td><td>指定要执行的shell</td></tr><tr><td>–help</td><td>显示帮助信息</td></tr><tr><td>–version</td><td>显示版本信息</td></tr></tbody></table><p>切换到linuxcool用户，并改变为linuxcool用户环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# su - linuxcool  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无人驾驶-感知层-传感器（一）——激光雷达</title>
      <link href="/2021/11/10/8%E3%80%81%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8F%8ASLAM/%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6-%E6%84%9F%E7%9F%A5%E5%B1%82-%E4%BC%A0%E6%84%9F%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE/"/>
      <url>/2021/11/10/8%E3%80%81%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8F%8ASLAM/%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6-%E6%84%9F%E7%9F%A5%E5%B1%82-%E4%BC%A0%E6%84%9F%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="无人驾驶-感知层-传感器（一）——激光雷达"><a href="#无人驾驶-感知层-传感器（一）——激光雷达" class="headerlink" title="无人驾驶-感知层-传感器（一）——激光雷达"></a>无人驾驶-感知层-传感器（一）——激光雷达</h3><h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><p>2021年最火爆的技术毫无疑问是无人驾驶技术，而无人驾驶技术里面竞争最激烈的便是激光雷达，蔚来1个、小鹏2个、北汽极狐αS2个、威马3个…智能汽车“军备竞赛”正在上演。那我们来看看激光雷达它为什么这么备受青睐。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86/image-20211101164030415.png"></p><p><strong>激光雷达</strong>：LiDAR<strong>（</strong>Light Detection and Ranging），是以发射激光束探测目标的位置、速度等特征量的雷达系统。近年来在机器人、无人驾驶领域得到了广泛的应用。</p><h4 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h4><p>工作原理是向目标发射探测信号(激光束）,然后将接收到的从目标反射回来的信号（目标回波）与发射信号进行比较,作适当处理后,就可获得目标的有关信息,如目标距离、方位、高度、速度、姿态、甚至形状等参数,从而对车辆、行人等目标进行探测、跟踪和识别。可以通过三角法测距或者TOF测距计算出激光雷达与物体的距离。因此对应有三角测距激光雷达和TOF测距激光雷达。</p><h5 id="2-1、三角测距激光雷达"><a href="#2-1、三角测距激光雷达" class="headerlink" title="2.1、三角测距激光雷达"></a>2.1、三角测距激光雷达</h5><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86/pIYBAGBvxlyAOmXDAABy6qDFssI146.png"></p><p>基本原理如上图所示。雷达测距模块向外发射<a href="http://www.elecfans.com/tags/%E7%BA%A2%E5%A4%96/">红外</a>激光，入射到被测物体上之后，部分散射光经接收透镜汇聚到线阵<a href="http://www.elecfans.com/tags/%E5%9B%BE%E5%83%8F%E4%BC%A0%E6%84%9F%E5%99%A8/">图像传感器</a>（CCD/CMOS）上成像。</p><p>由图中的几何关系可知，位于不同距离的物体，出射激光形成的光斑在线阵上成像的位置亦不相同；另一方面，测距模块的内部结构固定不变，接收透镜的焦距f，以及发射光路光轴与接收透镜主光轴之间的偏移（即基<a href="http://www.hqpcb.com/zhuoluye11/?tid=26&plan=fashaoyou">线距</a>离）L这两项参数都是已知的。根据三角形的相似关系，即可计算出物体的距离D如下：</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86/pIYBAGBvxlyAA1UwAAAGWnHapLU487.png"></p><p>以上原理介绍为最简化的情况。但在实际应用中，为了提高距离分辨率，以及充分利用线阵图像传感器的像素资源，通常将发射光路光轴与接收透镜主光轴布置为呈一定斜角（而非图示中的平行关系），但相似三角形的基本原理并无变化。</p><p><strong>影响三角测距激光雷达精度的参数：距离分辨率和测量速率。</strong></p><p><strong>距离分辨率：</strong>就是对不同距离目标的区分能力，相当于用尺子量长度时，使用的尺子的最小刻度是多少，三角测距的一大特点是这把“尺子”的刻度是不均匀的。对于比较近的距离区间，目标距离的变化会引起成像点位置的显著变化；而当目标位于远处时，即便距离发生很大的变化，体现到成像点上只会产生一点点移动，也就是说，三角测距的距离分辨率会随着距离的变远而急速下降。</p><p><strong>测量速率：</strong>机械式单线激光雷达在旋转扫描的同时对不同方向上的目标进行测距，因此测量速率直接决定了雷达能否以更快的速率扫描（对应更高的帧率），以及在完成一周扫描时能否输出更多的测量点（对应更高的角度分辨率）。为了达到一定的距离分辨率，三角测距激光雷达往往都会使用较高分辨率的线阵图像传感器，通常具有数千个像素点，每次测距时需要将这些像素点的灰度值读出并交给 DSP 处理，整个读出和处理的过程需要耗费一定时间，从而限制了三角测距激光雷达的数据速率。</p><h5 id="2-1、TOF测距激光雷达"><a href="#2-1、TOF测距激光雷达" class="headerlink" title="2.1、TOF测距激光雷达"></a>2.1、TOF测距激光雷达</h5><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86/pIYBAGBvxlyAcQkxAAB7AJCWE7A480.png"></p><p>​    </p><p><strong>原理：</strong>①、开始测距时，脉冲驱动<a href="http://www.hqpcb.com/">电路</a>驱动激光器发射一个持续时间极短但瞬时功率非常高的光脉冲，同时<a href="http://www.hqchip.com/app/1045">计时</a>单元启动计时；</p><p>​            ②、光脉冲经发射光路出射后，到达被测物体的表面并向各方向散射。测距模块的接收光路收到部分散射光能量，通过光电器件转化为光电流，输送给回波信号处理电路；</p><p>​            ③、回波信号处理电路将光电流转化为电压信号，经过一级或数级放大并调理后，得到一个回波信号对应的电脉冲，用于触发计时单元停止计时；</p><p>​            ④、此时，计时单元记录的时间间隔就代表了激光脉冲从发射到返回的全程所用的时间，使用这个时间值乘以光速并除以2，即可得到测距单元与被测目标之间的距离值。</p><p>ToF测距的原理很容易理解，但具体工程实现时有不少技术难点需要解决，这主要是由于ToF测距的工作条件比较极端，非常大（脉冲发射峰值）、非常弱（脉冲回波）和非常快（纳秒/皮秒级别）的信号，这就对整个电路的驱动能力、带宽和噪声抑制水平提出了很高的要求。但它的优势在于，只要解决了上述这些问题，整个测距系统可以实现非常高的性能。</p><h4 id="3、优点"><a href="#3、优点" class="headerlink" title="3、优点"></a>3、优点</h4><p>①、具有极高的分辨率：激光雷达工作于光学波段，频率比微波高2~3个数量级以上，与微波雷达相比，激光雷达具有极高的分辨率、角分辨率和速度分辨率；</p><p>②、抗干扰能力强:激光波长短，可发散角非常小的激光束，多路径效应小（不会形成定向发射于微波或毫米波产生多路径效应），可探测低空/超低空目标；</p><p>③、获取的信息量丰富：可直接获取目标的距离、角度、反射强度、速度等信息，生成目标对位图像；</p><p>④、可全天候工作：激光主动探测，不依赖于外界光照条件或目标本身的辐射特性。它只需发射自己的激光束，通过探测发射激光束的回波信号来获取目标信息。</p><h4 id="4、缺点"><a href="#4、缺点" class="headerlink" title="4、缺点"></a>4、缺点</h4><p>①、成本：激光雷达的成本是限定无人驾驶落地的原因之一；</p><p>②、应用坏境：易受天气影响（如大雾、雨天、烟尘会影响激光雷达精度）；</p><p>③、属性识别能力较弱：激光雷达的点云数据是物体的几何外形呈现，无法如同人眼视觉一样分辨物体的物理特性，如颜色、纹理等。</p><h4 id="5、分类"><a href="#5、分类" class="headerlink" title="5、分类"></a>5、分类</h4><p>①、根据线束多少，激光雷达可分为单线束和多线束（2线、4线、8线、16线、32线、64线、128线，2的倍速）。</p><p>单线束激光雷达扫描一次只能产生一条扫描线，所获得的数据为2D数据，无法区别有关物体的3D信息；多线束激光雷达可将多个横向扫描结果纵向叠加，从而获取3D数据，线束越多，纵向的垂直视角越大，价格越贵。</p><p>②、按照扫描方式，激光雷达主要分为三类：</p><p>一是光机结构整体旋转的<strong>机械式激光雷达</strong>（以Velydone公司为代表），在此基础上衍生出了收发模块不动的棱镜或转镜的激光雷达（如Livox览沃）；</p><p>二是<strong>半固态激光雷达</strong>，主要采用<strong>MEMS微振镜</strong>（Luminar/Innoviz等品牌）；</p><p>三是<strong>固态激光雷达</strong>，又分为了<strong>电子扫描</strong>或者<strong>整体曝光Flash面阵</strong>（Leddar/Ibeo/Ouster），以及<strong>基于光学相控的OPA方式</strong>（Quanergy/Lumotive），当前市场主流正朝着MEMS方向发展。</p><h4 id="6、公司"><a href="#6、公司" class="headerlink" title="6、公司"></a>6、公司</h4><p><strong>速腾聚创</strong>、华为、<strong>Livox</strong>、<strong>图达通 Innovusion</strong>、禾赛科技、镭神智能</p><h4 id="7、应用"><a href="#7、应用" class="headerlink" title="7、应用"></a>7、应用</h4><blockquote><p>参考：<a href="http://www.elecfans.com/d/1566850.html">http://www.elecfans.com/d/1566850.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 激光雷达-SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 激光雷达-SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1、PicGo+Gitee搭建图床</title>
      <link href="/2021/11/10/9%E3%80%81hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1%E3%80%81PicGo+gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2021/11/10/9%E3%80%81hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1%E3%80%81PicGo+gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="1、PicGo-Gitee搭建图床"><a href="#1、PicGo-Gitee搭建图床" class="headerlink" title="1、PicGo+Gitee搭建图床"></a>1、PicGo+Gitee搭建图床</h2><h3 id="1-1、新建仓库"><a href="#1-1、新建仓库" class="headerlink" title="1.1、新建仓库"></a>1.1、新建仓库</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110125935.png"></p><h3 id="1-2、配置仓库"><a href="#1-2、配置仓库" class="headerlink" title="1.2、配置仓库"></a>1.2、配置仓库</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110125941.png"></p><h3 id="1-3、生成密钥"><a href="#1-3、生成密钥" class="headerlink" title="1.3、生成密钥"></a>1.3、生成密钥</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110125945.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110130007.png"></p><p>这个密钥一定要保存好，之后就显示不了了</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110130239.png"></p><h2 id="2、下载PigGo软件"><a href="#2、下载PigGo软件" class="headerlink" title="2、下载PigGo软件"></a>2、下载PigGo软件</h2><h3 id="2-1、下载连接"><a href="#2-1、下载连接" class="headerlink" title="2.1、下载连接"></a>2.1、下载连接</h3><blockquote><p><a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110130012.png"></p><p>然后直接安装。。。</p><h3 id="2-2、下载gitee插件"><a href="#2-2、下载gitee插件" class="headerlink" title="2.2、下载gitee插件"></a>2.2、下载gitee插件</h3><p><strong>注意：一定要以管理员身份运行后在安装！，不然会一直安装不了！</strong></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110130016.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110130019.png"></p><h3 id="2-3、搭建图床"><a href="#2-3、搭建图床" class="headerlink" title="2.3、搭建图床"></a>2.3、搭建图床</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110132304.png"></p><p>可以把其它不用的图床关闭</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110132308.png"></p><h3 id="2-4、上传"><a href="#2-4、上传" class="headerlink" title="2.4、上传"></a>2.4、上传</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110130955.png"></p><p>显示</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Typroa+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20211110131000.png"></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思岚SLAMTEC A1开箱测试</title>
      <link href="/2021/11/10/8%E3%80%81%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8F%8ASLAM/%E4%B8%80%E3%80%81%E6%80%9D%E5%B2%9ASLAMTEC%20A1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/11/10/8%E3%80%81%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8F%8ASLAM/%E4%B8%80%E3%80%81%E6%80%9D%E5%B2%9ASLAMTEC%20A1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="思岚SLAMTEC-A1开箱测试"><a href="#思岚SLAMTEC-A1开箱测试" class="headerlink" title="思岚SLAMTEC A1开箱测试"></a>思岚SLAMTEC A1开箱测试</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120319.png"></p><h4 id="一、测试坏境"><a href="#一、测试坏境" class="headerlink" title="一、测试坏境"></a>一、测试坏境</h4><p>①、SLAMTEC A1激光雷达；</p><p>②、Ubuntu16.04 下 ROS Kinetic。</p><h4 id="二、测试功能"><a href="#二、测试功能" class="headerlink" title="二、测试功能"></a>二、测试功能</h4><p>①、运行ROS包，查看雷达数据</p><p>②、使用hector_slam进行建图</p><h4 id="三、具体实现过程"><a href="#三、具体实现过程" class="headerlink" title="三、具体实现过程"></a>三、具体实现过程</h4><p>1、建立ROS工作空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/dev/catkin_ws/src</span><br></pre></td></tr></table></figure><p>进入src文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/dev/catkin_ws/src</span><br></pre></td></tr></table></figure><p>初始化工作空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><p>在src文件中创建了一个 CMakeLists.txt 的文件，告诉系统ROS的工作空间。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120332.png"></p><p>2、下载ROS相关的功能包</p><p>在src目录下 下载SLAMTEC的激光雷达ROS包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Slamtec/rplidar_ros.git</span><br></pre></td></tr></table></figure><p>下载Hector_SLAM建图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tu-darmstadt-ros-pkg/hector_slam.git</span><br></pre></td></tr></table></figure><p>3、在工作空间中编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/dev/catkin_ws/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>添加环境变量source</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/dev/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure><p>(为了让source永久生效，应该写入.bashrc文件中）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo&quot;source~/dev/catkin_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>4、驱动安装</p><p>源码安装 rplidar-ros 雷达驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-kinetic-rplidar-ros</span><br></pre></td></tr></table></figure><p>源码安装 hector_slam库</p><pre><code>sudo apt-get install ros-kinetic-hector-slam</code></pre><p>在rplidar_ros中新建slam.launch文件<strong>（非常重要，不然会报错）</strong></p><p>在rplidar_ros/launch/目录下添加slam.launch文件:</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120337.png"></p><p>slam.launch文件中复制如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;node pkg=&quot;hector_mapping&quot; type=&quot;hector_mapping&quot; name=&quot;hector_mapping&quot; output=&quot;screen&quot;&gt;</span><br><span class="line">&lt;!-- Frame names --&gt;</span><br><span class="line">&lt;param name=&quot;pub_map_odom_transform&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;map_frame&quot; value=&quot;map&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;base_frame&quot; value=&quot;base_link&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;odom_frame&quot; value=&quot;base_link&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- Tf use --&gt;</span><br><span class="line">&lt;param name=&quot;use_tf_scan_transformation&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;use_tf_pose_start_estimate&quot; value=&quot;false&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- Map size / start point --&gt;</span><br><span class="line">&lt;param name=&quot;map_resolution&quot; value=&quot;0.05&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;map_size&quot; value=&quot;2048&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;map_start_x&quot; value=&quot;0.5&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;map_start_y&quot; value=&quot;0.5&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;laser_z_min_value&quot; value = &quot;-1.0&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;laser_z_max_value&quot; value = &quot;1.0&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;map_multi_res_levels&quot; value=&quot;2&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;param name=&quot;map_pub_period&quot; value=&quot;2&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;laser_min_dist&quot; value=&quot;0.4&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;laser_max_dist&quot; value=&quot;5.5&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;output_timing&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;pub_map_scanmatch_transform&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;!--&lt;param name=&quot;tf_map_scanmatch_transform_frame_name&quot; value=&quot;scanmatcher_frame&quot; /&gt;--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- Map update parameters --&gt;</span><br><span class="line">&lt;param name=&quot;update_factor_free&quot; value=&quot;0.4&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;update_factor_occupied&quot; value=&quot;0.7&quot; /&gt;    </span><br><span class="line">&lt;param name=&quot;map_update_distance_thresh&quot; value=&quot;0.2&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;map_update_angle_thresh&quot; value=&quot;0.06&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- Advertising config --&gt; </span><br><span class="line">&lt;param name=&quot;advertise_map_service&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;scan_subscriber_queue_size&quot; value=&quot;5&quot;/&gt;</span><br><span class="line">&lt;param name=&quot;scan_topic&quot; value=&quot;scan&quot;/&gt;</span><br><span class="line">&lt;/node&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;base_to_laser_broadcaster&quot; args=&quot;0 0 0 0 0 0 /base_link /laser 100&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot;</span><br><span class="line">    args=&quot;-d $(find hector_slam_launch)/rviz_cfg/mapping_demo.rviz&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/launch&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、连接雷达</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120343.png"></p><p>雷达连接好后会出现usb串口<br>查看usb串口及权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /dev |grep ttyUSB</span><br></pre></td></tr></table></figure><p>对应的文件号应该是ttyUSB0<br>给串口文件号ttyUSB0添加写权限为：666  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 666 /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>6、使用rviz雷达数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">roslaunch rplidar_ros view_rplidar.launch</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120348.png"></p><p>7、在终端查看雷达数据</p><p>启动ros主节点以及启动激光雷达</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">roslaunch rplidar_ros rplidar.launch</span><br></pre></td></tr></table></figure><p>启动rplidarNodeClient节点，在终端查看数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun rplidar_ros rplidarNodeClient</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120354.png"></p><p>8、使用Hector_SLAM建图</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">roslaunch rplidar_ros slam.launch</span><br></pre></td></tr></table></figure><p>如果出现如下报错</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120359.png"></p><p>进入到rplidar_ws目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/rplidar_ws</span><br><span class="line">source devel/setup.bash</span><br><span class="line">roslaunch rplidar_ros slam.launch</span><br></pre></td></tr></table></figure><p>一定要切换rplidar_ws到此目录下在启动命令；</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/%E6%80%9D%E5%B2%9ASLAMTECA1%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95/20211110120403.png"></p><p>9、保存slam得到的地图信息<br>先安装map_server包；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-kinetic-map-server</span><br></pre></td></tr></table></figure><p>然后，保存图形。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun map_server map_saver -f ~/my_map</span><br></pre></td></tr></table></figure><h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><p>进入roscoore,有时会使用CTRL+Z误操作关闭了ROS进程；</p><p>解决方案： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">killall -9 roscore</span><br><span class="line"></span><br><span class="line">killall -9 rosmaster</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://blog.csdn.net/NouriXiiX/article/details/102690064">https://blog.csdn.net/NouriXiiX/article/details/102690064</a></p><p>​            <a href="https://blog.csdn.net/t624124600/article/details/110723844">https://blog.csdn.net/t624124600/article/details/110723844</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 激光雷达-SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 激光雷达-SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FileZilla连接阿里云服务器</title>
      <link href="/2021/11/10/11%E3%80%81%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/FileZilla%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2021/11/10/11%E3%80%81%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/FileZilla%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="FileZilla连接阿里云服务器"><a href="#FileZilla连接阿里云服务器" class="headerlink" title="FileZilla连接阿里云服务器"></a>FileZilla连接阿里云服务器</h3><blockquote><p>目的：可以更好的管理云文件</p></blockquote><p>设置</p><p>在远程服务器端通过指令vim /etc/ssh/sshd_config开放22号端口</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/FileZilla%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/20211110100635.png"></p><p>设置云服务器的安全组ID，添加20/21</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/FileZilla%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/20211110100640.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/FileZilla%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/20211110100643.png"></p><p>然后启动FileZilla，新建站点，设置SFTP、公网地址（主机）、root账号（用户名）、密码、填写22端口进行连接。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/FileZilla%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/20211110100646.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/FileZilla%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/20211110100650.png"></p>]]></content>
      
      
      <categories>
          
          <category> 问题及解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题及解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、Matlab快速绘制栅格地图</title>
      <link href="/2021/11/09/7%E3%80%81%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1%E3%80%81Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/"/>
      <url>/2021/11/09/7%E3%80%81%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1%E3%80%81Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Matlab快速绘制栅格地图"><a href="#一、Matlab快速绘制栅格地图" class="headerlink" title="一、Matlab快速绘制栅格地图"></a>一、Matlab快速绘制栅格地图</h2><blockquote><p>声明：本文是学习古月居~基于栅格地图的机器人路径规划算法指南• 黎万洪](<a href="https://class.guyuehome.com/detail/p_6098db8ce4b071a81eb8befa/6)%E5%90%8E%E5%86%99%E7%9A%84%E7%AC%94%E8%AE%B0%EF%BC%8C%E5%A5%BD%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A6%82%E7%83%82%E7%AC%94%E5%A4%B4%EF%BC%81%E6%96%B9%E4%BE%BF%E6%97%A5%E5%90%8E%E7%9A%84%E5%B7%A9%E5%9B%BA%E4%B8%8E%E5%A4%8D%E4%B9%A0%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%95%99%E7%A8%8B%E8%AE%B2%E7%9A%84%E5%BE%88%E9%AB%98%EF%BC%8C%E5%80%BC%E5%BE%97%E6%8E%A8%E8%8D%90%EF%BC%81">https://class.guyuehome.com/detail/p_6098db8ce4b071a81eb8befa/6)后写的笔记，好记性不如烂笔头！方便日后的巩固与复习，这个教程讲的很高，值得推荐！</a></p></blockquote><h3 id="1、几种常用的地图形式："><a href="#1、几种常用的地图形式：" class="headerlink" title="1、几种常用的地图形式："></a>1、几种常用的地图形式：</h3><h4 id="1-1、尺度地图："><a href="#1-1、尺度地图：" class="headerlink" title="1.1、尺度地图："></a>1.1、尺度地图：</h4><p>具有真实的物理尺度，如：栅格地图、特征地图、点云地图，常用于地图构建、定位、SLAM、小规模路径规划。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109230749.png"></p><h4 id="1-2、拓扑地图："><a href="#1-2、拓扑地图：" class="headerlink" title="1.2、拓扑地图："></a>1.2、拓扑地图：</h4><p>不具备真实的物理尺度，只表示不同地点的连接关系和距离，如铁路网。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224555.png"></p><h4 id="1-3、语义地图："><a href="#1-3、语义地图：" class="headerlink" title="1.3、语义地图："></a>1.3、语义地图：</h4><p>加标签的尺度地图，常用于人机交互。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224559.png"></p><h3 id="2、栅格地图用于路径规划的优势："><a href="#2、栅格地图用于路径规划的优势：" class="headerlink" title="2、栅格地图用于路径规划的优势："></a>2、栅格地图用于路径规划的优势：</h3><blockquote><p>①、可以将任意形状轮廓的地图，用足够精细的栅格进行绘制；</p><p>②、每一个栅格，可以通过不同颜色表示不同含义，如黑色代表障碍物、黄色代表起点、红色代表终点；</p><p>③、基于栅格地图进行路径规划有横、纵、斜三个规划方向。对应室内低速机器人可以完全按照路径行走；对于中高速机器人，可以考虑将路径进行平滑处理，以适用于非完全约束系统。</p></blockquote><h3 id="3、matlab绘制栅格地图的核心函数及思想："><a href="#3、matlab绘制栅格地图的核心函数及思想：" class="headerlink" title="3、matlab绘制栅格地图的核心函数及思想："></a>3、matlab绘制栅格地图的核心函数及思想：</h3><h4 id="3-1、colormap函数："><a href="#3-1、colormap函数：" class="headerlink" title="3.1、colormap函数："></a>3.1、colormap函数：</h4><blockquote><p>为栅格地图创建自定义颜色。如黄色栅格代表起点、红色为终点。</p></blockquote><h4 id="3-2、sub2ind函数："><a href="#3-2、sub2ind函数：" class="headerlink" title="3.2、sub2ind函数："></a>3.2、sub2ind函数：</h4><p>将行列索引转为线性索引。对于右图栅格地图，10行1列，行从左上角自上而下排序，列从左上角自左向右排序。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224604.png"></p><h4 id="3-3、ind2sub函数："><a href="#3-3、ind2sub函数：" class="headerlink" title="3.3、ind2sub函数："></a>3.3、ind2sub函数：</h4><blockquote><p>与sub2ind相反，是将线性索引转为行列索引。</p></blockquote><h4 id="3-4、为了在栅格地图呈现随机障碍物的效果，可以设置障碍物出现频率数值，根据该数据在所有栅格中生成随机数，从而确定障碍物栅格。"><a href="#3-4、为了在栅格地图呈现随机障碍物的效果，可以设置障碍物出现频率数值，根据该数据在所有栅格中生成随机数，从而确定障碍物栅格。" class="headerlink" title="3.4、为了在栅格地图呈现随机障碍物的效果，可以设置障碍物出现频率数值，根据该数据在所有栅格中生成随机数，从而确定障碍物栅格。"></a>3.4、为了在栅格地图呈现随机障碍物的效果，可以设置障碍物出现频率数值，根据该数据在所有栅格中生成随机数，从而确定障碍物栅格。</h4><h4 id="3-5、image函数："><a href="#3-5、image函数：" class="headerlink" title="3.5、image函数："></a>3.5、image函数：</h4><p>利用colormap建立的颜色图，将数组信息显示为图像。</p><h3 id="4、具体例子："><a href="#4、具体例子：" class="headerlink" title="4、具体例子："></a>4、具体例子：</h3><h3 id="4-1、利用Matlab快速绘制栅格地图matlab代码："><a href="#4-1、利用Matlab快速绘制栅格地图matlab代码：" class="headerlink" title="4.1、利用Matlab快速绘制栅格地图matlab代码："></a>4.1、利用Matlab快速绘制栅格地图matlab代码：</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 构建颜色MAP图</span></span><br><span class="line">cmap = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>; ...       <span class="comment">% 1-白色-空地</span></span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; ...           <span class="comment">% 2-黑色-静态障碍</span></span><br><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; ...           <span class="comment">% 3-红色-动态障碍</span></span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>;...            <span class="comment">% 4-黄色-起始点 </span></span><br><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;...            <span class="comment">% 5-品红-目标点</span></span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>; ...           <span class="comment">% 6-绿色-到目标点的规划路径   </span></span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>];              <span class="comment">% 7-青色-动态规划的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 构建颜色MAP图</span></span><br><span class="line">colormap(cmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 构建栅格地图场景</span></span><br><span class="line"><span class="comment">% 栅格界面大小:行数和列数</span></span><br><span class="line">rows = <span class="number">10</span>;</span><br><span class="line">cols = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义栅格地图全域，并初始化空白区域</span></span><br><span class="line">field = <span class="built_in">ones</span>(rows, cols);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 障碍物区域</span></span><br><span class="line">obsRate = <span class="number">0.3</span>;</span><br><span class="line">obsNum = <span class="built_in">floor</span>(rows*cols*obsRate);</span><br><span class="line">obsIndex = randi([<span class="number">1</span>,rows*cols],obsNum,<span class="number">1</span>);</span><br><span class="line">field(obsIndex) = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 起始点和目标点</span></span><br><span class="line">startPos = <span class="number">2</span>;</span><br><span class="line">goalPos = rows*cols<span class="number">-2</span>;</span><br><span class="line">field(startPos) = <span class="number">4</span>;</span><br><span class="line">field(goalPos) = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 画栅格图</span></span><br><span class="line">image(<span class="number">1.5</span>,<span class="number">1.5</span>,field);</span><br><span class="line">grid on;</span><br><span class="line">set(gca,<span class="string">&#x27;gridline&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;gridcolor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;GridAlpha&#x27;</span>,<span class="number">0.5</span>);</span><br><span class="line">set(gca,<span class="string">&#x27;xtick&#x27;</span>,<span class="number">1</span>:cols+<span class="number">1</span>,<span class="string">&#x27;ytick&#x27;</span>,<span class="number">1</span>:rows+<span class="number">1</span>);</span><br><span class="line">axis image;</span><br></pre></td></tr></table></figure><h3 id="4-2、运行结构："><a href="#4-2、运行结构：" class="headerlink" title="4.2、运行结构："></a>4.2、运行结构：</h3><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224610.png"></p><h3 id="4-3、具体分析"><a href="#4-3、具体分析" class="headerlink" title="4.3、具体分析"></a>4.3、具体分析</h3><p>1、</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">close all</span><br></pre></td></tr></table></figure><blockquote><p>clc：清除命令窗口的内容，对工作环境中的全部变量无任何影响<br>close：关闭当前的Figure窗口<br>close all:关闭所有的Figure窗口<br>clear：清除工作空间的所有变量<br>clear all：清除工作空间的所有变量，函数，和MEX文件</p></blockquote><p>2、自定义构建颜色MAP图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 构建颜色MAP图</span></span><br><span class="line">cmap = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>; ...       <span class="comment">% 1-白色-空地</span></span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; ...           <span class="comment">% 2-黑色-静态障碍</span></span><br><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; ...           <span class="comment">% 3-红色-动态障碍</span></span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>;...            <span class="comment">% 4-黄色-起始点 </span></span><br><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;...            <span class="comment">% 5-品红-目标点</span></span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>; ...           <span class="comment">% 6-绿色-到目标点的规划路径   </span></span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>];              <span class="comment">% 7-青色-动态规划的路径</span></span><br></pre></td></tr></table></figure><p>运行后会建立对应变量的MAP图值</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224616.png"></p><p>3、colormap构建颜色MAP图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 构建颜色MAP图</span></span><br><span class="line">colormap(cmap);</span><br></pre></td></tr></table></figure><p>4、构建栅格地图场景：大小</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 构建栅格地图场景</span></span><br><span class="line"><span class="comment">% 栅格界面大小:行数和列数</span></span><br><span class="line">rows = <span class="number">10</span>;</span><br><span class="line">cols = <span class="number">10</span>; </span><br></pre></td></tr></table></figure><p>5、定义栅格地图全域，并初始化空白区域</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 定义栅格地图全域，并初始化空白区域</span></span><br><span class="line">field = <span class="built_in">ones</span>(rows, cols);</span><br></pre></td></tr></table></figure><p>将栅格图全设置为白色</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224620.png"></p><p>6、障碍物区域</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 障碍物区域</span></span><br><span class="line">obsRate = <span class="number">0.3</span>;</span><br><span class="line">obsNum = <span class="built_in">floor</span>(rows*cols*obsRate);</span><br><span class="line">obsIndex = randi([<span class="number">1</span>,rows*cols],obsNum,<span class="number">1</span>);</span><br><span class="line">field(obsIndex) = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><blockquote><p>obsRate = 0.3;%障碍物占比率</p><p>obsNum = floor(rows<em>cols</em>obsRate);%计算障碍物个数；</p><p>obsIndex = randi([1,rows*cols],obsNum,1);%随机设置障碍物</p></blockquote><p>得到障碍物的区域</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224624.png"></p><p>7、起始点和目标点</p><p>起始点和目标点要定义在障碍物后面，不然可能会和障碍物冲突</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 起始点和目标点</span></span><br><span class="line">startPos = <span class="number">2</span>;</span><br><span class="line">goalPos = rows*cols<span class="number">-2</span>;</span><br><span class="line">field(startPos) = <span class="number">4</span>;</span><br><span class="line">field(goalPos) = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><blockquote><p>startPos = 2; &amp;起点<br>goalPos = rows*cols-2;%终点<br>field(startPos) = 4; %起点为黄色<br>field(goalPos) = 5; %终点为红色</p></blockquote><p>8、画栅格图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 画栅格图</span></span><br><span class="line">image(<span class="number">1.5</span>,<span class="number">1.5</span>,field);</span><br><span class="line">grid on;</span><br><span class="line">set(gca,<span class="string">&#x27;gridline&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;gridcolor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;GridAlpha&#x27;</span>,<span class="number">0.5</span>);</span><br><span class="line">set(gca,<span class="string">&#x27;xtick&#x27;</span>,<span class="number">1</span>:cols+<span class="number">1</span>,<span class="string">&#x27;ytick&#x27;</span>,<span class="number">1</span>:rows+<span class="number">1</span>);</span><br><span class="line">axis image;</span><br></pre></td></tr></table></figure><blockquote><p>image(1.5,1.5,field);%画出颜色图</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224629.png"></p><p>grid on;% 画出网格</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224633.png"></p><p>set(gca,’gridline’,’-‘,’gridcolor’,’k’,’linewidth’,2,’GridAlpha’,0.5); % 设置网格为：网格线<del>实线、颜色</del>黑色、线宽<del>2、透明度</del>0.5；</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224637.png"></p><p>set(gca,’xtick’,1:cols+1,’ytick’,1:rows+1); % 设置长宽高为一样~正方形<br>axis image;</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/20211109224642.png"></p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 路径规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用过程中遇到的问题（一）：push fail</title>
      <link href="/2021/11/09/6%E3%80%81git/Git%20push%E5%88%B0%E4%BB%93%E5%BA%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AFailed%20to%20connect%20to%20github.com%20port%20443%20Timed%20out/"/>
      <url>/2021/11/09/6%E3%80%81git/Git%20push%E5%88%B0%E4%BB%93%E5%BA%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AFailed%20to%20connect%20to%20github.com%20port%20443%20Timed%20out/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-push到仓库过程中遇到的问题（一）：Failed-to-connect-to-github-com-port-443-Timed-out"><a href="#Git-push到仓库过程中遇到的问题（一）：Failed-to-connect-to-github-com-port-443-Timed-out" class="headerlink" title="Git push到仓库过程中遇到的问题（一）：Failed to connect to github.com port 443: Timed out"></a>Git push到仓库过程中遇到的问题（一）：Failed to connect to github.com port 443: Timed out</h2><blockquote><p>声明：本文是记录了自己在使用git过程中遇到push到GitHub仓库失败的问题后的解决过程，为以后复习！</p></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Git%E4%BD%BF%E7%94%A8/20211109202128.png"></p><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p><strong>1、打开windos设置，进入网络和Internet</strong></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Git%E4%BD%BF%E7%94%A8/20211109202750.png"></p><p><strong>2、点击代理，关闭自动检测设置</strong></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Git%E4%BD%BF%E7%94%A8/20211109202055.png"></p><p><strong>3、重新push</strong></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Git%E4%BD%BF%E7%94%A8/20211109202109.png"></p><p><strong>上传成功</strong></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Git%E4%BD%BF%E7%94%A8/20211109202215.png"></p><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p><strong>使用命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure><p><strong>直接设置不使用代理</strong></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、STM32CubeMX安装</title>
      <link href="/2021/11/09/4%E3%80%81STM32/2%E3%80%81STM32CubeMX/STM32CubeMX%E5%AE%89%E8%A3%85/"/>
      <url>/2021/11/09/4%E3%80%81STM32/2%E3%80%81STM32CubeMX/STM32CubeMX%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="STM32CubeMX安装"><a href="#STM32CubeMX安装" class="headerlink" title="STM32CubeMX安装"></a>STM32CubeMX安装</h3><h4 id="STM32CubeMX介绍"><a href="#STM32CubeMX介绍" class="headerlink" title="STM32CubeMX介绍"></a>STM32CubeMX介绍</h4><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image.PF259242.en.feature-description-include-personalized-no-cpn-large.jpg"></p><p>​    STM32CubeMX是ST公司主动原创的一款代码生成工具， 它可以减轻开发时间和费用。STM32CubeMX集成了一个全面的软件平台，支持STM32每一个系列的MCU开发。这个平台 包括 STM32Cube HAL（一个 STM32 的抽象层集成软件，确保 STM32 系列最大的移植性），再加上兼容的一套中间件 （RTOS、USB、TCP/IP 和图形）。所有内嵌软件组件附带了全套例程。 </p><h4 id="软件坏境安装"><a href="#软件坏境安装" class="headerlink" title="软件坏境安装"></a>软件坏境安装</h4><p>STM32CubeMX软件是基于java环境运行的，所以需要安装JRE才能使用。 </p><p>STM32CubeMX要求JRE最低版本是1.7.0_45，所以最好使用教新的版本，JAVA官方网址为：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a> ，安装完成后配置好Java环境变量 。</p><h4 id="STM32CubeMX软件下载"><a href="#STM32CubeMX软件下载" class="headerlink" title="STM32CubeMX软件下载"></a>STM32CubeMX软件下载</h4><p>软件获取方式： </p><p>①、 ST官网：工具和软件→开发工具→Software Development Tools→STM32CubeMX→GET SOFTWARE </p><p>官网下载地址链接：<a href="https://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-configurators-and-code-generators/stm32cubemx.html">https://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-configurators-and-code-generators/stm32cubemx.html</a></p><p>②、从官网下载需要注册ST账号，所以我已经将软件下载好放在百度云盘，需要的关注公众号《Kevin的嵌入式学习站》，后台回复“STM32CubeMX”。</p><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><p>①、解压安装包后，点击SetupSTM32CubeMX-4.27.0，以管理员权限运行</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102225307384.png"></p><p>②、安装步骤</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102230354486.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102230429236.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102230539190.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102230608865.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102230637341.png"></p><p>安装完成后可以在桌面打开STM32CubeMX</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102230737383.png"></p><p>安装对应的支持包，因为支持包比较大，所以最好更改一下默认安装路径，<strong>但切记不能出现中文路径</strong></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102230825288.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102231049976.png"></p><p>安装支持包</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102231122078.png"></p><p>安装自己开发所需要的支持包，如我需要如下安装包</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102231229774.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102231324494.png"></p><p>当然也可以提前下好支持包，然后再导入到软件中</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102231640286.png"></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/STM32CubeMX%E5%AE%89%E8%A3%85/image-20211102231756636.png"></p><p>到此安装结束，<strong>值得注意的是安装坏境不要出现中文环境，不然后期开发会报错！</strong></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、ROS开发中常用的命令</title>
      <link href="/2021/11/09/3%E3%80%81ROS/%E4%B8%89%E3%80%81ROS%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/09/3%E3%80%81ROS/%E4%B8%89%E3%80%81ROS%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="ROS开发中常用的命令"><a href="#ROS开发中常用的命令" class="headerlink" title="ROS开发中常用的命令"></a>ROS开发中常用的命令</h2><h4 id="启动命令roscore"><a href="#启动命令roscore" class="headerlink" title="启动命令roscore"></a>启动命令roscore</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><blockquote><p>必须运行 roscore 才能使 ROS 节点进行通信；</p><p>roscore 将启动:①、ros master；②、ros 参数服务器；③、rosout 日志节点</p></blockquote><h4 id="运行命令-rosrun"><a href="#运行命令-rosrun" class="headerlink" title="运行命令 rosrun"></a>运行命令 rosrun</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun 包名 可执行文件名  //运行指定的ROS节点</span><br></pre></td></tr></table></figure><h4 id="创建新的ROS功能包"><a href="#创建新的ROS功能包" class="headerlink" title="创建新的ROS功能包"></a>创建新的ROS功能包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg 自定义包名 依赖包</span><br></pre></td></tr></table></figure><h4 id="安装-ROS功能包"><a href="#安装-ROS功能包" class="headerlink" title="安装 ROS功能包"></a>安装 ROS功能包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install xxx</span><br></pre></td></tr></table></figure><h4 id="删除某个功能包"><a href="#删除某个功能包" class="headerlink" title="删除某个功能包"></a>删除某个功能包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt purge xxx</span><br></pre></td></tr></table></figure><h4 id="列出所有功能包"><a href="#列出所有功能包" class="headerlink" title="列出所有功能包"></a>列出所有功能包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rospack list</span><br></pre></td></tr></table></figure><h4 id="查找某个功能包是否存在"><a href="#查找某个功能包是否存在" class="headerlink" title="查找某个功能包是否存在"></a>查找某个功能包是否存在</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rospack find xxx</span><br></pre></td></tr></table></figure><h4 id="搜索某个功能包"><a href="#搜索某个功能包" class="headerlink" title="搜索某个功能包"></a>搜索某个功能包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search xxx</span><br></pre></td></tr></table></figure><h4 id="进入某个功能包"><a href="#进入某个功能包" class="headerlink" title="进入某个功能包"></a>进入某个功能包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscd xxx</span><br></pre></td></tr></table></figure><h4 id="列出某个包下的文件"><a href="#列出某个包下的文件" class="headerlink" title="列出某个包下的文件"></a>列出某个包下的文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosls xxx</span><br></pre></td></tr></table></figure><h4 id="修改某个功能包文件"><a href="#修改某个功能包文件" class="headerlink" title="修改某个功能包文件"></a>修改某个功能包文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosed 包名 文件名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、Ubuntu下ROS 的安装和测试</title>
      <link href="/2021/11/09/3%E3%80%81ROS/%E4%B8%80%E3%80%81Ubuntu%E4%B8%8BROS%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/11/09/3%E3%80%81ROS/%E4%B8%80%E3%80%81Ubuntu%E4%B8%8BROS%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Ubuntu下ROS-的安装和测试"><a href="#一、Ubuntu下ROS-的安装和测试" class="headerlink" title="一、Ubuntu下ROS 的安装和测试"></a>一、Ubuntu下ROS 的安装和测试</h2><h4 id="在Ubuntu下选择合适的ROS版本"><a href="#在Ubuntu下选择合适的ROS版本" class="headerlink" title="在Ubuntu下选择合适的ROS版本"></a>在Ubuntu下选择合适的ROS版本</h4><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225548.png"></p><p>根据自己的Ubuntu坏境选择ROS版本，建议安装最新版本。</p><h4 id="配置ubuntu的软件和更新"><a href="#配置ubuntu的软件和更新" class="headerlink" title="配置ubuntu的软件和更新"></a>配置ubuntu的软件和更新</h4><p>配置ubuntu的软件和更新，允许安装不经认证的软件。</p><p>首先打开“软件和更新”对话框，具体可以在 Ubuntu 搜索按钮中搜索。</p><p>打开后按照下图进行配置（确保勾选了”restricted”， “universe，” 和 “multiverse.”）</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225554.png"></p><h4 id="设置安装源"><a href="#设置安装源" class="headerlink" title="设置安装源"></a>设置安装源</h4><p>官方默认安装源:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span><br></pre></td></tr></table></figure><p>或来自国内清华的安装源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span><br></pre></td></tr></table></figure><p>或来自国内中科大的安装源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://m</span><br></pre></td></tr></table></figure><p><strong>尽量使用国内安装源，安装的数度会快一些</strong></p><h4 id="设置key"><a href="#设置key" class="headerlink" title="设置key"></a>设置key</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu</span><br></pre></td></tr></table></figure><p>若无法连接到密钥服务器，可以尝试替换上面命令中的 <code>hkp://keyserver.ubuntu.com:80</code> 为 <code>hkp://pgp.mit.edu:80</code> 。 </p><p>也可以使用curl命令替换apt-key命令，这在使用代理服务器的情况下比较有用： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL &#x27;http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654&#x27; | sudo apt-key add -</span><br></pre></td></tr></table></figure><h4 id="安装ROS"><a href="#安装ROS" class="headerlink" title="安装ROS"></a>安装ROS</h4><p>①、使用以下命令，确保Ubuntu软件包索引是最新的： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>②、安装完整桌面版的ROS，完整版包含了 ROS、<a href="http://wiki.ros.org/rqt">rqt</a>、<a href="http://wiki.ros.org/rviz">rviz</a>、机器人通用库、2D/3D 模拟器、导航以及 2D/3D 感知包。</p><p><strong>Ubuntu16.04下安装ROS Kinetic Kame 命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-kinetic-desktop-full</span><br></pre></td></tr></table></figure><p><strong>Ubuntu18.04下安装ROS Melodic 命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-melodic-desktop-full</span><br></pre></td></tr></table></figure><p><strong>Ubuntu20.04下安装ROS Noetic 命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-desktop-full</span><br></pre></td></tr></table></figure><p>出现错误</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225602.png"></p><p>重复多次安装一下，可能是因为网络的原因。</p><h4 id="配置ROS坏境"><a href="#配置ROS坏境" class="headerlink" title="配置ROS坏境"></a>配置ROS坏境</h4><p>配置环境变量，方便在任意 终端中使用 ROS。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="ROS卸载"><a href="#ROS卸载" class="headerlink" title="ROS卸载"></a>ROS卸载</h4><p>如果需要卸载ROS可以调用如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove ros-noetic-*</span><br></pre></td></tr></table></figure><h4 id="初始化-rosdep"><a href="#初始化-rosdep" class="headerlink" title="初始化 rosdep"></a>初始化 rosdep</h4><p>在使用 ROS 之前，需要初始化 <code>rosdep</code>。<code>rosdep</code> 能够轻松地安装被想要编译的源代码，或被某些 ROS 核心组件需要的系统依赖。</p><p>避免后面出现sudo rosdep：找不到命令提示，需要执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-rosdep</span><br></pre></td></tr></table></figure><p> 初始化rosdep</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225608.png"></p><p>但是，在 rosdep 初始化时，多半会抛出异常。</p><p><strong>问题:</strong></p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225615.png"></p><p><strong>原因:</strong></p><p>境外资源被屏蔽。</p><p><strong>解决:</strong></p><p>百度或google搜索，解决方式有多种(<a href="https://github.com/ros/rosdistro/issues/9721)%EF%BC%8C%E5%8F%AF%E6%83%9C%E5%9C%A8">https://github.com/ros/rosdistro/issues/9721)，可惜在</a> ubuntu20.04 下，集体失效。</p><p>新思路:<em>将相关资源备份到 gitee,修改 rosdep 源码,重新定位资源。</em></p><p><strong>实现:</strong></p><p>1.先打开资源备份路径:<a href="https://gitee.com/zhao-xuzuo/rosdistro%EF%BC%8C%E6%89%93%E5%BC%80">https://gitee.com/zhao-xuzuo/rosdistro，打开</a> rosdistro/<strong>rosdep</strong>/<strong>sources.list.d</strong>/<strong>20-default.list</strong>文件留作备用(主要是复用URL的部分内容:gitee.com/zhao-xuzuo/rosdistro/raw/master)。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225620.png"></p><p>2.进入”/usr/lib/python3/dist-packages/“ 查找rosdep中和<code>raw.githubusercontent.com</code>相关的内容，调用命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f | xargs grep &quot;raw.githubusercontent&quot;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225625.png"></p><p>3.修改相关文件，主要有: ./rosdistro/<strong>init</strong>.py、./rosdep2/gbpdistro_support.py、./rosdep2/sources_list.py 、./rosdep2/rep3.py。可以使用<code>sudo gedit</code>命令修改文件:</p><p>文件中涉及的 URL 内容，如果是:<code>raw.githubusercontent.com/ros/rosdistro/master</code>都替换成步骤1中准备的<code>gitee.com/zhao-xuzuo/rosdistro/raw/master</code>即可。</p><p>修改完毕，再重新执行命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><p>就可以正常实现 rosdep 的初始化与更新了。</p><h4 id="测试-ROS——运行小海龟"><a href="#测试-ROS——运行小海龟" class="headerlink" title="测试 ROS——运行小海龟"></a>测试 ROS——运行小海龟</h4><ol><li><p>首先启动三个终端(ctrl + alt + T)</p></li><li><p>第一个终端运行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure></li><li><p>第二个终端运行命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure><p>此时会弹出图形化界面</p></li><li><p>第三个终端运行命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p>在3中可以通过上下左右控制2中乌龟的运动</p></li></ol><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/ROS/20211108225632.png"></p><p><strong>注：</strong></p><p>有时候下载任务不小心被 CTRL+Z暂停了</p><p>使用： jobs 命令查看已有进程 使用fg %x恢复执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fg %x</span><br></pre></td></tr></table></figure><p> 参考文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_44830040/article/details/106049992</span><br><span class="line">https://blog.csdn.net/weixin_43159148/article/details/83375218</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、MATLAB程序流程控制语句</title>
      <link href="/2021/11/09/5%E3%80%81matlab/%E5%9B%9B%E3%80%81MATLAB%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2021/11/09/5%E3%80%81matlab/%E5%9B%9B%E3%80%81MATLAB%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="四、MATLAB程序流程控制语句"><a href="#四、MATLAB程序流程控制语句" class="headerlink" title="四、MATLAB程序流程控制语句"></a>四、MATLAB程序流程控制语句</h2><blockquote><p><strong>声明：</strong><br>笔记是学习慕课网《科学计算与MATLAB语言》课程和刘卫国主编的《MATLAB程序设计与应用（第3版）》后的个人总结，方便自己以后巩固和复习！</p></blockquote><h3 id="4-1-M文件"><a href="#4-1-M文件" class="headerlink" title="4.1  M文件"></a>4.1  M文件</h3><h4 id="4-1-1-M文件的建立与打开"><a href="#4-1-1-M文件的建立与打开" class="headerlink" title="4.1.1  M文件的建立与打开"></a>4.1.1  M文件的建立与打开</h4><p>M文件是一个文本文件，它可以用任何编辑程序来建立和编辑，而一般常用且最为方便的是使用MATLAB提供的文本编辑器。</p><h5 id="1．建立新的M文件"><a href="#1．建立新的M文件" class="headerlink" title="1．建立新的M文件"></a>1．建立新的M文件</h5><p>为建立新的M文件，启动MATLAB编辑器有3种方法。<br>① 在MATLAB主窗口选择“主页”选项卡，在“文件”命令组中单击“新建脚本”命令按钮。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109182936.png"></p><p>② 在MATLAB命令行窗口输入命令：<br>edit 文件名<br>启动MATLAB编辑器后，输入M文件的内容并存盘。<br>③ 在命令历史窗口选中一些命令（按住Ctrl可同时选择多条命令），然后从右键快捷菜单中选择“创建脚本”命令，将会启动MATLAB编辑器，并在编辑区中加入所选中的命令。</p><h5 id="2．打开已有的M文件"><a href="#2．打开已有的M文件" class="headerlink" title="2．打开已有的M文件"></a>2．打开已有的M文件</h5><p>打开已有的M文件，也有3种方法：<br>    (1) 菜单操作。在MATLAB主窗口选择“主页”选项卡，在“文件”命令组中单击“打开”命令按钮，再从弹出的下拉菜单中选择“打开”命令，从“打开”对话框中选择所需打开的M文件。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109182952.png">    (2) 命令操作。在MATLAB命令窗口输入命令：edit 文件名，则打开指定的M文件。<br>    (3) 命令按钮操作。单击MATLAB主窗口工具栏上的Open File命令按钮，再从弹出的对话框中选择所需打开的M文件。</p><h4 id="4-1-2-M文件的分类"><a href="#4-1-2-M文件的分类" class="headerlink" title="4.1.2  M文件的分类"></a>4.1.2  M文件的分类</h4><p>   用MATLAB语言编写的程序，称为M文件。M文件可以根据调用方式的不同分为两类：脚本文件(Script File)和函数文件(Function File)。</p><blockquote><p><strong>脚本文件和函数文件的主要区别如下：</strong><br>① 脚本文件没有输入参数，也不返回输出参数，而函数文件可以带输入参数，也可返回输出参数。<br>② 脚本文件对MATLAB工作空间中的变量进行操作，文件中所有命令的执行结果也完全返回到工作空间中，而函数文件中定义的变量为局部变量，当函数文件执行完毕时，这些变量被清除。<br>③ 脚本文件可以直接运行，在MATLAB命令行窗口输入脚本文件的名字，就会顺序执行脚本文件中的命令，而函数文件不能直接运行，而要以函数调用的方式来调用它。</p></blockquote><p>建立一个命令文件将变量a,b的值互换，然后运行该命令文件。<br>    程序1：<br>首先建立命令文件并以文件名exch.m存盘：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clear;</span><br><span class="line">a=<span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line">b=[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>;<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>];</span><br><span class="line">c=a;a=b;b=c;</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><p>然后在MATLAB的命令窗口中输入exch，将会执行该命令文件。 </p><h3 id="4-2-程序控制结构"><a href="#4-2-程序控制结构" class="headerlink" title="4.2  程序控制结构"></a>4.2  程序控制结构</h3><h4 id="4-2-1-顺序结构"><a href="#4-2-1-顺序结构" class="headerlink" title="4.2.1  顺序结构"></a>4.2.1  顺序结构</h4><h5 id="1．数据的输入"><a href="#1．数据的输入" class="headerlink" title="1．数据的输入"></a>1．数据的输入</h5><p>从键盘输入数据，则可以使用input函数来进行，该函数的调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A=input(提示信息，选项)；</span><br></pre></td></tr></table></figure><p>其中提示信息为一个字符串，用于提示用户输入什么样的数据。<br>    如果在input函数调用时采用’s’选项，则允许用户输入一个字符串。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xm=input(<span class="string">&#x27;What&#x27;&#x27;s your name?&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="2．数据的输出"><a href="#2．数据的输出" class="headerlink" title="2．数据的输出"></a>2．数据的输出</h5><p>​    MATLAB提供的命令窗口输出函数主要有disp函数，其调用格式为<br>​    disp(输出项)<br>其中输出项既可以为字符串，也可以为矩阵。</p><p>例4-2  求一元二次方程ax2 +bx+c=0的根。<br>程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=input(<span class="string">&#x27;a=&#x27;</span>);</span><br><span class="line">b=input(<span class="string">&#x27;b=&#x27;</span>);</span><br><span class="line">c=input(<span class="string">&#x27;c=&#x27;</span>);</span><br><span class="line">d=b*b<span class="number">-4</span>*a*c;</span><br><span class="line">x=[(-b+<span class="built_in">sqrt</span>(d))/(<span class="number">2</span>*a),(-b-<span class="built_in">sqrt</span>(d))/(<span class="number">2</span>*a)];</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;x1=&#x27;</span>,num2str(x(<span class="number">1</span>)),<span class="string">&#x27;,x2=&#x27;</span>,num2str(x(<span class="number">2</span>))]);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109183009.png"></p><h5 id="3．程序的暂停"><a href="#3．程序的暂停" class="headerlink" title="3．程序的暂停"></a>3．程序的暂停</h5><p>​    暂停程序的执行可以使用pause函数，其调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pause(延迟秒数)</span><br></pre></td></tr></table></figure><p>​    如果省略延迟时间，直接使用pause，则将暂停程序，直到用户按任一键后程序继续执行。<br>​    若要强行中止程序的运行可使用Ctrl+C命令。</p><h4 id="4-2-2-选择结构"><a href="#4-2-2-选择结构" class="headerlink" title="4.2.2  选择结构"></a>4.2.2  选择结构</h4><h5 id="1．if语句"><a href="#1．if语句" class="headerlink" title="1．if语句"></a>1．if语句</h5><p>​    在MATLAB中，if语句有3种格式。<br>​    (1) 单分支if语句：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  条件</span><br><span class="line">语句组</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当条件成立时，则执行语句组，执行完之后继续执行if语句的后继语句，若条件不成立，则直接执行if语句的后继语句。</p><p>  (2) 双分支if语句：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  条件</span><br><span class="line">    语句组<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     语句组<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>​    当条件成立时，执行语句组1，否则执行语句组2，语句组1或语句组2执行后，再执行if语句的后继语句。</p><p>计算分段函数。</p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109183017.png" style="zoom:33%;" /><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=input(<span class="string">&#x27;请输入x的值:&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> x==<span class="number">10</span></span><br><span class="line">     y=<span class="built_in">cos</span>(x+<span class="number">1</span>)+<span class="built_in">sqrt</span>(x*x+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     y=x*<span class="built_in">sqrt</span>(x+<span class="built_in">sqrt</span>(x));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">y</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109183023.png"></p><h5 id="3-多分支if语句："><a href="#3-多分支if语句：" class="headerlink" title="(3) 多分支if语句："></a>(3) 多分支if语句：</h5><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109183033.png"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  条件<span class="number">1</span></span><br><span class="line">    语句组<span class="number">1</span></span><br><span class="line"><span class="keyword">elseif</span>  条件<span class="number">2</span></span><br><span class="line">    语句组<span class="number">2</span></span><br><span class="line">   ……</span><br><span class="line"><span class="keyword">elseif</span>  条件m</span><br><span class="line">     语句组m</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     语句组n</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>例：输入一个字符，若为大写字母，则输出其对应的小写字母；若为小写字母，则输出其对应的大写字母；若为数字字符则输出其对应的数值，若为其他字符则原样输出。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c=input(<span class="string">&#x27;请输入一个字符&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> c&gt;=<span class="string">&#x27;A&#x27;</span> &amp; c&lt;=<span class="string">&#x27;Z&#x27;</span></span><br><span class="line">   <span class="built_in">disp</span>(setstr(<span class="built_in">abs</span>(c)+<span class="built_in">abs</span>(<span class="string">&#x27;a&#x27;</span>)-<span class="built_in">abs</span>(<span class="string">&#x27;A&#x27;</span>)));</span><br><span class="line"><span class="keyword">elseif</span> c&gt;=<span class="string">&#x27;a&#x27;</span>&amp; c&lt;=<span class="string">&#x27;z&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(setstr(<span class="built_in">abs</span>(c)- <span class="built_in">abs</span>(<span class="string">&#x27;a&#x27;</span>)+<span class="built_in">abs</span>(<span class="string">&#x27;A&#x27;</span>)));</span><br><span class="line"><span class="keyword">elseif</span> c&gt;=<span class="string">&#x27;0&#x27;</span>&amp; c&lt;=<span class="string">&#x27;9&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="built_in">abs</span>(c)-<span class="built_in">abs</span>(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(c);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="2．switch语句"><a href="#2．switch语句" class="headerlink" title="2．switch语句"></a>2．switch语句</h5><p>​    switch语句根据表达式的取值不同，分别执行不同的语句，其语句格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>  表达式</span><br><span class="line">   <span class="keyword">case</span>  表达式<span class="number">1</span></span><br><span class="line">      语句组<span class="number">1</span></span><br><span class="line">   <span class="keyword">case</span>  表达式<span class="number">2</span></span><br><span class="line">      语句组<span class="number">2</span></span><br><span class="line">      ……</span><br><span class="line">   <span class="keyword">case</span>  表达式m</span><br><span class="line">      语句组m</span><br><span class="line">   <span class="keyword">otherwise</span></span><br><span class="line">      语句组n</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109183040.png" style="zoom:80%;" /><blockquote><p>当表达式的值等于表达式1的值时，执行语句组1，当表达式的值等于表达式2的值时，执行语句组2，…，当表达式的值等于表达式m的值时，执行语句组m，当表达式的值不等于case所列的表达式的值时，执行语句组n。当任意一个分支的语句执行完后，直接执行switch语句的下一句</p></blockquote><p>例：某商场对顾客所购买的商品实行打折销售，标准如下(商品价格用price来表示)：<br>    price&lt;200           没有折扣<br>    200≤price&lt;500      3%折扣<br>    500≤price&lt;1000     5%折扣<br>    1000≤price&lt;2500    8%折扣<br>    2500≤price&lt;5000    10%折扣<br>    5000≤price         14%折扣<br>输入所售商品的价格，求其实际销售价格。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">price=input(<span class="string">&#x27;请输入商品价格&#x27;</span>);</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">fix</span>(price/<span class="number">100</span>) </span><br><span class="line">   <span class="keyword">case</span> &#123;<span class="number">0</span>,<span class="number">1</span>&#125;             <span class="comment">%价格小于200</span></span><br><span class="line">      rate=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">case</span> &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;            <span class="comment">%价格大于等于200但小于500</span></span><br><span class="line">      rate=<span class="number">3</span>/<span class="number">100</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">5</span>:<span class="number">9</span>)       <span class="comment">%价格大于等于500但小于1000</span></span><br><span class="line">      rate=<span class="number">5</span>/<span class="number">100</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">10</span>:<span class="number">24</span>)     <span class="comment">%价格大于等于1000但小于2500</span></span><br><span class="line">      rate=<span class="number">8</span>/<span class="number">100</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">25</span>:<span class="number">49</span>)     <span class="comment">%价格大于等于2500但小于5000</span></span><br><span class="line">      rate=<span class="number">10</span>/<span class="number">100</span>;</span><br><span class="line">   <span class="keyword">otherwise</span>               <span class="comment">%价格大于等于5000</span></span><br><span class="line">      rate=<span class="number">14</span>/<span class="number">100</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">price=price*(<span class="number">1</span>-rate)              <span class="comment">%输出商品实际销售价格</span></span><br></pre></td></tr></table></figure><h5 id="3．try语句"><a href="#3．try语句" class="headerlink" title="3．try语句"></a>3．try语句</h5><p>语句格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">   语句组<span class="number">1</span></span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">   语句组<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>try语句先试探性执行语句组1，如果语句组1在执行过程中出现错误，则将错误信息赋给保留的lasterr变量，并转去执行语句组2。</p><h4 id="4-2-3-循环结构"><a href="#4-2-3-循环结构" class="headerlink" title="4.2.3  循环结构"></a>4.2.3  循环结构</h4><h5 id="1．for语句"><a href="#1．for语句" class="headerlink" title="1．for语句"></a>1．for语句</h5><p>for语句的格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量=表达式<span class="number">1</span>:表达式<span class="number">2</span>:表达式<span class="number">3</span></span><br><span class="line">        循环体语句</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中，“表达式1:表达式2:表达式3”是一个冒号表达式，将产生一个行向量，3个表达式分别代表初值、步长和终值。步长为1时，表达式2可以省略。</p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab4/20211109183048.png" style="zoom:80%;" /><p>例：  一个三位整数各位数字的立方和等于该数本身则称该数为水仙花数。输出全部水仙花数。<br>程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m=<span class="number">100</span>:<span class="number">999</span></span><br><span class="line">m1=<span class="built_in">fix</span>(m/<span class="number">100</span>);           <span class="comment">%求m的百位数字</span></span><br><span class="line">m2=<span class="built_in">rem</span>(<span class="built_in">fix</span>(m/<span class="number">10</span>),<span class="number">10</span>);   <span class="comment">%求m的十位数字</span></span><br><span class="line">m3=<span class="built_in">rem</span>(m,<span class="number">10</span>);             <span class="comment">%求m的个位数字</span></span><br><span class="line"><span class="keyword">if</span> m==m1*m1*m1+m2*m2*m2+m3*m3*m3</span><br><span class="line"><span class="built_in">disp</span>(m)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>or语句更一般的格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量=矩阵表达式</span><br><span class="line">       循环体语句</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>​    执行过程是依次将矩阵的各列元素赋给循环变量，然后执行循环体语句，直至各列元素处理完毕。</p><h5 id="2．while语句"><a href="#2．while语句" class="headerlink" title="2．while语句"></a>2．while语句</h5><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>语句的一般格式为：</span><br><span class="line"><span class="keyword">while</span> (条件)</span><br><span class="line">     循环体语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>​    其执行过程为：若条件成立，则执行循环体语句，执行后再判断条件是否成立，如果不成立则跳出循环。</p><h5 id="3．break语句和continue语句"><a href="#3．break语句和continue语句" class="headerlink" title="3．break语句和continue语句"></a>3．break语句和continue语句</h5><p>​    与循环结构相关的语句还有break语句和continue语句。它们一般与if语句配合使用。<br>​    break语句用于终止循环的执行。当在循环体内执行到该语句时，程序将跳出循环，继续执行循环语句的下一语句。<br>​    continue语句控制跳过循环体中的某些语句。当在循环体内执行到该语句时，程序将跳过循环体中所有剩下的语句，继续下一次循环。</p><h5 id="4．循环的嵌套"><a href="#4．循环的嵌套" class="headerlink" title="4．循环的嵌套"></a>4．循环的嵌套</h5><p>​    如果一个循环结构的循环体又包括一个循环结构，就称为循环的嵌套，或称为多重循环结构。<br>例：  若一个数等于它的各个真因子之和，则称该数为完数，如6=1+2+3，所以6是完数。求[1,500]之间的全部完数。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m=<span class="number">1</span>:<span class="number">500</span></span><br><span class="line">s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:m/<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">rem</span>(m,k)==<span class="number">0</span></span><br><span class="line">s=s+k;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> m==s</span><br><span class="line">    <span class="built_in">disp</span>(m);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="4-3-函数文件"><a href="#4-3-函数文件" class="headerlink" title="4.3 函数文件"></a>4.3 函数文件</h3><h5 id="4-3-1-函数文件的基本结构"><a href="#4-3-1-函数文件的基本结构" class="headerlink" title="4.3.1  函数文件的基本结构"></a>4.3.1  函数文件的基本结构</h5><p>​    函数文件由function语句引导，其基本结构为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 输出形参表=函数名<span class="params">(输入形参表)</span></span></span><br><span class="line">    注释说明部分</span><br><span class="line">    函数体语句</span><br></pre></td></tr></table></figure><p>其中以function开头的一行为引导行，表示该M文件是一个函数文件。函数名的命名规则与变量名相同。输入形参为函数的输入参数，输出形参为函数的输出参数。当输出形参多于一个时，则应该用方括号括起来。</p><h5 id="4-3-2-函数调用"><a href="#4-3-2-函数调用" class="headerlink" title="4.3.2  函数调用"></a>4.3.2  函数调用</h5><p>1.函数调用的一般格式是：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[输出实参表]=函数名(输入实参表)</span><br></pre></td></tr></table></figure><p>​    要注意的是，函数调用时各实参出现的顺序、个数，应与函数定义时形参的顺序、个数一致，否则会出错。函数调用时，先将实参传递给相应的形参，从而实现参数传递，然后再执行函数的功能。</p><p>2．函数的递归调用<br>在MATLAB中，函数可以嵌套调用，即一个函数可以调用别的函数，甚至调用它自身。一个函数调用它自身称为函数的递归调用。</p><p>例： 利用函数的递归调用，求n！。<br>    n!本身就是以递归的形式定义的：<br>   显然，求n!需要求(n-1)!，这时可采用递归调用。递归调用函数文件</p><p>factor.m如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>=<span class="title">factor</span><span class="params">(n)</span></span></span><br><span class="line"><span class="keyword">if</span> n&lt;=<span class="number">1</span></span><br><span class="line">   f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   f=<span class="built_in">factor</span>(n<span class="number">-1</span>)*n;    <span class="comment">%递归调用求(n-1)!</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="4-3-3-函数参数的可调性"><a href="#4-3-3-函数参数的可调性" class="headerlink" title="4.3.3  函数参数的可调性"></a>4.3.3  函数参数的可调性</h5><p>​    在调用函数时，MATLAB用两个<strong>永久变量nargin和nargout</strong>分别记录调用该函数时的输入实参和输出实参的个数。只要在函数文件中包含这两个变量，就可以准确地知道该函数文件被调用时的输入输出参数个数，从而决定函数如何进行处理。</p><blockquote><p>注意：</p><p>for k = [1,2,3,4]与 for k = [1;2;3;4]执行的次数不一样，第一个执行4次，第二只执行1次。</p></blockquote><h5 id="4-3-4-全局变量与局部变量"><a href="#4-3-4-全局变量与局部变量" class="headerlink" title="4.3.4  全局变量与局部变量"></a>4.3.4  全局变量与局部变量</h5><p>函数文件中的变量是局部的，即在一个函数文件中定义的变量不能被另一个函数文件引用。如果在若干函数中都把某一变量定义为全局变量，那么这些函数将共用这个变量，作用域是整个工作空间，即全程有效。<br>全局变量用global命令定义，格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> 变量名</span><br></pre></td></tr></table></figure><h3 id="4-4特殊形式的函数"><a href="#4-4特殊形式的函数" class="headerlink" title="4.4特殊形式的函数"></a>4.4特殊形式的函数</h3><h4 id="4-3-1、子函数"><a href="#4-3-1、子函数" class="headerlink" title="4.3.1、子函数"></a>4.3.1、子函数</h4><p>在MATLAB中，可以在一个M文件中同时定义多个函数，其中M文件中出现的第一个函数称为主函数（primary function），其他函数称为子函数（subfunction），但需要注意的是子函数只能由同一M文件中的函数调用。在保存M文件时，M文件名一般和主函数名相同，外部程序只能对主函数进行调用。</p><h4 id="2-内联函数"><a href="#2-内联函数" class="headerlink" title="2. 内联函数"></a>2. 内联函数</h4><p>以字符串形式存在的函数表达式可以通过inline函数转化成内联函数。例如a=’(x+y)^2’，可以通过f=inline(a)生成内联函数f(x,y)=(x+y)^2。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a=<span class="string">&#x27;(x+y)^2&#x27;</span>;</span><br><span class="line">f=inline(a)</span><br><span class="line">f =</span><br><span class="line">     内联函数:</span><br><span class="line">     f(x,y) = (x+y)^<span class="number">2</span></span><br><span class="line">f(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">49</span></span><br></pre></td></tr></table></figure><h4 id="3-匿名函数"><a href="#3-匿名函数" class="headerlink" title="3. 匿名函数"></a>3. 匿名函数</h4><p>匿名函数的基本格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匿名函数名=@(输入参数) 匿名函数表达式</span><br></pre></td></tr></table></figure><p>其中，匿名函数的输入参数可以是一个，也可以是多个，有多个参数时，参数间用逗号分隔。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; f=@(x,y) x^<span class="number">2</span>+y^<span class="number">2</span>;</span><br><span class="line">f(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">25</span></span><br></pre></td></tr></table></figure><h3 id="4-5程序调试与优化"><a href="#4-5程序调试与优化" class="headerlink" title="4.5程序调试与优化"></a>4.5程序调试与优化</h3><h4 id="4-5-1-程序调试方法"><a href="#4-5-1-程序调试方法" class="headerlink" title="4.5.1  程序调试方法"></a>4.5.1  程序调试方法</h4><p>一般来说，应用程序的错误有两类，一类是语法错误，另一类是运行时的错误。语法错误包括词法或文法的错误，例如函数名的拼写错、表达式书写错等。</p><h5 id="程序优化"><a href="#程序优化" class="headerlink" title="程序优化"></a>程序优化</h5><p>（1）采用向量化运算<br>在实际MATLAB程序设计中，为了提高程序的执行速度，常用向量或矩阵运算来代替循环操作。<br>（2）预分配内存空间<br>通过在循环之前预分配向量或数组的内存空间可以提高for循环的处理速度。<br>（3）减小运算强度<br>在实现有关运算时，尽量采用运算量更小的运算，从而提高运算速度。一般来说，乘法比乘方运算快，加法比乘法运算快。</p>]]></content>
      
      
      <categories>
          
          <category> MATLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、MATLAB数据及其运算</title>
      <link href="/2021/11/09/5%E3%80%81matlab/%E4%BA%8C%E3%80%81MATLAB%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/"/>
      <url>/2021/11/09/5%E3%80%81matlab/%E4%BA%8C%E3%80%81MATLAB%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="二、MATLAB数据及其运算"><a href="#二、MATLAB数据及其运算" class="headerlink" title="二、MATLAB数据及其运算"></a>二、MATLAB数据及其运算</h2><blockquote><p><strong>声明：</strong><br>笔记是学习慕课网《科学计算与MATLAB语言》课程和刘卫国主编的《MATLAB程序设计与应用（第3版）》后的个人总结，方便自己以后巩固和复习！</p></blockquote><h3 id="2-1-Matlab数值数据"><a href="#2-1-Matlab数值数据" class="headerlink" title="2.1  Matlab数值数据"></a>2.1  Matlab数值数据</h3><h4 id="2-1-1-数值数据类型的分类"><a href="#2-1-1-数值数据类型的分类" class="headerlink" title="2.1.1  数值数据类型的分类"></a>2.1.1  数值数据类型的分类</h4><h5 id="1．整型"><a href="#1．整型" class="headerlink" title="1．整型"></a>1．整型</h5><p>整型数据是不带小数的数，分为有带符号整数和无符号整数。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/0.png"></p><h5 id="2．浮点型"><a href="#2．浮点型" class="headerlink" title="2．浮点型"></a>2．浮点型</h5><p>浮点型数据有单精度（single）和双精度（double）之分，单精度型实数在内存中占用4个字节，双精度型实数在内存中占用8个字节，双精度型的数据精度更高。</p><p>在Matlab中，数据默认为双精度型。</p><blockquote><p>single函数 可以将其他类型的数据转换为单精度型；利用class可以得到参数的数据类型。</p><p>double函数 可以将其他类型的数据转换为双精度型。</p></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/1.png"></p><h5 id="3．复型"><a href="#3．复型" class="headerlink" title="3．复型"></a>3．复型</h5><p>复型数据包括实部和虚部两个部分，实部和虚部默认为双精度型。</p><p>在MATLAB中，虚数单位用i或j表示。</p><blockquote><p>例如，6+5i与6+5j表示的是同一个复数，也可以写成6+5<em>i或6+5</em>j，这里将i或j看作一个运算量参与表达式的运算。</p></blockquote><h4 id="2-1-2-数据的输出格式"><a href="#2-1-2-数据的输出格式" class="headerlink" title="2.1.2  数据的输出格式"></a>2.1.2  数据的输出格式</h4><p>MATLAB用十进制数表示一个常数，具体可采用日常记数法和科学记数法两种表示方法。</p><p>format命令的格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format 格式符  </span><br></pre></td></tr></table></figure><p>其中，格式符决定数据的输出格式，各种格式符及其含义如表所示。</p><table><thead><tr><th><strong>格式符</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>short</strong></td><td><strong>输出小数点后4位，最多不超过7位有效数字。对于大于1000的实数，用5位有效数字的科学记数形式输出</strong></td></tr><tr><td><strong>long</strong></td><td><strong>15位有效数字形式输出</strong></td></tr><tr><td><strong>short e</strong></td><td><strong>5位有效数字的科学记数形式输出</strong></td></tr><tr><td><strong>long e</strong></td><td><strong>15位有效数字的科学记数形式输出</strong></td></tr><tr><td><strong>short g</strong></td><td><strong>从short和short e中自动选择最佳输出方式</strong></td></tr><tr><td><strong>long g</strong></td><td><strong>从long和long e中自动选择最佳输出方式</strong></td></tr><tr><td><strong>rat</strong></td><td><strong>近似有理数表示</strong></td></tr><tr><td><strong>hex</strong></td><td><strong>十六进制表示</strong></td></tr><tr><td><strong>+</strong></td><td><strong>正数、负数、零分别用+、-、空格表示</strong></td></tr><tr><td><strong>bank</strong></td><td><strong>银行格式，用元、角、分表示</strong></td></tr><tr><td><strong>compact</strong></td><td><strong>输出变量之间没有空行</strong></td></tr><tr><td><strong>loose</strong></td><td><strong>输出变量之间有空行</strong></td></tr></tbody></table><blockquote><p><strong>注意：format命令只影响数据输出格式，而不影响数据的计算和存储。</strong></p></blockquote><h3 id="2-2-MATLAB矩阵的表示"><a href="#2-2-MATLAB矩阵的表示" class="headerlink" title="2.2 MATLAB矩阵的表示"></a>2.2 MATLAB矩阵的表示</h3><h4 id="2-2-1-矩阵的建立"><a href="#2-2-1-矩阵的建立" class="headerlink" title="2.2.1  矩阵的建立"></a>2.2.1  矩阵的建立</h4><p>1．直接输入法:</p><p>最简单的建立矩阵的方法是从键盘直接输入矩阵的元素。</p><p>具体方法如下：将矩阵的元素用方括号括起来，按矩阵行的顺序输入各元素，同一行的各元素之间用空格或逗号分隔，不同行的元素之间用分号分隔。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/2.png"></p><h4 id="2-2-2-冒号表达式"><a href="#2-2-2-冒号表达式" class="headerlink" title="2.2.2   冒号表达式"></a>2.2.2   冒号表达式</h4><p>冒号表达式可以产生一个行向量，</p><p>一般格式是： </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e1:e2:e3</span><br></pre></td></tr></table></figure><p>其中e1为初始值，e2为步长，e3为终止值。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/3.png"></p><p>初始值:4 步长:3 终止值:12。</p><p>在MATLAB中，还可以用linspace函数产生行向量。</p><p>其调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">linspace</span>(a,b,n)</span><br></pre></td></tr></table></figure><p>其中a和b是生成向量的第一个和最后一个元素，n是元素总数。</p><blockquote><p>显然，linspace(a,b,n)与a:(b-a)/(n-1):b等价</p></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/4.png"></p><h4 id="2-2-3-矩阵的引用"><a href="#2-2-3-矩阵的引用" class="headerlink" title="2.2.3  矩阵的引用"></a>2.2.3  矩阵的引用</h4><h5 id="1．矩阵元素的引用方式"><a href="#1．矩阵元素的引用方式" class="headerlink" title="1．矩阵元素的引用方式"></a>1．矩阵元素的引用方式</h5><p>MATLAB通过下标引用矩阵的元素</p><blockquote><p>例如：A(3,2)=200</p></blockquote><p>也可以采用矩阵元素的序号来引用矩阵元素。矩阵元素的序号就是相应元素在内存中的排列顺序。</p><p>在MATLAB中，矩阵元素按列存储，先第一列，再第二列，依次类推。<br> 显然，序号(Index)与下标(Subscript )是一一对应的，以m×n矩阵A为例，矩阵元素A(i,j)的序号为(j-1)*m+i。其相互转换关系也可利用sub2ind和ind2sub函数求得。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/5.png"></p><h5 id="2-利用冒号表达式获得子矩阵"><a href="#2-利用冒号表达式获得子矩阵" class="headerlink" title="2.利用冒号表达式获得子矩阵"></a>2.利用冒号表达式获得子矩阵</h5><p>① A(:,j)表示取A矩阵的第j列全部元素；A(i,:)表示A矩阵第i行的全部元素；A(i,j)表示取A矩阵第i行、第j列的元素。</p><p>② A(i:i+m,:)表示取A矩阵第i～i+m行的全部元素；A(:,k:k+m)表示取A矩阵第k～k+m列的全部元素，A(i:i+m,k:k+m)表示取A矩阵第i～i+m行内，并在第k～k+m列中的所有元素。 ③A(:)将矩阵A每一列元素堆叠起来，成为一个列向量，而这也是MATLAB变量的内部储存方式。</p><h5 id="3-利用空矩阵删除矩阵的元素"><a href="#3-利用空矩阵删除矩阵的元素" class="headerlink" title="3.利用空矩阵删除矩阵的元素"></a>3.利用空矩阵删除矩阵的元素</h5><p>在MATLAB中，定义[]为空矩阵。给变量X赋空矩阵的语句为</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=[]</span><br></pre></td></tr></table></figure><p>注意，X=[]与clear X不同，clear是将X从工作空间中删除，而空矩阵则存在于工作空间中，只是维数为0。</p><h5 id="4．改变矩阵的形状"><a href="#4．改变矩阵的形状" class="headerlink" title="4．改变矩阵的形状"></a>4．改变矩阵的形状</h5><p>reshape(A,m,n)函数在矩阵总元素保持不变的前提下，将矩阵A重新排成m×n的二维矩阵。</p><p>例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="number">23</span>,<span class="number">45</span>,<span class="number">65</span>,<span class="number">34</span>,<span class="number">65</span>,<span class="number">34</span>,<span class="number">98</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">65</span>,<span class="number">43</span>,<span class="number">76</span></span><br><span class="line">y=<span class="built_in">reshape</span>(x,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">y =</span><br><span class="line">    <span class="number">23</span>    <span class="number">34</span>    <span class="number">98</span>    <span class="number">65</span></span><br><span class="line">    <span class="number">45</span>    <span class="number">65</span>    <span class="number">45</span>    <span class="number">43</span></span><br><span class="line">    <span class="number">65</span>    <span class="number">34</span>    <span class="number">78</span>    <span class="number">76</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>reshape函数只是改变原矩阵的行数和列数，即改变其逻辑结构，但并不改变原矩阵元素个数及其存储顺序。<br>A(:)将矩阵A的每一列元素堆叠起来，成为一个列向量，从而改变了矩阵的形状。</p></blockquote><h3 id="2-3-变量及其操作"><a href="#2-3-变量及其操作" class="headerlink" title="2.3  变量及其操作"></a>2.3  变量及其操作</h3><h4 id="2-3-1-变量与赋值语句"><a href="#2-3-1-变量与赋值语句" class="headerlink" title="2.3.1  变量与赋值语句"></a>2.3.1  变量与赋值语句</h4><h5 id="1．变量命名"><a href="#1．变量命名" class="headerlink" title="1．变量命名"></a>1．变量命名</h5><p>在MATLAB 7.0中，<strong>变量名是以字母开头，后接字母、数字或下划线的字符序列，最多63个字符。</strong>在MATLAB中，变量名区分字母的大小写。</p><h5 id="2．赋值语句"><a href="#2．赋值语句" class="headerlink" title="2．赋值语句"></a>2．赋值语句</h5><blockquote><p>(1) 变量=表达式 </p><p>(2) 表达式</p></blockquote><p>其中表达式是用运算符将有关运算量连接起来的式子，其结果是一个矩阵。</p><p>例如：计算表达式的值，并显示计算结果</p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/6.png" style="zoom:33%;" /><p>在MATLAB命令窗口输入命令：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; x=<span class="built_in">sqrt</span>(<span class="number">7</span>)<span class="number">-2</span><span class="built_in">i</span>;</span><br><span class="line">y=<span class="built_in">exp</span>(<span class="built_in">pi</span>/<span class="number">2</span>);</span><br><span class="line">z=(<span class="number">5</span>+<span class="built_in">cos</span>(<span class="number">47</span>*<span class="built_in">pi</span>/<span class="number">180</span>))/(<span class="number">1</span>+<span class="built_in">abs</span>(x-y))</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/7.png"></p><h4 id="2-3-2预定义变量"><a href="#2-3-2预定义变量" class="headerlink" title="2.3.2预定义变量"></a>2.3.2预定义变量</h4><p> 在MATLAB工作空间中，还驻留几个由系统本身定义的变量。例如，用pi表示圆周率π的近似值，用i，j表示虚数单位。</p><p><strong>预定义变量有特定的含义，在使用时，应尽量避免对这些变量重新赋值。</strong></p><h4 id="2-3-3-变量的管理"><a href="#2-3-3-变量的管理" class="headerlink" title="2.3.3  变量的管理"></a>2.3.3  变量的管理</h4><h5 id="1．内存变量的删除与修改"><a href="#1．内存变量的删除与修改" class="headerlink" title="1．内存变量的删除与修改"></a>1．内存变量的删除与修改</h5><p>MATLAB工作区窗口专门用于内存变量的管理。在工作区窗口中可以显示所有内存变量的属性。</p><p>who和whos这两个命令用于显示在MATLAB工作空间中已经驻留的变量名清单。</p><blockquote><p>who命令只显示出驻留变量的名称；</p><p>whos在给出变量名的同时，还给出它们的大小、所占字节数及数据类型等信息。 </p></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/8.png"></p><blockquote><p>clear命令用于删除MATLAB工作空间中的变量。</p></blockquote><p>2．内存变量文件利用MAT文件可以把当前MATLAB工作空间中的一些有用变量长久地保留下来，扩展名是.mat。MAT文件的生成和装入由save和load命令来完成。常用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save 文件名 [变量名表]  [-append] [-ascii]</span><br><span class="line">load 文件名  [变量名表]  [-ascii]</span><br></pre></td></tr></table></figure><p>其中，文件名可以带路径，但不需带扩展名.mat，命令隐含一定对.mat文件进行操作。变量名表中的变量个数不限，只要内存或文件中存在即可，变量名之间以空格分隔。当变量名表省略时，保存或装入全部变量。-ascii选项使文件以ASCII格式处理，省略该选项时文件将以二进制格式处理。save命令中的-append选项控制将变量追加到MAT文件中。</p><h3 id="2-4-MATLAB常用内部函数"><a href="#2-4-MATLAB常用内部函数" class="headerlink" title="2.4  MATLAB常用内部函数"></a>2.4  MATLAB常用内部函数</h3><h4 id="2-4-1-常用数学函数"><a href="#2-4-1-常用数学函数" class="headerlink" title="2.4.1  常用数学函数"></a>2.4.1  常用数学函数</h4><p>MATLAB提供了许多数学函数，函数的自变量规定为矩阵变量，运算法则是将函数逐项作用于矩阵的元素上，因而运算的结果是一个与自变量同维数的矩阵。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/9.png"></p><h4 id="2-4-2-矩阵的超越函数"><a href="#2-4-2-矩阵的超越函数" class="headerlink" title="2.4.2  矩阵的超越函数"></a>2.4.2  矩阵的超越函数</h4><p>MATLAB还提供了一些直接作用于矩阵的超越函数，这些函数名都在上述内部函数名之后缀以m，并规定输入参数A必须是方阵。</p><h5 id="1．矩阵平方根"><a href="#1．矩阵平方根" class="headerlink" title="1．矩阵平方根"></a>1．矩阵平方根</h5><p>sqrtm(A)计算矩阵A的平方根。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/10.png"></p><h5 id="2．矩阵对数"><a href="#2．矩阵对数" class="headerlink" title="2．矩阵对数"></a>2．矩阵对数</h5><p>logm(A)计算矩阵A的自然对数。此函数输入参数的条件与输出结果间的关系和函数sqrtm(A)完全一样。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/11.png"></p><h5 id="3．矩阵指数"><a href="#3．矩阵指数" class="headerlink" title="3．矩阵指数"></a>3．矩阵指数</h5><p>expm(A)的功能都是求矩阵指数eA。例如，对上面计算所得到的A的自然对数b.</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/12.png"></p><h5 id="4．普通矩阵函数"><a href="#4．普通矩阵函数" class="headerlink" title="4．普通矩阵函数"></a>4．普通矩阵函数</h5><p>funm(A,@fun)对方阵A计算由fun定义的函数的矩阵函数值。例如，当fun取exp时，funm(A,@exp)可以计算矩阵A的指数，与expm(A)的计算结果一样。</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/13.png"></p><h3 id="2-5-MATLAB运算"><a href="#2-5-MATLAB运算" class="headerlink" title="2.5 MATLAB运算"></a>2.5 MATLAB运算</h3><h4 id="2-5-1-算术运算"><a href="#2-5-1-算术运算" class="headerlink" title="2.5.1  算术运算"></a>2.5.1  算术运算</h4><h5 id="1．基本算术运算"><a href="#1．基本算术运算" class="headerlink" title="1．基本算术运算"></a>1．基本算术运算</h5><p>MATLAB的基本算术运算有：＋(加)、－(减)、*(乘)、/(右除)、(左除)、^(乘方)。</p><p>注意，运算是在矩阵意义下进行的，单个数据的算术运算只是一种特例。</p><p> (1) 矩阵加减运算</p><blockquote><p>假定有两个矩阵A和B，则可以由A+B和A-B实现矩阵的加减运算。运算规则是：若A和B矩阵的维数相同，则可以执行矩阵的加减运算，A和B矩阵的相应元素相加减。如果A与B的维数不相同，则MATLAB将给出错误信息，提示用户两个矩阵的维数不匹配。</p></blockquote><p>(2) 矩阵乘法</p><blockquote><p>假定有两个矩阵A和B，若A为m×n矩阵，B为n×p矩阵，则C=A*B为m×p矩阵。</p></blockquote><p>(3) 矩阵除法</p><blockquote><p>在MATLAB中，有两种矩阵除法运算：\和/，分别表示左除和右除。</p><p>如果A矩阵是非奇异方阵，则A\B和B/A运算可以实现。</p><blockquote><p>A\B等效于A的逆左乘B矩阵，也就是inv(A) *B，</p><p>而B/A等效于A矩阵的逆右乘B矩阵，也就是B*inv(A)。</p></blockquote></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/14.png"></p><p>  (4) 矩阵的乘方</p><p>一个矩阵的乘方运算可以表示成A^x，要求A为方阵，x为标量。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A^<span class="number">2</span> = A*A</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/15.png"></p><h5 id="2．点运算"><a href="#2．点运算" class="headerlink" title="2．点运算"></a>2．点运算</h5><p>在MATLAB中，有一种特殊的运算，因为其运算符是在有关算术运算符前面加点，所以叫点运算。点运算符有.*、./、.\和.^。两矩阵进行点运算是指它们的对应元素进行相关运算，要求两矩阵的维参数相同。</p><h4 id="2-5-2-关系运算"><a href="#2-5-2-关系运算" class="headerlink" title="2.5.2  关系运算"></a>2.5.2  关系运算</h4><blockquote><p> MATLAB提供了6种关系运算符：</p><p> &lt;(小于)、&lt;=(小于或等于)、&gt;(大于)、&gt;=(大于或等于)、==(等于)、～=(不等于)。<br> 它们的含义不难理解，但要注意其书写方法与数学中的不等式符号不尽相同。</p></blockquote><p>关系运算符的运算法则为：</p><blockquote><p> (1) 当两个比较量是标量时，直接比较两数的大小。若关系成立，关系表达式结果为1，否则为0。</p><p> (2) 当参与比较的量是两个维数相同的矩阵时，比较是对两矩阵相同位置的元素按标量关系运算规则逐个进行，并给出元素比较结果。最终的关系运算的结果是一个维数与原矩阵相同的矩阵，它的元素由0或1组成。</p><p> (3) 当参与比较的一个是标量，而另一个是矩阵时，则把标量与矩阵的每一个元素按标量关系运算规则逐个比较，并给出元素比较结果。最终的关系运算的结果是一个维数与原矩阵相同的矩阵，它的元素由0或1组成。</p></blockquote><p>   例如：</p><p>建立5阶方阵A，判断A的元素是否能被3整除</p><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Matlab2/16.png"></p><blockquote><p>其中，rem(A,3)是矩阵A的每个元素除以3的余数矩阵。此时，0被扩展为与A同维数的零矩阵，P是进行等于(==)比较的结果矩阵。</p></blockquote><h4 id="2-5-3-逻辑运算"><a href="#2-5-3-逻辑运算" class="headerlink" title="2.5.3  逻辑运算"></a>2.5.3  逻辑运算</h4><p> MATLAB提供了3种逻辑运算符：&amp;(与)、|(或)和～(非)。</p><p>逻辑运算的运算法则为：</p><blockquote><p>(1) 在逻辑运算中，确认非零元素为真，用1表示，零元素为假，用0表示。</p><p>(2) 设参与逻辑运算的是两个标量a和b，</p><p>那么，a&amp;b  a,b全为非零时，运算结果为1，否则为0。</p><p>a|b  a,b中只要有一个非零，运算结果为1。</p><p>～a  当a是零时，运算结果为1；当a非零时，运算结果为0。</p><p>(3) 若参与逻辑运算的是两个同维矩阵，那么运算将对矩阵相同位置上的元素按标量规则逐个进行。最终运算结果是一个与原矩阵同维的矩阵，其元素由1或0组成。</p><p>(4) 若参与逻辑运算的一个是标量，一个是矩阵，那么运算将在标量与矩阵中的每个元素之间按标量规则逐个进行。最终运算结果是一个与矩阵同维的矩阵，其元素由1或0组成。</p><p>(5) 逻辑非是单目运算符，也服从矩阵运算规则。</p><p>(6) 在算术、关系、逻辑运算中，算术运算优先级最高，逻辑运算优先级最低。</p></blockquote><h3 id="2-6-字符串"><a href="#2-6-字符串" class="headerlink" title="2.6  字符串"></a>2.6  字符串</h3><p>在MATLAB中，字符串是用单撇号括起来的字符序列。</p><p>MATLAB将字符串当作一个行向量，每个元素对应一个字符，其标识方法和数值向量相同。也可以建立多行字符串矩阵。</p><h5 id="2-6-1-字符串的表示"><a href="#2-6-1-字符串的表示" class="headerlink" title="2.6.1  字符串的表示"></a>2.6.1  字符串的表示</h5><p>在MATLAB中，字符串是用单引号括起来的字符序列。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xm=<span class="string">&#x27;Central South University&#x27;</span></span><br></pre></td></tr></table></figure><p>例：建立一个字符串向量，然后对该向量做如下处理：</p><blockquote><p>(1) 取第1～5个字符组成的子字符串。</p><p>(2) 将字符串倒过来重新排列。</p><p>(3) 将字符串中的小写字母变成相应的大写字母，其余字符不变。</p><p>(4) 统计字符串中小写字母的个数。</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch=<span class="string">&#x27;ABc123d4e56Fg9&#x27;</span>;</span><br><span class="line">subch=ch(<span class="number">1</span>:<span class="number">5</span>)           <span class="comment">%取子字符串</span></span><br><span class="line">revch=ch(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>)       <span class="comment">%将字符串倒排</span></span><br><span class="line">k=<span class="built_in">find</span>(ch&gt;=<span class="string">&#x27;a&#x27;</span>&amp;ch&lt;=<span class="string">&#x27;z&#x27;</span>);     <span class="comment">%找小写字母的位置</span></span><br><span class="line">ch(k)=ch(k)-(<span class="string">&#x27;a&#x27;</span>-<span class="string">&#x27;A&#x27;</span>);         <span class="comment">%将小写字母变成相应的大写字母</span></span><br><span class="line">char(ch)                </span><br><span class="line"><span class="built_in">length</span>(k)                  <span class="comment">%统计小写字母的个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意是英文下的单撇号；’ABc123d4e56Fg9’，不是‘ABc123d4e56Fg9’</p></blockquote><h5 id="2-6-2-字符串的操作"><a href="#2-6-2-字符串的操作" class="headerlink" title="2.6.2  字符串的操作"></a>2.6.2  字符串的操作</h5><p>1．字符串的执行<br>与字符串有关的一个重要函数是eval，它的作用是把字符串的内容作为对应的MATLAB命令来执行，其调用格式为：<br>eval(s)<br>其中s为字符串。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; t=<span class="built_in">pi</span>;</span><br><span class="line">m=<span class="string">&#x27;[t,sin(t),cos(t)]&#x27;</span>;</span><br><span class="line">y=eval(m)</span><br><span class="line">y =</span><br><span class="line">    <span class="number">3.1416</span>    <span class="number">0.0000</span>   <span class="number">-1.0000</span></span><br></pre></td></tr></table></figure><p>2．字符串与数值之间的转换<br>字符串是以ASCII码形式存储的，abs和double函数都可以用来获取字符串矩阵所对应的ASCII码数值矩阵。</p><p>3．字符串的连接<br>在MATLAB中，要将两个字符串连接在一起，有两种常见方法：一是用字符串向量，二是用strcat函数。</p><p>4．字符串的比较<br>字符串的比较有两种方法：<strong>利用关系运算符</strong>或<strong>字符串比较函数</strong>。<br>当两个字符串拥有相同的长度时，可以利用关系运算符对字符串进行比较，比较的规则是按ASCII值大小逐个字符进行比较，比较的结果是一个数值向量，其元素为对应字符比较的结果。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="string">&#x27;www0&#x27;</span>&gt;=<span class="string">&#x27;W123&#x27;</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure><p>字符串比较函数用于判断字符串是否相等，有4种比较方式，函数如下：</p><blockquote><p>① strcmp(s1,s2)：用来比较字符串s1和s2是否相等，如果相等，返回1，否则返回0。<br>② strncmp(s1,s2,n)：用来比较前n个字符是否相等，如果相等，返回1，否则返回0。<br>③ strcmpi(s1,s2)：在忽略字母大小写前提下，比较字符串s1和s2是否相等，如果相等，返回1，否则返回0。<br>④ strncmpi(s1,s2,n)：在忽略字符串大小写前提下，比较前n个字符是否相等，如果相等，返回1，否则返回0。</p></blockquote><h3 id="2-7-结构数据和单元数据"><a href="#2-7-结构数据和单元数据" class="headerlink" title="2.7  结构数据和单元数据"></a>2.7  结构数据和单元数据</h3><h5 id="2-7-1-结构数据"><a href="#2-7-1-结构数据" class="headerlink" title="2.7.1  结构数据"></a>2.7.1  结构数据</h5><p>1．结构矩阵的建立与引用</p><p>建立一个结构矩阵可采用给结构成员赋值的办法。</p><p>具体格式为：</p><blockquote><p>结构矩阵名.成员名=表达式</p><p>其中表达式应理解为矩阵表达式。</p></blockquote><p>2．结构成员的修改</p><p>可以根据需要增加或删除结构的成员。</p><p>例如要给结构矩阵a增加一个成员x4，可给a中任意一个元素增加成员x4：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a(<span class="number">1</span>).x4=‘<span class="number">410075</span>’;</span><br></pre></td></tr></table></figure><p>但其他成员均为空矩阵，可以使用赋值语句给它赋确定的值。</p><p>要删除结构的成员，则可以使用rmfield函数来完成。</p><p>例如，删除成员x4：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=rmfield(a,‘x4’);</span><br></pre></td></tr></table></figure><h5 id="2-7-2-单元数据"><a href="#2-7-2-单元数据" class="headerlink" title="2.7.2  单元数据"></a>2.7.2  单元数据</h5><p>建立单元矩阵和一般矩阵相似，只是矩阵元素用大括号括起来。</p><p>可以用带有大括号下标的形式引用单元矩阵元素。例如b{3,3}。单元矩阵的元素可以是结构或单元数据。</p><p>可以使用celldisp函数来显示整个单元矩阵，如celldisp(b)。</p>]]></content>
      
      
      <categories>
          
          <category> MATLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写博客的意义及此博客介绍（必看！！！）</title>
      <link href="/2021/11/08/0%E3%80%81hello_Blog/hello-world/"/>
      <url>/2021/11/08/0%E3%80%81hello_Blog/hello-world/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/CSDN_51che/src=http---www.mianfeiwendang.com-pic-19484a0c6efc11aab2a7cef732243488c7b81bc4-1-810-jpg_6-1080-0-0-1080.jpg&refer=http---www.mianfeiwendang.jpg"></p><blockquote><p>2021年11月7日创建了这个博客。</p></blockquote><h2 id="搭建个人博客和写博客的意义："><a href="#搭建个人博客和写博客的意义：" class="headerlink" title="搭建个人博客和写博客的意义："></a>搭建个人博客和写博客的意义：</h2><blockquote><p>①、便于以后对知识点的巩固复习；</p><p>②、建立起自己的知识清单；</p><p>③、记录学习中遇到的一些问题；</p><p>④、提高自己的写作能力；</p><p>⑤、为自己以后面试加分；</p><p>⑥、认识很多有意思的朋友；</p><p>⑦、提高阅读量，认识度。</p><p>⑧、在浩瀚无穷的网络世界留下属于我的足迹！</p></blockquote><h2 id="博主介绍："><a href="#博主介绍：" class="headerlink" title="博主介绍："></a>博主介绍：</h2><blockquote><p>一个普普通通的电信（电子信息工程）专业学习，对嵌入式和无人驾驶比较感兴趣，大学期间无才，参加过一些学科竞赛：互联网+、电子设计大赛、智能车竞赛、节能减排竞赛、Robomaser，当然也拿到了一些不错的荣誉；回顾自己的大学四年，“悄悄的来，悄悄的走！”，无论在学校还是在浩瀚的互联网世界都没有留下属于自己的足迹，因此捣鼓了这个博客，逝去的青春就像失去的女孩无法挽留，只有珍惜现在，放眼未来，所有此博客主要记录自己的学习和工作（无人驾驶方向）的笔记；当然欢迎大佬一起交流哈！联系方式：QQ–1622697411。</p></blockquote><blockquote><p>这不得露个脸？ 😂😂😂😂</p></blockquote><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Linux/20211120162736.png"></p><blockquote><p>猜猜这是去干啥？</p><p>很荣幸我也是见过、参与过 <strong>国产碳基芯片</strong> 的人，为强大的祖国点赞👍👍👍</p></blockquote><h2 id="博文学习目录："><a href="#博文学习目录：" class="headerlink" title="博文学习目录："></a>博文学习目录：</h2><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/Linux/20211120155229.png"></p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="C-基础"><a href="#C-基础" class="headerlink" title="C++ 基础"></a>C++ 基础</h4><h4 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h4><p><a href="https://zhuizhengzhe.github.io/2021/11/13/1%E3%80%81C++/3.C++%20STL/0%E3%80%81C++%20STL--%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/">C++ STL–标准模板库分类</a></p><p><a href="https://zhuizhengzhe.github.io/2021/11/13/1%E3%80%81C++/3.C++%20STL/1%E3%80%81C++%20STL%EF%BC%9Astring%E5%AE%B9%E5%99%A8/">一、C++ STL–标准模板库：string–字符串容器</a></p><p><a href="https://zhuizhengzhe.github.io/2021/11/13/1%E3%80%81C++/3.C++%20STL/2%E3%80%81C++%20STL%EF%BC%9Avector%E5%AE%B9%E5%99%A8/">二、C++ STL–标准模板库：vector容器</a></p><p><a href="https://zhuizhengzhe.github.io/2021/11/18/1%E3%80%81C++/3.C++%20STL/3%E3%80%81C++%20STL%EF%BC%9Adeque%E5%AE%B9%E5%99%A8/">三、C++ STL–标准模板库：deque 容器</a></p><h4 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++ 新特性"></a>C++ 新特性</h4><p><a href="https://zhuizhengzhe.github.io/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/1%E3%80%81auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/">一、C++11新特性：auto类型推导</a></p><p><a href="%5B%E4%B8%80%E3%80%81C++11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9Aauto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%5D(https://zhuizhengzhe.github.io/2021/11/13/1%E3%80%81C++/2.C++%E6%96%B0%E7%89%B9%E6%80%A7/1%E3%80%81auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/)">二、C++11新特性：decltype类型推导</a></p><h4 id="C-刷题"><a href="#C-刷题" class="headerlink" title="C++ 刷题"></a>C++ 刷题</h4><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h4><h4 id="嵌入式Linux"><a href="#嵌入式Linux" class="headerlink" title="嵌入式Linux"></a>嵌入式Linux</h4><h3 id="ROS"><a href="#ROS" class="headerlink" title="ROS"></a>ROS</h3><h4 id="ROS基础"><a href="#ROS基础" class="headerlink" title="ROS基础"></a>ROS基础</h4><h4 id="ROS仿真"><a href="#ROS仿真" class="headerlink" title="ROS仿真"></a>ROS仿真</h4><h3 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h3><h4 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a>STM32CubeMX</h4><h3 id="无人驾驶"><a href="#无人驾驶" class="headerlink" title="无人驾驶"></a>无人驾驶</h3><h4 id="路径规划"><a href="#路径规划" class="headerlink" title="路径规划"></a>路径规划</h4><h4 id="激光雷达-SLAM"><a href="#激光雷达-SLAM" class="headerlink" title="激光雷达-SLAM"></a>激光雷达-SLAM</h4><p><img src="https://gitee.com/peng_xiang_li/Blogimage/raw/master/CSDN_51che/src=http---inews.gtimg.com-newsapp_match-0-5577924328-0.jpg&refer=http---inews.gtimg.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
